import gql from 'graphql-tag';
import * as Urql from '@urql/vue';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Any: any;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  Map: any;
  Time: any;
  Upload: any;
};

export type CreateLabelInput = {
  name: Scalars['String'];
};

export type CreatePostInput = {
  content: Scalars['String'];
  labelIDs?: InputMaybe<Array<Scalars['ID']>>;
  publishedAt?: InputMaybe<Scalars['Time']>;
  slug: Scalars['String'];
  title: Scalars['String'];
};

export type GithubUser = {
  __typename?: 'GithubUser';
  avatarURL: Scalars['String'];
  bio: Scalars['String'];
  createdAt: Timestamp;
  email: Scalars['String'];
  followers: Scalars['Int'];
  following: Scalars['Int'];
  htmlurl: Scalars['String'];
  id: Scalars['Int'];
  location: Scalars['String'];
  login: Scalars['String'];
  name: Scalars['String'];
  publicRepos: Scalars['Int'];
  updatedAt: Timestamp;
};

export type Label = Node & {
  __typename?: 'Label';
  createTime: Scalars['Time'];
  id: Scalars['ID'];
  name: Scalars['String'];
  posts: PostConnection;
  updateTime: Scalars['Time'];
};


export type LabelPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};

/** A connection to a list of items. */
export type LabelConnection = {
  __typename?: 'LabelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Ordering options for Label connections */
export type LabelOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Labels. */
  field: LabelOrderField;
};

/** Properties by which Label connections can be ordered. */
export enum LabelOrderField {
  Name = 'NAME'
}

/**
 * LabelWhereInput is used for filtering Label objects.
 * Input was generated by ent.
 */
export type LabelWhereInput = {
  and?: InputMaybe<Array<LabelWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<LabelWhereInput>;
  or?: InputMaybe<Array<LabelWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Link = {
  __typename?: 'Link';
  name: Scalars['String'];
  url: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  createLabel: Label;
  createPost: Post;
  deleteLabel: Scalars['ID'];
  deletePost: Scalars['ID'];
  ping?: Maybe<Scalars['String']>;
  updateLabel: Label;
  updatePost: Post;
};


export type MutationCreateLabelArgs = {
  input: CreateLabelInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationDeleteLabelArgs = {
  id: Scalars['ID'];
};


export type MutationDeletePostArgs = {
  id: Scalars['ID'];
};


export type MutationUpdateLabelArgs = {
  id: Scalars['ID'];
  input: UpdateLabelInput;
};


export type MutationUpdatePostArgs = {
  id: Scalars['ID'];
  input: UpdatePostInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Post = Node & {
  __typename?: 'Post';
  author: User;
  content: Scalars['String'];
  contentHTML: Scalars['String'];
  createTime: Scalars['Time'];
  id: Scalars['ID'];
  labels: LabelConnection;
  publishedAt: Scalars['Time'];
  slug: Scalars['String'];
  title: Scalars['String'];
  updateTime: Scalars['Time'];
};


export type PostLabelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelOrder>;
  where?: InputMaybe<LabelWhereInput>;
};

/** A connection to a list of items. */
export type PostConnection = {
  __typename?: 'PostConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PostEdge = {
  __typename?: 'PostEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Post>;
};

/** Ordering options for Post connections */
export type PostOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Posts. */
  field: PostOrderField;
};

/** Properties by which Post connections can be ordered. */
export enum PostOrderField {
  Date = 'DATE',
  Slug = 'SLUG',
  Title = 'TITLE'
}

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  and?: InputMaybe<Array<PostWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']>;
  contentContains?: InputMaybe<Scalars['String']>;
  contentContainsFold?: InputMaybe<Scalars['String']>;
  contentEqualFold?: InputMaybe<Scalars['String']>;
  contentGT?: InputMaybe<Scalars['String']>;
  contentGTE?: InputMaybe<Scalars['String']>;
  /** content_html field predicates */
  contentHTML?: InputMaybe<Scalars['String']>;
  contentHTMLContains?: InputMaybe<Scalars['String']>;
  contentHTMLContainsFold?: InputMaybe<Scalars['String']>;
  contentHTMLEqualFold?: InputMaybe<Scalars['String']>;
  contentHTMLGT?: InputMaybe<Scalars['String']>;
  contentHTMLGTE?: InputMaybe<Scalars['String']>;
  contentHTMLHasPrefix?: InputMaybe<Scalars['String']>;
  contentHTMLHasSuffix?: InputMaybe<Scalars['String']>;
  contentHTMLIn?: InputMaybe<Array<Scalars['String']>>;
  contentHTMLLT?: InputMaybe<Scalars['String']>;
  contentHTMLLTE?: InputMaybe<Scalars['String']>;
  contentHTMLNEQ?: InputMaybe<Scalars['String']>;
  contentHTMLNotIn?: InputMaybe<Array<Scalars['String']>>;
  contentHasPrefix?: InputMaybe<Scalars['String']>;
  contentHasSuffix?: InputMaybe<Scalars['String']>;
  contentIn?: InputMaybe<Array<Scalars['String']>>;
  contentLT?: InputMaybe<Scalars['String']>;
  contentLTE?: InputMaybe<Scalars['String']>;
  contentNEQ?: InputMaybe<Scalars['String']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** labels edge predicates */
  hasLabels?: InputMaybe<Scalars['Boolean']>;
  hasLabelsWith?: InputMaybe<Array<LabelWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PostWhereInput>;
  or?: InputMaybe<Array<PostWhereInput>>;
  /** published_at field predicates */
  publishedAt?: InputMaybe<Scalars['Time']>;
  publishedAtGT?: InputMaybe<Scalars['Time']>;
  publishedAtGTE?: InputMaybe<Scalars['Time']>;
  publishedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  publishedAtLT?: InputMaybe<Scalars['Time']>;
  publishedAtLTE?: InputMaybe<Scalars['Time']>;
  publishedAtNEQ?: InputMaybe<Scalars['Time']>;
  publishedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** slug field predicates */
  slug?: InputMaybe<Scalars['String']>;
  slugContains?: InputMaybe<Scalars['String']>;
  slugContainsFold?: InputMaybe<Scalars['String']>;
  slugEqualFold?: InputMaybe<Scalars['String']>;
  slugGT?: InputMaybe<Scalars['String']>;
  slugGTE?: InputMaybe<Scalars['String']>;
  slugHasPrefix?: InputMaybe<Scalars['String']>;
  slugHasSuffix?: InputMaybe<Scalars['String']>;
  slugIn?: InputMaybe<Array<Scalars['String']>>;
  slugLT?: InputMaybe<Scalars['String']>;
  slugLTE?: InputMaybe<Scalars['String']>;
  slugNEQ?: InputMaybe<Scalars['String']>;
  slugNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Query = {
  __typename?: 'Query';
  githubUser: GithubUser;
  labels: LabelConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  posts: PostConnection;
  self?: Maybe<User>;
  users: UserConnection;
  version: VersionInfo;
};


export type QueryLabelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelOrder>;
  where?: InputMaybe<LabelWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};

export type Timestamp = {
  __typename?: 'Timestamp';
  Time: Scalars['Time'];
};

export type UpdateLabelInput = {
  name: Scalars['String'];
};

export type UpdatePostInput = {
  addLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  content?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['Time']>;
  removeLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type User = Node & {
  __typename?: 'User';
  avatarURL?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  createTime: Scalars['Time'];
  email?: Maybe<Scalars['String']>;
  htmlURL?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  location?: Maybe<Scalars['String']>;
  login: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  posts: PostConnection;
  updateTime: Scalars['Time'];
  userID: Scalars['Int'];
};


export type UserPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  Email = 'EMAIL',
  Login = 'LOGIN',
  Name = 'NAME'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** avatar_url field predicates */
  avatarURL?: InputMaybe<Scalars['String']>;
  avatarURLContains?: InputMaybe<Scalars['String']>;
  avatarURLContainsFold?: InputMaybe<Scalars['String']>;
  avatarURLEqualFold?: InputMaybe<Scalars['String']>;
  avatarURLGT?: InputMaybe<Scalars['String']>;
  avatarURLGTE?: InputMaybe<Scalars['String']>;
  avatarURLHasPrefix?: InputMaybe<Scalars['String']>;
  avatarURLHasSuffix?: InputMaybe<Scalars['String']>;
  avatarURLIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLIsNil?: InputMaybe<Scalars['Boolean']>;
  avatarURLLT?: InputMaybe<Scalars['String']>;
  avatarURLLTE?: InputMaybe<Scalars['String']>;
  avatarURLNEQ?: InputMaybe<Scalars['String']>;
  avatarURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** bio field predicates */
  bio?: InputMaybe<Scalars['String']>;
  bioContains?: InputMaybe<Scalars['String']>;
  bioContainsFold?: InputMaybe<Scalars['String']>;
  bioEqualFold?: InputMaybe<Scalars['String']>;
  bioGT?: InputMaybe<Scalars['String']>;
  bioGTE?: InputMaybe<Scalars['String']>;
  bioHasPrefix?: InputMaybe<Scalars['String']>;
  bioHasSuffix?: InputMaybe<Scalars['String']>;
  bioIn?: InputMaybe<Array<Scalars['String']>>;
  bioIsNil?: InputMaybe<Scalars['Boolean']>;
  bioLT?: InputMaybe<Scalars['String']>;
  bioLTE?: InputMaybe<Scalars['String']>;
  bioNEQ?: InputMaybe<Scalars['String']>;
  bioNotIn?: InputMaybe<Array<Scalars['String']>>;
  bioNotNil?: InputMaybe<Scalars['Boolean']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailIsNil?: InputMaybe<Scalars['Boolean']>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  emailNotNil?: InputMaybe<Scalars['Boolean']>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** html_url field predicates */
  htmlURL?: InputMaybe<Scalars['String']>;
  htmlURLContains?: InputMaybe<Scalars['String']>;
  htmlURLContainsFold?: InputMaybe<Scalars['String']>;
  htmlURLEqualFold?: InputMaybe<Scalars['String']>;
  htmlURLGT?: InputMaybe<Scalars['String']>;
  htmlURLGTE?: InputMaybe<Scalars['String']>;
  htmlURLHasPrefix?: InputMaybe<Scalars['String']>;
  htmlURLHasSuffix?: InputMaybe<Scalars['String']>;
  htmlURLIn?: InputMaybe<Array<Scalars['String']>>;
  htmlURLIsNil?: InputMaybe<Scalars['Boolean']>;
  htmlURLLT?: InputMaybe<Scalars['String']>;
  htmlURLLTE?: InputMaybe<Scalars['String']>;
  htmlURLNEQ?: InputMaybe<Scalars['String']>;
  htmlURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  htmlURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** location field predicates */
  location?: InputMaybe<Scalars['String']>;
  locationContains?: InputMaybe<Scalars['String']>;
  locationContainsFold?: InputMaybe<Scalars['String']>;
  locationEqualFold?: InputMaybe<Scalars['String']>;
  locationGT?: InputMaybe<Scalars['String']>;
  locationGTE?: InputMaybe<Scalars['String']>;
  locationHasPrefix?: InputMaybe<Scalars['String']>;
  locationHasSuffix?: InputMaybe<Scalars['String']>;
  locationIn?: InputMaybe<Array<Scalars['String']>>;
  locationIsNil?: InputMaybe<Scalars['Boolean']>;
  locationLT?: InputMaybe<Scalars['String']>;
  locationLTE?: InputMaybe<Scalars['String']>;
  locationNEQ?: InputMaybe<Scalars['String']>;
  locationNotIn?: InputMaybe<Array<Scalars['String']>>;
  locationNotNil?: InputMaybe<Scalars['Boolean']>;
  /** login field predicates */
  login?: InputMaybe<Scalars['String']>;
  loginContains?: InputMaybe<Scalars['String']>;
  loginContainsFold?: InputMaybe<Scalars['String']>;
  loginEqualFold?: InputMaybe<Scalars['String']>;
  loginGT?: InputMaybe<Scalars['String']>;
  loginGTE?: InputMaybe<Scalars['String']>;
  loginHasPrefix?: InputMaybe<Scalars['String']>;
  loginHasSuffix?: InputMaybe<Scalars['String']>;
  loginIn?: InputMaybe<Array<Scalars['String']>>;
  loginLT?: InputMaybe<Scalars['String']>;
  loginLTE?: InputMaybe<Scalars['String']>;
  loginNEQ?: InputMaybe<Scalars['String']>;
  loginNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['Int']>;
  userIDGT?: InputMaybe<Scalars['Int']>;
  userIDGTE?: InputMaybe<Scalars['Int']>;
  userIDIn?: InputMaybe<Array<Scalars['Int']>>;
  userIDLT?: InputMaybe<Scalars['Int']>;
  userIDLTE?: InputMaybe<Scalars['Int']>;
  userIDNEQ?: InputMaybe<Scalars['Int']>;
  userIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type VersionInfo = {
  __typename?: 'VersionInfo';
  arch: Scalars['String'];
  command: Scalars['String'];
  commit: Scalars['String'];
  date: Scalars['String'];
  goVersion: Scalars['String'];
  links?: Maybe<Array<Link>>;
  name: Scalars['String'];
  os: Scalars['String'];
  version: Scalars['String'];
};

export type DeletePostMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePostMutation = { __typename?: 'Mutation', deletePost: string };

export type CreatePostMutationVariables = Exact<{
  input: CreatePostInput;
}>;


export type CreatePostMutation = { __typename?: 'Mutation', createPost: { __typename?: 'Post', id: string } };

export type UpdatePostMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdatePostInput;
}>;


export type UpdatePostMutation = { __typename?: 'Mutation', updatePost: { __typename?: 'Post', id: string } };

export type CreateLabelMutationVariables = Exact<{
  input: CreateLabelInput;
}>;


export type CreateLabelMutation = { __typename?: 'Mutation', createLabel: { __typename?: 'Label', id: string, name: string } };

export type BaseQueryVariables = Exact<{ [key: string]: never; }>;


export type BaseQuery = { __typename?: 'Query', self?: { __typename?: 'User', id: string, name?: string | null, login: string, avatarURL?: string | null } | null, githubUser: { __typename?: 'GithubUser', login: string, name: string, avatarURL: string, bio: string, email: string, location: string, htmlurl: string }, version: { __typename?: 'VersionInfo', commit: string, goVersion: string, date: string } };

export type GetPostContentQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetPostContentQuery = { __typename?: 'Query', posts: { __typename?: 'PostConnection', edges?: Array<{ __typename?: 'PostEdge', node?: { __typename?: 'Post', id: string, title: string, slug: string, contentHTML: string, publishedAt: any, author: { __typename?: 'User', name?: string | null, login: string, avatarURL?: string | null, htmlURL?: string | null }, labels: { __typename?: 'LabelConnection', edges?: Array<{ __typename?: 'LabelEdge', node?: { __typename?: 'Label', id: string, name: string } | null } | null> | null } } | null } | null> | null } };

export type GetPostsQueryVariables = Exact<{
  count?: InputMaybe<Scalars['Int']>;
  cursor?: InputMaybe<Scalars['Cursor']>;
  order?: InputMaybe<OrderDirection>;
  orderBy?: InputMaybe<PostOrderField>;
}>;


export type GetPostsQuery = { __typename?: 'Query', posts: { __typename?: 'PostConnection', edges?: Array<{ __typename?: 'PostEdge', node?: { __typename?: 'Post', id: string, title: string, slug: string, publishedAt: any, labels: { __typename?: 'LabelConnection', edges?: Array<{ __typename?: 'LabelEdge', node?: { __typename?: 'Label', id: string, name: string } | null } | null> | null }, author: { __typename?: 'User', login: string, avatarURL?: string | null } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null } } };

export type GetLabelsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetLabelsQuery = { __typename?: 'Query', labels: { __typename?: 'LabelConnection', edges?: Array<{ __typename?: 'LabelEdge', node?: { __typename?: 'Label', id: string, name: string } | null } | null> | null } };


export const DeletePostDocument = gql`
    mutation deletePost($id: ID!) {
  deletePost(id: $id)
}
    `;

export function useDeletePostMutation() {
  return Urql.useMutation<DeletePostMutation, DeletePostMutationVariables>(DeletePostDocument);
};
export const CreatePostDocument = gql`
    mutation createPost($input: CreatePostInput!) {
  createPost(input: $input) {
    id
  }
}
    `;

export function useCreatePostMutation() {
  return Urql.useMutation<CreatePostMutation, CreatePostMutationVariables>(CreatePostDocument);
};
export const UpdatePostDocument = gql`
    mutation updatePost($id: ID!, $input: UpdatePostInput!) {
  updatePost(id: $id, input: $input) {
    id
  }
}
    `;

export function useUpdatePostMutation() {
  return Urql.useMutation<UpdatePostMutation, UpdatePostMutationVariables>(UpdatePostDocument);
};
export const CreateLabelDocument = gql`
    mutation createLabel($input: CreateLabelInput!) {
  createLabel(input: $input) {
    id
    name
  }
}
    `;

export function useCreateLabelMutation() {
  return Urql.useMutation<CreateLabelMutation, CreateLabelMutationVariables>(CreateLabelDocument);
};
export const BaseDocument = gql`
    query base {
  self {
    id
    name
    login
    avatarURL
  }
  githubUser {
    login
    name
    avatarURL
    bio
    email
    location
    htmlurl
  }
  version {
    commit
    goVersion
    date
  }
}
    `;

export function useBaseQuery(options: Omit<Urql.UseQueryArgs<never, BaseQueryVariables>, 'query'> = {}) {
  return Urql.useQuery<BaseQuery>({ query: BaseDocument, ...options });
};
export const GetPostContentDocument = gql`
    query getPostContent($slug: String!) {
  posts(where: {slugEqualFold: $slug}) {
    edges {
      node {
        id
        title
        slug
        contentHTML
        author {
          name
          login
          avatarURL
          htmlURL
        }
        labels {
          edges {
            node {
              id
              name
            }
          }
        }
        publishedAt
      }
    }
  }
}
    `;

export function useGetPostContentQuery(options: Omit<Urql.UseQueryArgs<never, GetPostContentQueryVariables>, 'query'> = {}) {
  return Urql.useQuery<GetPostContentQuery>({ query: GetPostContentDocument, ...options });
};
export const GetPostsDocument = gql`
    query getPosts($count: Int = 25, $cursor: Cursor, $order: OrderDirection = DESC, $orderBy: PostOrderField = DATE) {
  posts(
    first: $count
    after: $cursor
    orderBy: {direction: $order, field: $orderBy}
  ) {
    edges {
      node {
        id
        title
        slug
        publishedAt
        labels {
          edges {
            node {
              id
              name
            }
          }
        }
        author {
          login
          avatarURL
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
    `;

export function useGetPostsQuery(options: Omit<Urql.UseQueryArgs<never, GetPostsQueryVariables>, 'query'> = {}) {
  return Urql.useQuery<GetPostsQuery>({ query: GetPostsDocument, ...options });
};
export const GetLabelsDocument = gql`
    query getLabels {
  labels(first: 100, orderBy: {direction: ASC, field: NAME}) {
    edges {
      node {
        id
        name
      }
    }
  }
}
    `;

export function useGetLabelsQuery(options: Omit<Urql.UseQueryArgs<never, GetLabelsQueryVariables>, 'query'> = {}) {
  return Urql.useQuery<GetLabelsQuery>({ query: GetLabelsDocument, ...options });
};