/**
 * Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
 * this source code is governed by the MIT license that can be found in
 * the LICENSE file.
 */

// This file is auto-generated by @hey-api/openapi-ts

export const CodingStatsSchema = {
    properties: {
        calculated_days: {
            type: 'integer',
            minimum: 0
        },
        languages: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/LanguageStat'
            }
        },
        summary: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/CodingStatsSummary'
            }
        },
        total_duration: {
            type: 'string',
            example: '95 hrs 19 mins'
        },
        total_duration_short: {
            type: 'string',
            example: '95 hrs'
        },
        total_seconds: {
            type: 'integer',
            minimum: 0
        }
    },
    required: ['calculated_days', 'languages', 'summary', 'total_duration', 'total_duration_short', 'total_seconds']
} as const;

export const CodingStatsSummarySchema = {
    type: 'object',
    properties: {
        hex_color: {
            type: 'string',
            example: '#ff0000'
        },
        key: {
            type: 'string',
            example: 'Go'
        },
        percentage: {
            type: 'integer',
            maximum: 100,
            minimum: 0
        },
        title_length: {
            type: 'integer',
            minimum: 0
        },
        total_duration: {
            type: 'string',
            example: '95 hrs 19 mins'
        },
        total_seconds: {
            type: 'integer',
            minimum: 0
        }
    },
    required: ['hex_color', 'key', 'percentage', 'total_duration', 'total_seconds', 'title_length']
} as const;

export const ErrorBadRequestSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Bad Request'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 400
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorConflictSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Conflict'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 409
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorForbiddenSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Forbidden'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 403
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorInternalServerErrorSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Internal Server Error'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 500
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorNotFoundSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Not Found'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 404
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorTooManyRequestsSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Too Many Requests'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 429
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const ErrorUnauthorizedSchema = {
    type: 'object',
    properties: {
        error: {
            description: 'The underlying error, which may be masked when debugging is disabled.',
            type: 'string'
        },
        type: {
            description: 'A summary of the error code based off the HTTP status code or application error code.',
            type: 'string',
            example: 'Unauthorized'
        },
        code: {
            description: 'The HTTP status code or other internal application error code.',
            type: 'integer',
            example: 401
        },
        request_id: {
            description: 'The unique request ID for this error.',
            type: 'string',
            example: 'cb6f6f9c1783cdc9752cee2a4e95dd4c'
        },
        timestamp: {
            description: 'The timestamp of the error, in RFC3339 format.',
            type: 'string',
            format: 'date-time',
            example: '2024-04-26T12:19:01Z'
        }
    },
    required: ['error', 'type', 'code', 'timestamp']
} as const;

export const FilterOperationSchema = {
    description: 'Specifies how to combine multiple filters.',
    type: 'string',
    enum: ['and', 'or'],
    default: 'and'
} as const;

export const GithubAssetSchema = {
    description: 'A single GithubAsset entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the GithubAsset entity.',
            type: 'integer'
        },
        asset_id: {
            description: 'The ID of the asset.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        browser_download_url: {
            description: 'The URL of the asset.',
            type: 'string',
            example: 'https://github.com/lrstanley/entrest/releases/download/v0.1.0/entrest-v0.1.0-linux-amd64.tar.gz'
        },
        name: {
            description: 'The name of the asset.',
            type: 'string'
        },
        label: {
            description: 'The label of the asset.',
            type: 'string'
        },
        state: {
            description: 'The state of the asset.',
            type: 'string'
        },
        content_type: {
            description: 'The content type of the asset.',
            type: 'string'
        },
        size: {
            description: 'The size of the asset in bytes.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        download_count: {
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        created_at: {
            description: 'The date the asset was created.',
            type: 'string',
            format: 'date-time'
        },
        updated_at: {
            description: 'The date the asset was last updated.',
            type: 'string',
            format: 'date-time'
        },
        uploader: {
            '$ref': '#/components/schemas/GithubUser',
            description: 'The data of the user that uploaded the asset.'
        }
    },
    required: ['id', 'asset_id', 'browser_download_url', 'name', 'content_type', 'size', 'download_count', 'created_at', 'uploader']
} as const;

export const GithubAssetListSchema = {
    description: 'A paginated result set of GithubAsset entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/GithubAsset'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const GithubAssetReadSchema = {
    '$ref': '#/components/schemas/GithubAsset'
} as const;

export const GithubAssetSortableFieldsSchema = {
    description: 'All potential sortable fields for GithubAsset entities.',
    type: 'string',
    enum: ['asset_id', 'created_at', 'download_count', 'id', 'label', 'name', 'random', 'release.created_at', 'release.draft', 'release.id', 'release.name', 'release.prerelease', 'release.published_at', 'release.release_id', 'release.tag_name', 'size', 'updated_at'],
    default: 'id'
} as const;

export const GithubEventSchema = {
    description: 'A single GithubEvent entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the GithubEvent entity.',
            type: 'integer'
        },
        event_id: {
            description: 'The ID of the event.',
            type: 'string'
        },
        event_type: {
            description: 'The type of the event.',
            type: 'string'
        },
        created_at: {
            description: 'The date the event was created.',
            type: 'string',
            format: 'date-time'
        },
        public: {
            description: 'Whether the event is public or not.',
            type: 'boolean',
            default: false
        },
        actor_id: {
            description: 'The ID of the actor.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        actor: {
            '$ref': '#/components/schemas/GithubUser',
            description: 'The actor data of the event.'
        },
        repo_id: {
            description: 'The ID of the repository.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        repo: {
            description: 'The repository of the event.',
            type: 'object',
            additionalProperties: true
        },
        payload: {
            description: 'The payload of the event.',
            type: 'object',
            additionalProperties: true
        }
    },
    required: ['id', 'event_id', 'event_type', 'created_at', 'public', 'actor_id', 'actor', 'repo_id', 'repo', 'payload']
} as const;

export const GithubEventListSchema = {
    description: 'A paginated result set of GithubEvent entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/GithubEvent'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const GithubEventReadSchema = {
    '$ref': '#/components/schemas/GithubEvent'
} as const;

export const GithubEventSortableFieldsSchema = {
    description: 'All potential sortable fields for GithubEvent entities.',
    type: 'string',
    enum: ['actor_id', 'created_at', 'event_id', 'event_type', 'id', 'public', 'random', 'repo_id'],
    default: 'id'
} as const;

export const GithubGistSchema = {
    description: 'A single GithubGist entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the GithubGist entity.',
            type: 'integer'
        },
        gist_id: {
            description: 'The ID of the gist.',
            type: 'string'
        },
        html_url: {
            description: 'The URL of the gist.',
            type: 'string',
            example: 'https://gist.github.com/lrstanley/c4f0a3f2b8a2f3a4c2c0'
        },
        public: {
            description: 'Whether the gist is public or not.',
            type: 'boolean'
        },
        created_at: {
            description: 'The date the gist was created.',
            type: 'string',
            format: 'date-time'
        },
        updated_at: {
            description: 'The date the gist was last updated.',
            type: 'string',
            format: 'date-time'
        },
        description: {
            description: 'The description of the gist.',
            type: 'string'
        },
        owner: {
            '$ref': '#/components/schemas/GithubUser',
            description: 'The owner data of the gist.'
        },
        name: {
            description: 'The name of the file.',
            type: 'string'
        },
        type: {
            description: 'The type of the file.',
            type: 'string'
        },
        language: {
            description: 'The programming language of the file.',
            type: 'string'
        },
        size: {
            description: 'The size of the file in bytes.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        raw_url: {
            description: 'The raw URL of the file.',
            type: 'string'
        },
        content: {
            description: 'The content of the file.',
            type: 'string'
        }
    },
    required: ['id', 'gist_id', 'html_url', 'public', 'created_at', 'updated_at', 'owner', 'name', 'type', 'size', 'raw_url', 'content']
} as const;

export const GithubGistListSchema = {
    description: 'A paginated result set of GithubGist entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/GithubGist'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const GithubGistReadSchema = {
    '$ref': '#/components/schemas/GithubGist'
} as const;

export const GithubGistSortableFieldsSchema = {
    description: 'All potential sortable fields for GithubGist entities.',
    type: 'string',
    enum: ['created_at', 'gist_id', 'id', 'language', 'name', 'public', 'random', 'size', 'type', 'updated_at'],
    default: 'id'
} as const;

export const GithubReleaseSchema = {
    description: 'A single GithubRelease entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the GithubRelease entity.',
            type: 'integer'
        },
        release_id: {
            description: 'The ID of the release.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        html_url: {
            description: 'The URL of the release.',
            type: 'string',
            example: 'https://github.com/lrstanley/entrest/releases/tag/v0.1.0'
        },
        tag_name: {
            description: 'The tag name of the release.',
            type: 'string',
            example: 'v0.1.0'
        },
        target_commitish: {
            description: "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.",
            type: 'string',
            example: 'master'
        },
        name: {
            description: 'The name of the release.',
            type: 'string'
        },
        draft: {
            description: 'Indicates whether the release is a draft.',
            type: 'boolean'
        },
        prerelease: {
            description: 'Indicates whether the release is a prerelease.',
            type: 'boolean'
        },
        created_at: {
            description: 'The date the release was created.',
            type: 'string',
            format: 'date-time'
        },
        published_at: {
            description: 'The date the release was published.',
            type: 'string',
            format: 'date-time'
        },
        author: {
            '$ref': '#/components/schemas/GithubUser'
        }
    },
    required: ['id', 'release_id', 'html_url', 'tag_name', 'target_commitish', 'draft', 'prerelease', 'created_at', 'published_at', 'author']
} as const;

export const GithubReleaseAssetListSchema = {
    description: 'List of assets associated with githubreleases (githubasset entity type).',
    type: 'array',
    items: {
        '$ref': '#/components/schemas/GithubAsset'
    }
} as const;

export const GithubReleaseEdgesSchema = {
    type: 'object',
    properties: {
        repository: {
            '$ref': '#/components/schemas/GithubRepository'
        },
        assets: {
            description: "A list of GithubAsset entities. Limited to 1000 items. If there are more results than the limit, the results are capped and you must use the associated edge endpoint with pagination -- see also the 'EagerLoadLimit' config option.",
            type: 'array',
            items: {
                '$ref': '#/components/schemas/GithubAsset'
            },
            maxItems: 1000,
            minItems: 0
        }
    },
    required: ['repository']
} as const;

export const GithubReleaseListSchema = {
    description: 'A paginated result set of GithubRelease entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/GithubReleaseRead'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const GithubReleaseReadSchema = {
    description: 'A single GithubRelease entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/GithubRelease'
        },
        {
            type: 'object',
            properties: {
                edges: {
                    '$ref': '#/components/schemas/GithubReleaseEdges'
                }
            },
            required: ['edges']
        }
    ]
} as const;

export const GithubReleaseSortableFieldsSchema = {
    description: 'All potential sortable fields for GithubRelease entities.',
    type: 'string',
    enum: ['assets.asset_id.sum', 'assets.count', 'assets.download_count.sum', 'assets.size.sum', 'created_at', 'draft', 'id', 'name', 'prerelease', 'published_at', 'random', 'release_id', 'repository.archived', 'repository.created_at', 'repository.default_branch', 'repository.fork', 'repository.full_name', 'repository.has_issues', 'repository.id', 'repository.is_template', 'repository.name', 'repository.owner_login', 'repository.public', 'repository.pushed_at', 'repository.repo_id', 'repository.star_count', 'repository.updated_at', 'tag_name'],
    default: 'id'
} as const;

export const GithubRepositorySchema = {
    description: 'A single GithubRepository entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the GithubRepository entity.',
            type: 'integer'
        },
        repo_id: {
            description: 'The ID of the repository.',
            type: 'integer',
            format: 'int64',
            maximum: 9223372036854776000,
            minimum: -9223372036854776000
        },
        name: {
            description: 'The name of the repository.',
            type: 'string',
            example: 'entrest'
        },
        full_name: {
            description: 'The full name of the repository, which includes the owner.',
            type: 'string',
            example: 'lrstanley/entrest'
        },
        owner_login: {
            description: 'The username which owns the repository (user or organization).',
            type: 'string',
            example: 'lrstanley'
        },
        owner: {
            '$ref': '#/components/schemas/GithubUser',
            description: 'The owner data of the repository.'
        },
        public: {
            description: 'Whether the repository is public or not.',
            type: 'boolean',
            default: false
        },
        html_url: {
            description: 'The URL of the repository.',
            type: 'string',
            example: 'https://github.com/lrstanley/entrest'
        },
        description: {
            description: 'The description of the repository.',
            type: 'string'
        },
        fork: {
            description: 'Whether the repository is a fork or not.',
            type: 'boolean',
            default: false
        },
        homepage: {
            description: 'The homepage of the repository.',
            type: 'string',
            example: 'https://example.com'
        },
        star_count: {
            description: 'The number of stars the repository has.',
            type: 'integer',
            default: 0
        },
        default_branch: {
            description: 'The default branch of the repository.',
            type: 'string',
            example: 'master'
        },
        is_template: {
            description: 'Whether the repository is a template repo or not.',
            type: 'boolean',
            default: false
        },
        has_issues: {
            description: 'Whether the repository has issues enabled or not.',
            type: 'boolean',
            default: true
        },
        archived: {
            description: 'Whether the repository is archived or not.',
            type: 'boolean',
            default: false
        },
        pushed_at: {
            description: 'The date the repository was last pushed to.',
            type: 'string',
            format: 'date-time'
        },
        created_at: {
            description: 'The date the repository was created.',
            type: 'string',
            format: 'date-time'
        },
        updated_at: {
            description: 'The date the repository was last updated.',
            type: 'string',
            format: 'date-time'
        },
        license: {
            type: 'object',
            additionalProperties: true
        }
    },
    required: ['id', 'repo_id', 'name', 'full_name', 'owner_login', 'owner', 'public', 'html_url', 'fork', 'star_count', 'default_branch', 'is_template', 'has_issues', 'archived', 'created_at']
} as const;

export const GithubRepositoryEdgesSchema = {
    type: 'object',
    properties: {
        labels: {
            description: "A list of Label entities. Limited to 1000 items. If there are more results than the limit, the results are capped and you must use the associated edge endpoint with pagination -- see also the 'EagerLoadLimit' config option.",
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Label'
            },
            maxItems: 1000,
            minItems: 0
        }
    }
} as const;

export const GithubRepositoryLabelListSchema = {
    description: 'List of labels associated with githubrepositories (label entity type).',
    type: 'array',
    items: {
        '$ref': '#/components/schemas/Label'
    }
} as const;

export const GithubRepositoryListSchema = {
    description: 'A paginated result set of GithubRepository entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/GithubRepositoryRead'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const GithubRepositoryReadSchema = {
    description: 'A single GithubRepository entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/GithubRepository'
        },
        {
            type: 'object',
            properties: {
                edges: {
                    '$ref': '#/components/schemas/GithubRepositoryEdges'
                }
            },
            required: ['edges']
        }
    ]
} as const;

export const GithubRepositorySortableFieldsSchema = {
    description: 'All potential sortable fields for GithubRepository entities.',
    type: 'string',
    enum: ['archived', 'created_at', 'default_branch', 'fork', 'full_name', 'has_issues', 'id', 'is_template', 'labels.count', 'name', 'owner_login', 'public', 'pushed_at', 'random', 'releases.count', 'releases.release_id.sum', 'repo_id', 'star_count', 'updated_at'],
    default: 'id'
} as const;

export const GithubStatsSchema = {
    type: 'object',
    properties: {
        all_issues: {
            type: 'integer'
        },
        closed_issues: {
            type: 'integer'
        },
        commits_year: {
            type: 'integer'
        },
        contributed_repositories: {
            type: 'integer'
        },
        open_issues: {
            type: 'integer'
        },
        pull_requests: {
            type: 'integer'
        },
        repositories: {
            type: 'integer'
        },
        stars: {
            type: 'integer'
        }
    },
    required: ['commits_year', 'pull_requests', 'open_issues', 'closed_issues', 'all_issues', 'repositories', 'contributed_repositories', 'stars']
} as const;

export const GithubUserSchema = {
    type: 'object',
    properties: {
        avatar_url: {
            type: 'string'
        },
        bio: {
            type: 'string'
        },
        collaborators: {
            type: 'integer'
        },
        created_at: {
            type: 'string'
        },
        email: {
            type: 'string'
        },
        followers: {
            type: 'integer'
        },
        following: {
            type: 'integer'
        },
        html_url: {
            type: 'string'
        },
        id: {
            type: 'integer'
        },
        location: {
            type: 'string'
        },
        login: {
            type: 'string'
        },
        name: {
            type: 'string'
        },
        owned_private_repos: {
            type: 'integer'
        },
        private_gists: {
            type: 'integer'
        },
        public_gists: {
            type: 'integer'
        },
        public_repos: {
            type: 'integer'
        },
        total_private_repos: {
            type: 'integer'
        },
        type: {
            type: 'string'
        },
        updated_at: {
            type: 'string'
        }
    },
    additionalProperties: true,
    required: ['login', 'id', 'avatar_url', 'html_url', 'name', 'location', 'email', 'bio', 'public_repos', 'public_gists', 'followers', 'following', 'created_at', 'updated_at', 'type', 'total_private_repos', 'owned_private_repos', 'private_gists', 'collaborators']
} as const;

export const LabelSchema = {
    description: 'A single Label entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the Label entity.',
            type: 'integer'
        },
        create_time: {
            description: 'Time the entity was created.',
            type: 'string',
            format: 'date-time'
        },
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        name: {
            description: 'Label name.',
            type: 'string',
            example: 'golang'
        }
    },
    required: ['id', 'create_time', 'update_time', 'name']
} as const;

export const LabelCountSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/Label'
        },
        {
            type: 'object',
            properties: {
                githubrepository_count: {
                    type: 'integer'
                },
                post_count: {
                    type: 'integer'
                },
                total_count: {
                    type: 'integer'
                }
            },
            required: ['githubrepository_count', 'post_count', 'total_count']
        }
    ]
} as const;

export const LabelCountListSchema = {
    type: 'array',
    items: {
        '$ref': '#/components/schemas/LabelCount'
    }
} as const;

export const LabelCreateSchema = {
    description: 'A single Label entity and the fields that can be created/updated.',
    type: 'object',
    properties: {
        create_time: {
            description: 'Time the entity was created.',
            type: 'string',
            format: 'date-time'
        },
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        name: {
            description: 'Label name.',
            type: 'string',
            example: 'golang'
        },
        posts: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        github_repositories: {
            type: 'array',
            items: {
                type: 'integer'
            }
        }
    },
    required: ['name']
} as const;

export const LabelListSchema = {
    description: 'A paginated result set of Label entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/Label'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const LabelReadSchema = {
    '$ref': '#/components/schemas/Label'
} as const;

export const LabelSortableFieldsSchema = {
    description: 'All potential sortable fields for Label entities.',
    type: 'string',
    enum: ['create_time', 'github_repositories.count', 'github_repositories.repo_id.sum', 'github_repositories.star_count.sum', 'id', 'name', 'posts.count', 'posts.view_count.sum', 'random', 'update_time'],
    default: 'id'
} as const;

export const LabelUpdateSchema = {
    description: 'A single Label entity and the fields that can be created/updated.',
    type: 'object',
    properties: {
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        name: {
            description: 'Label name.',
            type: 'string',
            example: 'golang'
        },
        add_posts: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        remove_posts: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        add_github_repositories: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        remove_github_repositories: {
            type: 'array',
            items: {
                type: 'integer'
            }
        }
    }
} as const;

export const LanguageStatSchema = {
    properties: {
        hex_color: {
            type: 'string',
            example: '#00ADD8'
        },
        key: {
            type: 'string',
            example: 'Go'
        },
        total: {
            description: 'Total seconds using the language.',
            type: 'integer',
            minimum: 0
        },
        total_duration: {
            type: 'string',
            example: '95 hrs 19 mins'
        }
    },
    required: ['hex_color', 'key', 'total_duration', 'total']
} as const;

export const OutdatedRepositoryReleaseSchema = {
    properties: {
        release: {
            '$ref': '#/components/schemas/GithubReleaseRead'
        },
        repository: {
            '$ref': '#/components/schemas/GithubRepositoryRead'
        }
    },
    required: ['repository', 'release']
} as const;

export const PagedResponseSchema = {
    type: 'object',
    properties: {
        page: {
            description: 'Page which the results are associated with.',
            type: 'integer',
            minimum: 1,
            example: 1
        },
        last_page: {
            description: 'The number of the last page of results.',
            type: 'integer',
            minimum: 1,
            example: 3
        },
        is_last_page: {
            description: 'If true, the current results are the last page of results.',
            type: 'boolean',
            example: false
        },
        total_count: {
            description: 'The total number of results based on the provided query.',
            type: 'integer',
            minimum: 0,
            example: 123
        }
    },
    required: ['page', 'last_page', 'is_last_page', 'total_count']
} as const;

export const PostSchema = {
    description: 'A single Post entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the Post entity.',
            type: 'integer'
        },
        create_time: {
            description: 'Time the entity was created.',
            type: 'string',
            format: 'date-time'
        },
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        slug: {
            description: 'Post slug.',
            type: 'string',
            example: 'hello-world'
        },
        title: {
            description: 'Post title.',
            type: 'string',
            example: 'Hello World'
        },
        content: {
            description: 'Post content in Markdown.',
            type: 'string',
            example: `## Title

Hello World`
        },
        content_html: {
            description: "Generated HTML content (produced from 'content' field).",
            type: 'string',
            example: `<h1>Title</h1>

<p>Hello World</p>`
        },
        summary: {
            description: 'Post summary, which is produced from the first sentence or two of the post content.',
            type: 'string',
            example: 'Some example content here...'
        },
        published_at: {
            type: 'string',
            format: 'date-time'
        },
        view_count: {
            description: 'Number of times the post has been viewed.',
            type: 'integer',
            default: 0
        },
        public: {
            description: 'Whether the post is public or not.',
            type: 'boolean',
            default: false
        }
    },
    required: ['id', 'create_time', 'update_time', 'slug', 'title', 'content', 'content_html', 'summary', 'published_at', 'view_count', 'public']
} as const;

export const PostCreateSchema = {
    description: 'A single Post entity and the fields that can be created/updated.',
    type: 'object',
    properties: {
        create_time: {
            description: 'Time the entity was created.',
            type: 'string',
            format: 'date-time'
        },
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        slug: {
            description: 'Post slug.',
            type: 'string',
            example: 'hello-world'
        },
        title: {
            description: 'Post title.',
            type: 'string',
            example: 'Hello World'
        },
        content: {
            description: 'Post content in Markdown.',
            type: 'string',
            example: `## Title

Hello World`
        },
        published_at: {
            type: 'string',
            format: 'date-time'
        },
        public: {
            description: 'Whether the post is public or not.',
            type: 'boolean',
            default: false
        },
        author: {
            type: 'integer'
        },
        labels: {
            type: 'array',
            items: {
                type: 'integer'
            }
        }
    },
    required: ['slug', 'title', 'content', 'author']
} as const;

export const PostEdgesSchema = {
    type: 'object',
    properties: {
        author: {
            '$ref': '#/components/schemas/User'
        },
        labels: {
            description: "A list of Label entities. Limited to 1000 items. If there are more results than the limit, the results are capped and you must use the associated edge endpoint with pagination -- see also the 'EagerLoadLimit' config option.",
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Label'
            },
            maxItems: 1000,
            minItems: 0
        }
    },
    required: ['author']
} as const;

export const PostLabelListSchema = {
    description: 'List of labels associated with posts (label entity type).',
    type: 'array',
    items: {
        '$ref': '#/components/schemas/Label'
    }
} as const;

export const PostListSchema = {
    description: 'A paginated result set of Post entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/PostRead'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const PostReadSchema = {
    description: 'A single Post entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/Post'
        },
        {
            type: 'object',
            properties: {
                edges: {
                    '$ref': '#/components/schemas/PostEdges'
                }
            },
            required: ['edges']
        }
    ]
} as const;

export const PostSortableFieldsSchema = {
    description: 'All potential sortable fields for Post entities.',
    type: 'string',
    enum: ['author.create_time', 'author.email', 'author.id', 'author.location', 'author.login', 'author.name', 'author.update_time', 'create_time', 'id', 'labels.count', 'public', 'published_at', 'random', 'slug', 'title', 'update_time', 'view_count'],
    default: 'id'
} as const;

export const PostUpdateSchema = {
    description: 'A single Post entity and the fields that can be created/updated.',
    type: 'object',
    properties: {
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        slug: {
            description: 'Post slug.',
            type: 'string',
            example: 'hello-world'
        },
        title: {
            description: 'Post title.',
            type: 'string',
            example: 'Hello World'
        },
        content: {
            description: 'Post content in Markdown.',
            type: 'string',
            example: `## Title

Hello World`
        },
        published_at: {
            type: 'string',
            format: 'date-time'
        },
        public: {
            description: 'Whether the post is public or not.',
            type: 'boolean',
            default: false
        },
        author: {
            type: 'integer'
        },
        add_labels: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        remove_labels: {
            type: 'array',
            items: {
                type: 'integer'
            }
        }
    }
} as const;

export const UserSchema = {
    description: 'A single User entity.',
    type: 'object',
    properties: {
        id: {
            description: 'The ID of the User entity.',
            type: 'integer'
        },
        create_time: {
            description: 'Time the entity was created.',
            type: 'string',
            format: 'date-time'
        },
        update_time: {
            description: 'Time the entity was last updated.',
            type: 'string',
            format: 'date-time'
        },
        user_id: {
            description: 'Users GitHub ID.',
            type: 'integer',
            example: 12345
        },
        login: {
            description: 'Users GitHub login ID (username).',
            type: 'string',
            example: 'lrstanley'
        },
        name: {
            description: 'Users GitHub display name.',
            type: 'string',
            example: 'Liam Stanley'
        },
        avatar_url: {
            description: 'GitHub avatar of the user, provided by GitHub.',
            type: 'string',
            example: 'https://avatars.githubusercontent.com/u/1847365?v=4'
        },
        html_url: {
            description: 'Users GitHub profile URL.',
            type: 'string',
            example: 'https://github.com/lrstanley'
        },
        email: {
            description: 'Users GitHub email address.',
            type: 'string'
        },
        location: {
            description: 'Users GitHub location.',
            type: 'string'
        },
        bio: {
            description: 'Users GitHub bio.',
            type: 'string'
        }
    },
    required: ['id', 'create_time', 'update_time', 'user_id', 'login']
} as const;

export const UserListSchema = {
    description: 'A paginated result set of User entities. Includes eager-loaded edges (if any) for each entity.',
    allOf: [
        {
            '$ref': '#/components/schemas/PagedResponse'
        },
        {
            type: 'object',
            properties: {
                content: {
                    type: 'array',
                    items: {
                        '$ref': '#/components/schemas/User'
                    }
                }
            },
            required: ['content']
        }
    ]
} as const;

export const UserReadSchema = {
    '$ref': '#/components/schemas/User'
} as const;

export const UserSortableFieldsSchema = {
    description: 'All potential sortable fields for User entities.',
    type: 'string',
    enum: ['create_time', 'email', 'id', 'location', 'login', 'name', 'posts.count', 'posts.view_count.sum', 'random', 'update_time'],
    default: 'id'
} as const;

export const VersionInfoSchema = {
    type: 'object',
    properties: {
        arch: {
            description: 'CPU Architecture for this build.',
            type: 'string',
            example: 'amd64'
        },
        build_commit: {
            description: 'VCS commit SHA.',
            type: 'string'
        },
        build_date: {
            description: 'VCS commit date.',
            type: 'string'
        },
        build_version: {
            description: 'Build version.',
            type: 'string',
            example: 'v1.0.0'
        },
        command: {
            description: 'Executable name where the command was called from.',
            type: 'string',
            example: 'httpserver'
        },
        go_version: {
            description: 'Version of Go that produced this binary.',
            type: 'string',
            example: 'go1.20.3'
        },
        links: {
            description: 'Links to other resources.',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/VersionLink'
            }
        },
        name: {
            description: 'Name of cli tool.',
            type: 'string',
            example: 'github.com/lrstanley/entrest'
        },
        os: {
            description: 'Operating system for this build.',
            type: 'string',
            example: 'linux'
        }
    },
    required: ['arch', 'build_commit', 'build_date', 'build_version', 'command', 'go_version', 'name', 'os', 'links']
} as const;

export const VersionLinkSchema = {
    type: 'object',
    properties: {
        name: {
            description: 'Name of the link.',
            type: 'string',
            example: 'github'
        },
        url: {
            description: 'URL of the link.',
            type: 'string',
            example: 'https://github.com/lrstanley/liam.sh'
        }
    },
    required: ['name', 'url']
} as const;