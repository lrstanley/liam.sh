// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package ent

import (
	"github.com/lrstanley/liam.sh/internal/ent/githubasset"
	"github.com/lrstanley/liam.sh/internal/ent/githubevent"
	"github.com/lrstanley/liam.sh/internal/ent/githubrelease"
	"github.com/lrstanley/liam.sh/internal/ent/githubrepository"
	"github.com/lrstanley/liam.sh/internal/ent/label"
	"github.com/lrstanley/liam.sh/internal/ent/post"
	"github.com/lrstanley/liam.sh/internal/ent/predicate"
	"github.com/lrstanley/liam.sh/internal/ent/user"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 7)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   githubasset.Table,
			Columns: githubasset.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: githubasset.FieldID,
			},
		},
		Type: "GithubAsset",
		Fields: map[string]*sqlgraph.FieldSpec{
			githubasset.FieldAssetID:            {Type: field.TypeInt64, Column: githubasset.FieldAssetID},
			githubasset.FieldBrowserDownloadURL: {Type: field.TypeString, Column: githubasset.FieldBrowserDownloadURL},
			githubasset.FieldName:               {Type: field.TypeString, Column: githubasset.FieldName},
			githubasset.FieldLabel:              {Type: field.TypeString, Column: githubasset.FieldLabel},
			githubasset.FieldState:              {Type: field.TypeString, Column: githubasset.FieldState},
			githubasset.FieldContentType:        {Type: field.TypeString, Column: githubasset.FieldContentType},
			githubasset.FieldSize:               {Type: field.TypeInt64, Column: githubasset.FieldSize},
			githubasset.FieldDownloadCount:      {Type: field.TypeInt64, Column: githubasset.FieldDownloadCount},
			githubasset.FieldCreatedAt:          {Type: field.TypeTime, Column: githubasset.FieldCreatedAt},
			githubasset.FieldUpdatedAt:          {Type: field.TypeTime, Column: githubasset.FieldUpdatedAt},
			githubasset.FieldUploader:           {Type: field.TypeJSON, Column: githubasset.FieldUploader},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   githubevent.Table,
			Columns: githubevent.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: githubevent.FieldID,
			},
		},
		Type: "GithubEvent",
		Fields: map[string]*sqlgraph.FieldSpec{
			githubevent.FieldEventID:   {Type: field.TypeString, Column: githubevent.FieldEventID},
			githubevent.FieldEventType: {Type: field.TypeString, Column: githubevent.FieldEventType},
			githubevent.FieldCreatedAt: {Type: field.TypeTime, Column: githubevent.FieldCreatedAt},
			githubevent.FieldPublic:    {Type: field.TypeBool, Column: githubevent.FieldPublic},
			githubevent.FieldActorID:   {Type: field.TypeInt64, Column: githubevent.FieldActorID},
			githubevent.FieldActor:     {Type: field.TypeJSON, Column: githubevent.FieldActor},
			githubevent.FieldRepoID:    {Type: field.TypeInt64, Column: githubevent.FieldRepoID},
			githubevent.FieldRepo:      {Type: field.TypeJSON, Column: githubevent.FieldRepo},
			githubevent.FieldPayload:   {Type: field.TypeJSON, Column: githubevent.FieldPayload},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   githubrelease.Table,
			Columns: githubrelease.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: githubrelease.FieldID,
			},
		},
		Type: "GithubRelease",
		Fields: map[string]*sqlgraph.FieldSpec{
			githubrelease.FieldReleaseID:       {Type: field.TypeInt64, Column: githubrelease.FieldReleaseID},
			githubrelease.FieldHTMLURL:         {Type: field.TypeString, Column: githubrelease.FieldHTMLURL},
			githubrelease.FieldTagName:         {Type: field.TypeString, Column: githubrelease.FieldTagName},
			githubrelease.FieldTargetCommitish: {Type: field.TypeString, Column: githubrelease.FieldTargetCommitish},
			githubrelease.FieldName:            {Type: field.TypeString, Column: githubrelease.FieldName},
			githubrelease.FieldDraft:           {Type: field.TypeBool, Column: githubrelease.FieldDraft},
			githubrelease.FieldPrerelease:      {Type: field.TypeBool, Column: githubrelease.FieldPrerelease},
			githubrelease.FieldCreatedAt:       {Type: field.TypeTime, Column: githubrelease.FieldCreatedAt},
			githubrelease.FieldPublishedAt:     {Type: field.TypeTime, Column: githubrelease.FieldPublishedAt},
			githubrelease.FieldAuthor:          {Type: field.TypeJSON, Column: githubrelease.FieldAuthor},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   githubrepository.Table,
			Columns: githubrepository.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: githubrepository.FieldID,
			},
		},
		Type: "GithubRepository",
		Fields: map[string]*sqlgraph.FieldSpec{
			githubrepository.FieldRepoID:        {Type: field.TypeInt64, Column: githubrepository.FieldRepoID},
			githubrepository.FieldName:          {Type: field.TypeString, Column: githubrepository.FieldName},
			githubrepository.FieldFullName:      {Type: field.TypeString, Column: githubrepository.FieldFullName},
			githubrepository.FieldOwnerLogin:    {Type: field.TypeString, Column: githubrepository.FieldOwnerLogin},
			githubrepository.FieldOwner:         {Type: field.TypeJSON, Column: githubrepository.FieldOwner},
			githubrepository.FieldPublic:        {Type: field.TypeBool, Column: githubrepository.FieldPublic},
			githubrepository.FieldHTMLURL:       {Type: field.TypeString, Column: githubrepository.FieldHTMLURL},
			githubrepository.FieldDescription:   {Type: field.TypeString, Column: githubrepository.FieldDescription},
			githubrepository.FieldFork:          {Type: field.TypeBool, Column: githubrepository.FieldFork},
			githubrepository.FieldHomepage:      {Type: field.TypeString, Column: githubrepository.FieldHomepage},
			githubrepository.FieldStarCount:     {Type: field.TypeInt, Column: githubrepository.FieldStarCount},
			githubrepository.FieldDefaultBranch: {Type: field.TypeString, Column: githubrepository.FieldDefaultBranch},
			githubrepository.FieldIsTemplate:    {Type: field.TypeBool, Column: githubrepository.FieldIsTemplate},
			githubrepository.FieldHasIssues:     {Type: field.TypeBool, Column: githubrepository.FieldHasIssues},
			githubrepository.FieldArchived:      {Type: field.TypeBool, Column: githubrepository.FieldArchived},
			githubrepository.FieldPushedAt:      {Type: field.TypeTime, Column: githubrepository.FieldPushedAt},
			githubrepository.FieldCreatedAt:     {Type: field.TypeTime, Column: githubrepository.FieldCreatedAt},
			githubrepository.FieldUpdatedAt:     {Type: field.TypeTime, Column: githubrepository.FieldUpdatedAt},
			githubrepository.FieldLicense:       {Type: field.TypeJSON, Column: githubrepository.FieldLicense},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   label.Table,
			Columns: label.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: label.FieldID,
			},
		},
		Type: "Label",
		Fields: map[string]*sqlgraph.FieldSpec{
			label.FieldCreateTime: {Type: field.TypeTime, Column: label.FieldCreateTime},
			label.FieldUpdateTime: {Type: field.TypeTime, Column: label.FieldUpdateTime},
			label.FieldName:       {Type: field.TypeString, Column: label.FieldName},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   post.Table,
			Columns: post.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: post.FieldID,
			},
		},
		Type: "Post",
		Fields: map[string]*sqlgraph.FieldSpec{
			post.FieldCreateTime:  {Type: field.TypeTime, Column: post.FieldCreateTime},
			post.FieldUpdateTime:  {Type: field.TypeTime, Column: post.FieldUpdateTime},
			post.FieldSlug:        {Type: field.TypeString, Column: post.FieldSlug},
			post.FieldTitle:       {Type: field.TypeString, Column: post.FieldTitle},
			post.FieldContent:     {Type: field.TypeString, Column: post.FieldContent},
			post.FieldContentHTML: {Type: field.TypeString, Column: post.FieldContentHTML},
			post.FieldSummary:     {Type: field.TypeString, Column: post.FieldSummary},
			post.FieldPublishedAt: {Type: field.TypeTime, Column: post.FieldPublishedAt},
			post.FieldViewCount:   {Type: field.TypeInt, Column: post.FieldViewCount},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldCreateTime: {Type: field.TypeTime, Column: user.FieldCreateTime},
			user.FieldUpdateTime: {Type: field.TypeTime, Column: user.FieldUpdateTime},
			user.FieldUserID:     {Type: field.TypeInt, Column: user.FieldUserID},
			user.FieldLogin:      {Type: field.TypeString, Column: user.FieldLogin},
			user.FieldName:       {Type: field.TypeString, Column: user.FieldName},
			user.FieldAvatarURL:  {Type: field.TypeString, Column: user.FieldAvatarURL},
			user.FieldHTMLURL:    {Type: field.TypeString, Column: user.FieldHTMLURL},
			user.FieldEmail:      {Type: field.TypeString, Column: user.FieldEmail},
			user.FieldLocation:   {Type: field.TypeString, Column: user.FieldLocation},
			user.FieldBio:        {Type: field.TypeString, Column: user.FieldBio},
		},
	}
	graph.MustAddE(
		"release",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   githubasset.ReleaseTable,
			Columns: []string{githubasset.ReleaseColumn},
			Bidi:    false,
		},
		"GithubAsset",
		"GithubRelease",
	)
	graph.MustAddE(
		"repository",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   githubrelease.RepositoryTable,
			Columns: []string{githubrelease.RepositoryColumn},
			Bidi:    false,
		},
		"GithubRelease",
		"GithubRepository",
	)
	graph.MustAddE(
		"assets",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   githubrelease.AssetsTable,
			Columns: []string{githubrelease.AssetsColumn},
			Bidi:    false,
		},
		"GithubRelease",
		"GithubAsset",
	)
	graph.MustAddE(
		"labels",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   githubrepository.LabelsTable,
			Columns: githubrepository.LabelsPrimaryKey,
			Bidi:    false,
		},
		"GithubRepository",
		"Label",
	)
	graph.MustAddE(
		"releases",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   githubrepository.ReleasesTable,
			Columns: []string{githubrepository.ReleasesColumn},
			Bidi:    false,
		},
		"GithubRepository",
		"GithubRelease",
	)
	graph.MustAddE(
		"posts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   label.PostsTable,
			Columns: label.PostsPrimaryKey,
			Bidi:    false,
		},
		"Label",
		"Post",
	)
	graph.MustAddE(
		"github_repositories",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   label.GithubRepositoriesTable,
			Columns: label.GithubRepositoriesPrimaryKey,
			Bidi:    false,
		},
		"Label",
		"GithubRepository",
	)
	graph.MustAddE(
		"author",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   post.AuthorTable,
			Columns: []string{post.AuthorColumn},
			Bidi:    false,
		},
		"Post",
		"User",
	)
	graph.MustAddE(
		"labels",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   post.LabelsTable,
			Columns: post.LabelsPrimaryKey,
			Bidi:    false,
		},
		"Post",
		"Label",
	)
	graph.MustAddE(
		"posts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PostsTable,
			Columns: []string{user.PostsColumn},
			Bidi:    false,
		},
		"User",
		"Post",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (gaq *GithubAssetQuery) addPredicate(pred func(s *sql.Selector)) {
	gaq.predicates = append(gaq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the GithubAssetQuery builder.
func (gaq *GithubAssetQuery) Filter() *GithubAssetFilter {
	return &GithubAssetFilter{gaq.config, gaq}
}

// addPredicate implements the predicateAdder interface.
func (m *GithubAssetMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the GithubAssetMutation builder.
func (m *GithubAssetMutation) Filter() *GithubAssetFilter {
	return &GithubAssetFilter{m.config, m}
}

// GithubAssetFilter provides a generic filtering capability at runtime for GithubAssetQuery.
type GithubAssetFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *GithubAssetFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *GithubAssetFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(githubasset.FieldID))
}

// WhereAssetID applies the entql int64 predicate on the asset_id field.
func (f *GithubAssetFilter) WhereAssetID(p entql.Int64P) {
	f.Where(p.Field(githubasset.FieldAssetID))
}

// WhereBrowserDownloadURL applies the entql string predicate on the browser_download_url field.
func (f *GithubAssetFilter) WhereBrowserDownloadURL(p entql.StringP) {
	f.Where(p.Field(githubasset.FieldBrowserDownloadURL))
}

// WhereName applies the entql string predicate on the name field.
func (f *GithubAssetFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(githubasset.FieldName))
}

// WhereLabel applies the entql string predicate on the label field.
func (f *GithubAssetFilter) WhereLabel(p entql.StringP) {
	f.Where(p.Field(githubasset.FieldLabel))
}

// WhereState applies the entql string predicate on the state field.
func (f *GithubAssetFilter) WhereState(p entql.StringP) {
	f.Where(p.Field(githubasset.FieldState))
}

// WhereContentType applies the entql string predicate on the content_type field.
func (f *GithubAssetFilter) WhereContentType(p entql.StringP) {
	f.Where(p.Field(githubasset.FieldContentType))
}

// WhereSize applies the entql int64 predicate on the size field.
func (f *GithubAssetFilter) WhereSize(p entql.Int64P) {
	f.Where(p.Field(githubasset.FieldSize))
}

// WhereDownloadCount applies the entql int64 predicate on the download_count field.
func (f *GithubAssetFilter) WhereDownloadCount(p entql.Int64P) {
	f.Where(p.Field(githubasset.FieldDownloadCount))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *GithubAssetFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(githubasset.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *GithubAssetFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(githubasset.FieldUpdatedAt))
}

// WhereUploader applies the entql json.RawMessage predicate on the uploader field.
func (f *GithubAssetFilter) WhereUploader(p entql.BytesP) {
	f.Where(p.Field(githubasset.FieldUploader))
}

// WhereHasRelease applies a predicate to check if query has an edge release.
func (f *GithubAssetFilter) WhereHasRelease() {
	f.Where(entql.HasEdge("release"))
}

// WhereHasReleaseWith applies a predicate to check if query has an edge release with a given conditions (other predicates).
func (f *GithubAssetFilter) WhereHasReleaseWith(preds ...predicate.GithubRelease) {
	f.Where(entql.HasEdgeWith("release", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (geq *GithubEventQuery) addPredicate(pred func(s *sql.Selector)) {
	geq.predicates = append(geq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the GithubEventQuery builder.
func (geq *GithubEventQuery) Filter() *GithubEventFilter {
	return &GithubEventFilter{geq.config, geq}
}

// addPredicate implements the predicateAdder interface.
func (m *GithubEventMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the GithubEventMutation builder.
func (m *GithubEventMutation) Filter() *GithubEventFilter {
	return &GithubEventFilter{m.config, m}
}

// GithubEventFilter provides a generic filtering capability at runtime for GithubEventQuery.
type GithubEventFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *GithubEventFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *GithubEventFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(githubevent.FieldID))
}

// WhereEventID applies the entql string predicate on the event_id field.
func (f *GithubEventFilter) WhereEventID(p entql.StringP) {
	f.Where(p.Field(githubevent.FieldEventID))
}

// WhereEventType applies the entql string predicate on the event_type field.
func (f *GithubEventFilter) WhereEventType(p entql.StringP) {
	f.Where(p.Field(githubevent.FieldEventType))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *GithubEventFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(githubevent.FieldCreatedAt))
}

// WherePublic applies the entql bool predicate on the public field.
func (f *GithubEventFilter) WherePublic(p entql.BoolP) {
	f.Where(p.Field(githubevent.FieldPublic))
}

// WhereActorID applies the entql int64 predicate on the actor_id field.
func (f *GithubEventFilter) WhereActorID(p entql.Int64P) {
	f.Where(p.Field(githubevent.FieldActorID))
}

// WhereActor applies the entql json.RawMessage predicate on the actor field.
func (f *GithubEventFilter) WhereActor(p entql.BytesP) {
	f.Where(p.Field(githubevent.FieldActor))
}

// WhereRepoID applies the entql int64 predicate on the repo_id field.
func (f *GithubEventFilter) WhereRepoID(p entql.Int64P) {
	f.Where(p.Field(githubevent.FieldRepoID))
}

// WhereRepo applies the entql json.RawMessage predicate on the repo field.
func (f *GithubEventFilter) WhereRepo(p entql.BytesP) {
	f.Where(p.Field(githubevent.FieldRepo))
}

// WherePayload applies the entql json.RawMessage predicate on the payload field.
func (f *GithubEventFilter) WherePayload(p entql.BytesP) {
	f.Where(p.Field(githubevent.FieldPayload))
}

// addPredicate implements the predicateAdder interface.
func (grq *GithubReleaseQuery) addPredicate(pred func(s *sql.Selector)) {
	grq.predicates = append(grq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the GithubReleaseQuery builder.
func (grq *GithubReleaseQuery) Filter() *GithubReleaseFilter {
	return &GithubReleaseFilter{grq.config, grq}
}

// addPredicate implements the predicateAdder interface.
func (m *GithubReleaseMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the GithubReleaseMutation builder.
func (m *GithubReleaseMutation) Filter() *GithubReleaseFilter {
	return &GithubReleaseFilter{m.config, m}
}

// GithubReleaseFilter provides a generic filtering capability at runtime for GithubReleaseQuery.
type GithubReleaseFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *GithubReleaseFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *GithubReleaseFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(githubrelease.FieldID))
}

// WhereReleaseID applies the entql int64 predicate on the release_id field.
func (f *GithubReleaseFilter) WhereReleaseID(p entql.Int64P) {
	f.Where(p.Field(githubrelease.FieldReleaseID))
}

// WhereHTMLURL applies the entql string predicate on the html_url field.
func (f *GithubReleaseFilter) WhereHTMLURL(p entql.StringP) {
	f.Where(p.Field(githubrelease.FieldHTMLURL))
}

// WhereTagName applies the entql string predicate on the tag_name field.
func (f *GithubReleaseFilter) WhereTagName(p entql.StringP) {
	f.Where(p.Field(githubrelease.FieldTagName))
}

// WhereTargetCommitish applies the entql string predicate on the target_commitish field.
func (f *GithubReleaseFilter) WhereTargetCommitish(p entql.StringP) {
	f.Where(p.Field(githubrelease.FieldTargetCommitish))
}

// WhereName applies the entql string predicate on the name field.
func (f *GithubReleaseFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(githubrelease.FieldName))
}

// WhereDraft applies the entql bool predicate on the draft field.
func (f *GithubReleaseFilter) WhereDraft(p entql.BoolP) {
	f.Where(p.Field(githubrelease.FieldDraft))
}

// WherePrerelease applies the entql bool predicate on the prerelease field.
func (f *GithubReleaseFilter) WherePrerelease(p entql.BoolP) {
	f.Where(p.Field(githubrelease.FieldPrerelease))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *GithubReleaseFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(githubrelease.FieldCreatedAt))
}

// WherePublishedAt applies the entql time.Time predicate on the published_at field.
func (f *GithubReleaseFilter) WherePublishedAt(p entql.TimeP) {
	f.Where(p.Field(githubrelease.FieldPublishedAt))
}

// WhereAuthor applies the entql json.RawMessage predicate on the author field.
func (f *GithubReleaseFilter) WhereAuthor(p entql.BytesP) {
	f.Where(p.Field(githubrelease.FieldAuthor))
}

// WhereHasRepository applies a predicate to check if query has an edge repository.
func (f *GithubReleaseFilter) WhereHasRepository() {
	f.Where(entql.HasEdge("repository"))
}

// WhereHasRepositoryWith applies a predicate to check if query has an edge repository with a given conditions (other predicates).
func (f *GithubReleaseFilter) WhereHasRepositoryWith(preds ...predicate.GithubRepository) {
	f.Where(entql.HasEdgeWith("repository", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasAssets applies a predicate to check if query has an edge assets.
func (f *GithubReleaseFilter) WhereHasAssets() {
	f.Where(entql.HasEdge("assets"))
}

// WhereHasAssetsWith applies a predicate to check if query has an edge assets with a given conditions (other predicates).
func (f *GithubReleaseFilter) WhereHasAssetsWith(preds ...predicate.GithubAsset) {
	f.Where(entql.HasEdgeWith("assets", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (grq *GithubRepositoryQuery) addPredicate(pred func(s *sql.Selector)) {
	grq.predicates = append(grq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the GithubRepositoryQuery builder.
func (grq *GithubRepositoryQuery) Filter() *GithubRepositoryFilter {
	return &GithubRepositoryFilter{grq.config, grq}
}

// addPredicate implements the predicateAdder interface.
func (m *GithubRepositoryMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the GithubRepositoryMutation builder.
func (m *GithubRepositoryMutation) Filter() *GithubRepositoryFilter {
	return &GithubRepositoryFilter{m.config, m}
}

// GithubRepositoryFilter provides a generic filtering capability at runtime for GithubRepositoryQuery.
type GithubRepositoryFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *GithubRepositoryFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *GithubRepositoryFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(githubrepository.FieldID))
}

// WhereRepoID applies the entql int64 predicate on the repo_id field.
func (f *GithubRepositoryFilter) WhereRepoID(p entql.Int64P) {
	f.Where(p.Field(githubrepository.FieldRepoID))
}

// WhereName applies the entql string predicate on the name field.
func (f *GithubRepositoryFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldName))
}

// WhereFullName applies the entql string predicate on the full_name field.
func (f *GithubRepositoryFilter) WhereFullName(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldFullName))
}

// WhereOwnerLogin applies the entql string predicate on the owner_login field.
func (f *GithubRepositoryFilter) WhereOwnerLogin(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldOwnerLogin))
}

// WhereOwner applies the entql json.RawMessage predicate on the owner field.
func (f *GithubRepositoryFilter) WhereOwner(p entql.BytesP) {
	f.Where(p.Field(githubrepository.FieldOwner))
}

// WherePublic applies the entql bool predicate on the public field.
func (f *GithubRepositoryFilter) WherePublic(p entql.BoolP) {
	f.Where(p.Field(githubrepository.FieldPublic))
}

// WhereHTMLURL applies the entql string predicate on the html_url field.
func (f *GithubRepositoryFilter) WhereHTMLURL(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldHTMLURL))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *GithubRepositoryFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldDescription))
}

// WhereFork applies the entql bool predicate on the fork field.
func (f *GithubRepositoryFilter) WhereFork(p entql.BoolP) {
	f.Where(p.Field(githubrepository.FieldFork))
}

// WhereHomepage applies the entql string predicate on the homepage field.
func (f *GithubRepositoryFilter) WhereHomepage(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldHomepage))
}

// WhereStarCount applies the entql int predicate on the star_count field.
func (f *GithubRepositoryFilter) WhereStarCount(p entql.IntP) {
	f.Where(p.Field(githubrepository.FieldStarCount))
}

// WhereDefaultBranch applies the entql string predicate on the default_branch field.
func (f *GithubRepositoryFilter) WhereDefaultBranch(p entql.StringP) {
	f.Where(p.Field(githubrepository.FieldDefaultBranch))
}

// WhereIsTemplate applies the entql bool predicate on the is_template field.
func (f *GithubRepositoryFilter) WhereIsTemplate(p entql.BoolP) {
	f.Where(p.Field(githubrepository.FieldIsTemplate))
}

// WhereHasIssues applies the entql bool predicate on the has_issues field.
func (f *GithubRepositoryFilter) WhereHasIssues(p entql.BoolP) {
	f.Where(p.Field(githubrepository.FieldHasIssues))
}

// WhereArchived applies the entql bool predicate on the archived field.
func (f *GithubRepositoryFilter) WhereArchived(p entql.BoolP) {
	f.Where(p.Field(githubrepository.FieldArchived))
}

// WherePushedAt applies the entql time.Time predicate on the pushed_at field.
func (f *GithubRepositoryFilter) WherePushedAt(p entql.TimeP) {
	f.Where(p.Field(githubrepository.FieldPushedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *GithubRepositoryFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(githubrepository.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *GithubRepositoryFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(githubrepository.FieldUpdatedAt))
}

// WhereLicense applies the entql json.RawMessage predicate on the license field.
func (f *GithubRepositoryFilter) WhereLicense(p entql.BytesP) {
	f.Where(p.Field(githubrepository.FieldLicense))
}

// WhereHasLabels applies a predicate to check if query has an edge labels.
func (f *GithubRepositoryFilter) WhereHasLabels() {
	f.Where(entql.HasEdge("labels"))
}

// WhereHasLabelsWith applies a predicate to check if query has an edge labels with a given conditions (other predicates).
func (f *GithubRepositoryFilter) WhereHasLabelsWith(preds ...predicate.Label) {
	f.Where(entql.HasEdgeWith("labels", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasReleases applies a predicate to check if query has an edge releases.
func (f *GithubRepositoryFilter) WhereHasReleases() {
	f.Where(entql.HasEdge("releases"))
}

// WhereHasReleasesWith applies a predicate to check if query has an edge releases with a given conditions (other predicates).
func (f *GithubRepositoryFilter) WhereHasReleasesWith(preds ...predicate.GithubRelease) {
	f.Where(entql.HasEdgeWith("releases", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (lq *LabelQuery) addPredicate(pred func(s *sql.Selector)) {
	lq.predicates = append(lq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the LabelQuery builder.
func (lq *LabelQuery) Filter() *LabelFilter {
	return &LabelFilter{lq.config, lq}
}

// addPredicate implements the predicateAdder interface.
func (m *LabelMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the LabelMutation builder.
func (m *LabelMutation) Filter() *LabelFilter {
	return &LabelFilter{m.config, m}
}

// LabelFilter provides a generic filtering capability at runtime for LabelQuery.
type LabelFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *LabelFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *LabelFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(label.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *LabelFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(label.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *LabelFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(label.FieldUpdateTime))
}

// WhereName applies the entql string predicate on the name field.
func (f *LabelFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(label.FieldName))
}

// WhereHasPosts applies a predicate to check if query has an edge posts.
func (f *LabelFilter) WhereHasPosts() {
	f.Where(entql.HasEdge("posts"))
}

// WhereHasPostsWith applies a predicate to check if query has an edge posts with a given conditions (other predicates).
func (f *LabelFilter) WhereHasPostsWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("posts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasGithubRepositories applies a predicate to check if query has an edge github_repositories.
func (f *LabelFilter) WhereHasGithubRepositories() {
	f.Where(entql.HasEdge("github_repositories"))
}

// WhereHasGithubRepositoriesWith applies a predicate to check if query has an edge github_repositories with a given conditions (other predicates).
func (f *LabelFilter) WhereHasGithubRepositoriesWith(preds ...predicate.GithubRepository) {
	f.Where(entql.HasEdgeWith("github_repositories", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (pq *PostQuery) addPredicate(pred func(s *sql.Selector)) {
	pq.predicates = append(pq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the PostQuery builder.
func (pq *PostQuery) Filter() *PostFilter {
	return &PostFilter{pq.config, pq}
}

// addPredicate implements the predicateAdder interface.
func (m *PostMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the PostMutation builder.
func (m *PostMutation) Filter() *PostFilter {
	return &PostFilter{m.config, m}
}

// PostFilter provides a generic filtering capability at runtime for PostQuery.
type PostFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *PostFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *PostFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(post.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *PostFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(post.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *PostFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(post.FieldUpdateTime))
}

// WhereSlug applies the entql string predicate on the slug field.
func (f *PostFilter) WhereSlug(p entql.StringP) {
	f.Where(p.Field(post.FieldSlug))
}

// WhereTitle applies the entql string predicate on the title field.
func (f *PostFilter) WhereTitle(p entql.StringP) {
	f.Where(p.Field(post.FieldTitle))
}

// WhereContent applies the entql string predicate on the content field.
func (f *PostFilter) WhereContent(p entql.StringP) {
	f.Where(p.Field(post.FieldContent))
}

// WhereContentHTML applies the entql string predicate on the content_html field.
func (f *PostFilter) WhereContentHTML(p entql.StringP) {
	f.Where(p.Field(post.FieldContentHTML))
}

// WhereSummary applies the entql string predicate on the summary field.
func (f *PostFilter) WhereSummary(p entql.StringP) {
	f.Where(p.Field(post.FieldSummary))
}

// WherePublishedAt applies the entql time.Time predicate on the published_at field.
func (f *PostFilter) WherePublishedAt(p entql.TimeP) {
	f.Where(p.Field(post.FieldPublishedAt))
}

// WhereViewCount applies the entql int predicate on the view_count field.
func (f *PostFilter) WhereViewCount(p entql.IntP) {
	f.Where(p.Field(post.FieldViewCount))
}

// WhereHasAuthor applies a predicate to check if query has an edge author.
func (f *PostFilter) WhereHasAuthor() {
	f.Where(entql.HasEdge("author"))
}

// WhereHasAuthorWith applies a predicate to check if query has an edge author with a given conditions (other predicates).
func (f *PostFilter) WhereHasAuthorWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("author", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasLabels applies a predicate to check if query has an edge labels.
func (f *PostFilter) WhereHasLabels() {
	f.Where(entql.HasEdge("labels"))
}

// WhereHasLabelsWith applies a predicate to check if query has an edge labels with a given conditions (other predicates).
func (f *PostFilter) WhereHasLabelsWith(preds ...predicate.Label) {
	f.Where(entql.HasEdgeWith("labels", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{uq.config, uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{m.config, m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	config
	predicateAdder
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *UserFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(user.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *UserFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *UserFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdateTime))
}

// WhereUserID applies the entql int predicate on the user_id field.
func (f *UserFilter) WhereUserID(p entql.IntP) {
	f.Where(p.Field(user.FieldUserID))
}

// WhereLogin applies the entql string predicate on the login field.
func (f *UserFilter) WhereLogin(p entql.StringP) {
	f.Where(p.Field(user.FieldLogin))
}

// WhereName applies the entql string predicate on the name field.
func (f *UserFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(user.FieldName))
}

// WhereAvatarURL applies the entql string predicate on the avatar_url field.
func (f *UserFilter) WhereAvatarURL(p entql.StringP) {
	f.Where(p.Field(user.FieldAvatarURL))
}

// WhereHTMLURL applies the entql string predicate on the html_url field.
func (f *UserFilter) WhereHTMLURL(p entql.StringP) {
	f.Where(p.Field(user.FieldHTMLURL))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereLocation applies the entql string predicate on the location field.
func (f *UserFilter) WhereLocation(p entql.StringP) {
	f.Where(p.Field(user.FieldLocation))
}

// WhereBio applies the entql string predicate on the bio field.
func (f *UserFilter) WhereBio(p entql.StringP) {
	f.Where(p.Field(user.FieldBio))
}

// WhereHasPosts applies a predicate to check if query has an edge posts.
func (f *UserFilter) WhereHasPosts() {
	f.Where(entql.HasEdge("posts"))
}

// WhereHasPostsWith applies a predicate to check if query has an edge posts with a given conditions (other predicates).
func (f *UserFilter) WhereHasPostsWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("posts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
