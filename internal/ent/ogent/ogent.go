// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/lrstanley/liam.sh/internal/ent"
	"github.com/lrstanley/liam.sh/internal/ent/label"
	"github.com/lrstanley/liam.sh/internal/ent/post"
	"github.com/lrstanley/liam.sh/internal/ent/user"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateLabel handles POST /labels requests.
func (h *OgentHandler) CreateLabel(ctx context.Context, req CreateLabelReq) (CreateLabelRes, error) {
	b := h.client.Label.Create()
	// Add all fields.
	b.SetCreateTime(req.CreateTime)
	b.SetUpdateTime(req.UpdateTime)
	b.SetName(req.Name)
	// Add all edges.
	b.AddPostIDs(req.Posts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Label.Query().Where(label.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewLabelCreate(e), nil
}

// ReadLabel handles GET /labels/{id} requests.
func (h *OgentHandler) ReadLabel(ctx context.Context, params ReadLabelParams) (ReadLabelRes, error) {
	q := h.client.Label.Query().Where(label.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewLabelRead(e), nil
}

// UpdateLabel handles PATCH /labels/{id} requests.
func (h *OgentHandler) UpdateLabel(ctx context.Context, req UpdateLabelReq, params UpdateLabelParams) (UpdateLabelRes, error) {
	b := h.client.Label.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	b.ClearPosts().AddPostIDs(req.Posts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Label.Query().Where(label.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewLabelUpdate(e), nil
}

// DeleteLabel handles DELETE /labels/{id} requests.
func (h *OgentHandler) DeleteLabel(ctx context.Context, params DeleteLabelParams) (DeleteLabelRes, error) {
	err := h.client.Label.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteLabelNoContent), nil

}

// ListLabel handles GET /labels requests.
func (h *OgentHandler) ListLabel(ctx context.Context, params ListLabelParams) (ListLabelRes, error) {
	q := h.client.Label.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewLabelLists(es)
	return (*ListLabelOKApplicationJSON)(&r), nil
}

// ListLabelPosts handles GET /labels/{id}/posts requests.
func (h *OgentHandler) ListLabelPosts(ctx context.Context, params ListLabelPostsParams) (ListLabelPostsRes, error) {
	q := h.client.Label.Query().Where(label.IDEQ(params.ID)).QueryPosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewLabelPostsLists(es)
	return (*ListLabelPostsOKApplicationJSON)(&r), nil
}

// CreatePost handles POST /posts requests.
func (h *OgentHandler) CreatePost(ctx context.Context, req CreatePostReq) (CreatePostRes, error) {
	b := h.client.Post.Create()
	// Add all fields.
	b.SetCreateTime(req.CreateTime)
	b.SetUpdateTime(req.UpdateTime)
	b.SetSlug(req.Slug)
	b.SetTitle(req.Title)
	b.SetContent(req.Content)
	b.SetPublishedAt(req.PublishedAt)
	// Add all edges.
	b.SetAuthorID(req.Author)
	b.AddLabelIDs(req.Labels...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Post.Query().Where(post.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPostCreate(e), nil
}

// DeletePost handles DELETE /posts/{id} requests.
func (h *OgentHandler) DeletePost(ctx context.Context, params DeletePostParams) (DeletePostRes, error) {
	err := h.client.Post.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePostNoContent), nil

}

// ListPost handles GET /posts requests.
func (h *OgentHandler) ListPost(ctx context.Context, params ListPostParams) (ListPostRes, error) {
	q := h.client.Post.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPostLists(es)
	return (*ListPostOKApplicationJSON)(&r), nil
}

// ReadPost handles GET /posts/{id} requests.
func (h *OgentHandler) ReadPost(ctx context.Context, params ReadPostParams) (ReadPostRes, error) {
	q := h.client.Post.Query().Where(post.IDEQ(params.ID)).WithAuthor().WithLabels()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPostRead(e), nil
}

// UpdatePost handles PATCH /posts/{id} requests.
func (h *OgentHandler) UpdatePost(ctx context.Context, req UpdatePostReq, params UpdatePostParams) (UpdatePostRes, error) {
	b := h.client.Post.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Slug.Get(); ok {
		b.SetSlug(v)
	}
	if v, ok := req.Title.Get(); ok {
		b.SetTitle(v)
	}
	if v, ok := req.Content.Get(); ok {
		b.SetContent(v)
	}
	if v, ok := req.PublishedAt.Get(); ok {
		b.SetPublishedAt(v)
	}
	// Add all edges.
	if v, ok := req.Author.Get(); ok {
		b.SetAuthorID(v)
	}
	b.ClearLabels().AddLabelIDs(req.Labels...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Post.Query().Where(post.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPostUpdate(e), nil
}

// ReadPostAuthor handles GET /posts/{id}/author requests.
func (h *OgentHandler) ReadPostAuthor(ctx context.Context, params ReadPostAuthorParams) (ReadPostAuthorRes, error) {
	q := h.client.Post.Query().Where(post.IDEQ(params.ID)).QueryAuthor()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPostAuthorRead(e), nil
}

// ListPostLabels handles GET /posts/{id}/labels requests.
func (h *OgentHandler) ListPostLabels(ctx context.Context, params ListPostLabelsParams) (ListPostLabelsRes, error) {
	q := h.client.Post.Query().Where(post.IDEQ(params.ID)).QueryLabels()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPostLabelsLists(es)
	return (*ListPostLabelsOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetCreateTime(req.CreateTime)
	b.SetUpdateTime(req.UpdateTime)
	b.SetUserID(req.UserID)
	b.SetLogin(req.Login)
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.AvatarURL.Get(); ok {
		b.SetAvatarURL(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Location.Get(); ok {
		b.SetLocation(v)
	}
	if v, ok := req.Bio.Get(); ok {
		b.SetBio(v)
	}
	// Add all edges.
	b.AddPostIDs(req.Posts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Login.Get(); ok {
		b.SetLogin(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.AvatarURL.Get(); ok {
		b.SetAvatarURL(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Location.Get(); ok {
		b.SetLocation(v)
	}
	if v, ok := req.Bio.Get(); ok {
		b.SetBio(v)
	}
	// Add all edges.
	b.ClearPosts().AddPostIDs(req.Posts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserPosts handles GET /users/{id}/posts requests.
func (h *OgentHandler) ListUserPosts(ctx context.Context, params ListUserPostsParams) (ListUserPostsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryPosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserPostsLists(es)
	return (*ListUserPostsOKApplicationJSON)(&r), nil
}
