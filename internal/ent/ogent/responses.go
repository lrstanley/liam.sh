// Copyright (c) Liam Stanley <me@liamstanley.io>. All rights reserved. Use
// of this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package ogent

import "github.com/lrstanley/liam.sh/internal/ent"

func NewUserCreate(e *ent.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.CreateTime = e.CreateTime
	ret.UpdateTime = e.UpdateTime
	ret.UserID = e.UserID
	ret.Login = e.Login
	ret.Name = NewOptString(e.Name)
	ret.AvatarURL = NewOptString(e.AvatarURL)
	ret.Email = NewOptString(e.Email)
	ret.Location = NewOptString(e.Location)
	ret.Bio = NewOptString(e.Bio)
	return &ret
}

func NewUserCreates(es []*ent.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *ent.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.CreateTime = e.CreateTime
	ret.UpdateTime = e.UpdateTime
	ret.UserID = e.UserID
	ret.Login = e.Login
	ret.Name = NewOptString(e.Name)
	ret.AvatarURL = NewOptString(e.AvatarURL)
	ret.Email = NewOptString(e.Email)
	ret.Location = NewOptString(e.Location)
	ret.Bio = NewOptString(e.Bio)
	return &ret
}

func NewUserLists(es []*ent.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *ent.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.CreateTime = e.CreateTime
	ret.UpdateTime = e.UpdateTime
	ret.UserID = e.UserID
	ret.Login = e.Login
	ret.Name = NewOptString(e.Name)
	ret.AvatarURL = NewOptString(e.AvatarURL)
	ret.Email = NewOptString(e.Email)
	ret.Location = NewOptString(e.Location)
	ret.Bio = NewOptString(e.Bio)
	return &ret
}

func NewUserReads(es []*ent.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *ent.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.CreateTime = e.CreateTime
	ret.UpdateTime = e.UpdateTime
	ret.UserID = e.UserID
	ret.Login = e.Login
	ret.Name = NewOptString(e.Name)
	ret.AvatarURL = NewOptString(e.AvatarURL)
	ret.Email = NewOptString(e.Email)
	ret.Location = NewOptString(e.Location)
	ret.Bio = NewOptString(e.Bio)
	return &ret
}

func NewUserUpdates(es []*ent.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}
