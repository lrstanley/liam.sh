// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlhandler

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/go-github/v48/github"
	"github.com/lrstanley/clix"
	"github.com/lrstanley/liam.sh/internal/ent"
	"github.com/lrstanley/liam.sh/internal/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CodingStats struct {
		CalculatedDays     func(childComplexity int) int
		Languages          func(childComplexity int) int
		TotalDuration      func(childComplexity int) int
		TotalDurationShort func(childComplexity int) int
		TotalSeconds       func(childComplexity int) int
	}

	GithubAsset struct {
		AssetID            func(childComplexity int) int
		BrowserDownloadURL func(childComplexity int) int
		ContentType        func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		DownloadCount      func(childComplexity int) int
		ID                 func(childComplexity int) int
		Label              func(childComplexity int) int
		Name               func(childComplexity int) int
		Release            func(childComplexity int) int
		Size               func(childComplexity int) int
		State              func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		Uploader           func(childComplexity int) int
	}

	GithubAssetConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubAssetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubEvent struct {
		Actor     func(childComplexity int) int
		ActorID   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		EventID   func(childComplexity int) int
		EventType func(childComplexity int) int
		ID        func(childComplexity int) int
		Payload   func(childComplexity int) int
		Public    func(childComplexity int) int
		Repo      func(childComplexity int) int
		RepoID    func(childComplexity int) int
	}

	GithubEventConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubEventEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubEventRepo struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	GithubGist struct {
		Content     func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		GistID      func(childComplexity int) int
		HTMLURL     func(childComplexity int) int
		ID          func(childComplexity int) int
		Language    func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Public      func(childComplexity int) int
		RawURL      func(childComplexity int) int
		Size        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	GithubGistConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubGistEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubLicense struct {
		HTMLURL func(childComplexity int) int
		Key     func(childComplexity int) int
		Name    func(childComplexity int) int
		SPDXID  func(childComplexity int) int
	}

	GithubRelease struct {
		Assets          func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubAssetOrder, where *ent.GithubAssetWhereInput) int
		Author          func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Draft           func(childComplexity int) int
		HTMLURL         func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Prerelease      func(childComplexity int) int
		PublishedAt     func(childComplexity int) int
		ReleaseID       func(childComplexity int) int
		Repository      func(childComplexity int) int
		TagName         func(childComplexity int) int
		TargetCommitish func(childComplexity int) int
	}

	GithubReleaseConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubReleaseEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubRepository struct {
		Archived      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DefaultBranch func(childComplexity int) int
		Description   func(childComplexity int) int
		Fork          func(childComplexity int) int
		FullName      func(childComplexity int) int
		HTMLURL       func(childComplexity int) int
		HasIssues     func(childComplexity int) int
		Homepage      func(childComplexity int) int
		ID            func(childComplexity int) int
		IsTemplate    func(childComplexity int) int
		Labels        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.LabelOrder, where *ent.LabelWhereInput) int
		License       func(childComplexity int) int
		Name          func(childComplexity int) int
		Owner         func(childComplexity int) int
		OwnerLogin    func(childComplexity int) int
		Public        func(childComplexity int) int
		PushedAt      func(childComplexity int) int
		Releases      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubReleaseOrder, where *ent.GithubReleaseWhereInput) int
		RepoID        func(childComplexity int) int
		StarCount     func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	GithubRepositoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GithubRepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GithubStats struct {
		ClosedIssues     func(childComplexity int) int
		CommitsYear      func(childComplexity int) int
		ContributedRepos func(childComplexity int) int
		Issues           func(childComplexity int) int
		OpenIssues       func(childComplexity int) int
		PullRequests     func(childComplexity int) int
		Repos            func(childComplexity int) int
		Stars            func(childComplexity int) int
	}

	GithubUser struct {
		AvatarURL   func(childComplexity int) int
		Bio         func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Email       func(childComplexity int) int
		Followers   func(childComplexity int) int
		Following   func(childComplexity int) int
		HTMLURL     func(childComplexity int) int
		ID          func(childComplexity int) int
		Location    func(childComplexity int) int
		Login       func(childComplexity int) int
		Name        func(childComplexity int) int
		PublicRepos func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Label struct {
		CreateTime         func(childComplexity int) int
		GithubRepositories func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubRepositoryOrder, where *ent.GithubRepositoryWhereInput) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		Posts              func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PostOrder, where *ent.PostWhereInput) int
		UpdateTime         func(childComplexity int) int
	}

	LabelConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LabelEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LanguageStat struct {
		HexColor      func(childComplexity int) int
		Language      func(childComplexity int) int
		TotalDuration func(childComplexity int) int
		TotalSeconds  func(childComplexity int) int
	}

	Link struct {
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	Mutation struct {
		CreateLabel     func(childComplexity int, input ent.CreateLabelInput) int
		CreatePost      func(childComplexity int, input ent.CreatePostInput) int
		DeleteLabel     func(childComplexity int, id int) int
		DeletePost      func(childComplexity int, id int) int
		Ping            func(childComplexity int) int
		RegeneratePosts func(childComplexity int) int
		UpdateLabel     func(childComplexity int, id int, input ent.UpdateLabelInput) int
		UpdatePost      func(childComplexity int, id int, input ent.UpdatePostInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Post struct {
		Author      func(childComplexity int) int
		Content     func(childComplexity int) int
		ContentHTML func(childComplexity int) int
		CreateTime  func(childComplexity int) int
		ID          func(childComplexity int) int
		Labels      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.LabelOrder, where *ent.LabelWhereInput) int
		Public      func(childComplexity int) int
		PublishedAt func(childComplexity int) int
		Slug        func(childComplexity int) int
		Summary     func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdateTime  func(childComplexity int) int
		ViewCount   func(childComplexity int) int
	}

	PostConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PostEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		CodingStats        func(childComplexity int) int
		GithubAssets       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubAssetOrder, where *ent.GithubAssetWhereInput) int
		GithubEvents       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubEventOrder, where *ent.GithubEventWhereInput) int
		GithubGists        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubGistOrder, where *ent.GithubGistWhereInput) int
		GithubReleases     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubReleaseOrder, where *ent.GithubReleaseWhereInput) int
		GithubRepositories func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubRepositoryOrder, where *ent.GithubRepositoryWhereInput) int
		GithubStats        func(childComplexity int) int
		GithubUser         func(childComplexity int) int
		Labels             func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.LabelOrder, where *ent.LabelWhereInput) int
		Node               func(childComplexity int, id int) int
		Nodes              func(childComplexity int, ids []int) int
		Posts              func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PostOrder, where *ent.PostWhereInput) int
		Self               func(childComplexity int) int
		Users              func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.UserOrder, where *ent.UserWhereInput) int
		Version            func(childComplexity int) int
	}

	Timestamp struct {
		Time func(childComplexity int) int
	}

	User struct {
		AvatarURL  func(childComplexity int) int
		Bio        func(childComplexity int) int
		CreateTime func(childComplexity int) int
		Email      func(childComplexity int) int
		HTMLURL    func(childComplexity int) int
		ID         func(childComplexity int) int
		Location   func(childComplexity int) int
		Login      func(childComplexity int) int
		Name       func(childComplexity int) int
		Posts      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PostOrder, where *ent.PostWhereInput) int
		UpdateTime func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	VersionInfo struct {
		Arch      func(childComplexity int) int
		Command   func(childComplexity int) int
		Commit    func(childComplexity int) int
		Date      func(childComplexity int) int
		GoVersion func(childComplexity int) int
		Links     func(childComplexity int) int
		Name      func(childComplexity int) int
		OS        func(childComplexity int) int
		Version   func(childComplexity int) int
	}
}

type MutationResolver interface {
	Ping(ctx context.Context) (*string, error)
	CreateLabel(ctx context.Context, input ent.CreateLabelInput) (*ent.Label, error)
	UpdateLabel(ctx context.Context, id int, input ent.UpdateLabelInput) (*ent.Label, error)
	DeleteLabel(ctx context.Context, id int) (int, error)
	CreatePost(ctx context.Context, input ent.CreatePostInput) (*ent.Post, error)
	UpdatePost(ctx context.Context, id int, input ent.UpdatePostInput) (*ent.Post, error)
	DeletePost(ctx context.Context, id int) (int, error)
	RegeneratePosts(ctx context.Context) (bool, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	GithubAssets(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubAssetOrder, where *ent.GithubAssetWhereInput) (*ent.GithubAssetConnection, error)
	GithubEvents(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubEventOrder, where *ent.GithubEventWhereInput) (*ent.GithubEventConnection, error)
	GithubGists(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubGistOrder, where *ent.GithubGistWhereInput) (*ent.GithubGistConnection, error)
	GithubReleases(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubReleaseOrder, where *ent.GithubReleaseWhereInput) (*ent.GithubReleaseConnection, error)
	GithubRepositories(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.GithubRepositoryOrder, where *ent.GithubRepositoryWhereInput) (*ent.GithubRepositoryConnection, error)
	Labels(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.LabelOrder, where *ent.LabelWhereInput) (*ent.LabelConnection, error)
	Posts(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PostOrder, where *ent.PostWhereInput) (*ent.PostConnection, error)
	Users(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.UserOrder, where *ent.UserWhereInput) (*ent.UserConnection, error)
	GithubUser(ctx context.Context) (*github.User, error)
	CodingStats(ctx context.Context) (*models.CodingStats, error)
	GithubStats(ctx context.Context) (*models.GithubStats, error)
	Self(ctx context.Context) (*ent.User, error)
	Version(ctx context.Context) (*clix.NonSensitiveVersion, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "CodingStats.calculatedDays":
		if e.complexity.CodingStats.CalculatedDays == nil {
			break
		}

		return e.complexity.CodingStats.CalculatedDays(childComplexity), true

	case "CodingStats.languages":
		if e.complexity.CodingStats.Languages == nil {
			break
		}

		return e.complexity.CodingStats.Languages(childComplexity), true

	case "CodingStats.totalDuration":
		if e.complexity.CodingStats.TotalDuration == nil {
			break
		}

		return e.complexity.CodingStats.TotalDuration(childComplexity), true

	case "CodingStats.totalDurationShort":
		if e.complexity.CodingStats.TotalDurationShort == nil {
			break
		}

		return e.complexity.CodingStats.TotalDurationShort(childComplexity), true

	case "CodingStats.totalSeconds":
		if e.complexity.CodingStats.TotalSeconds == nil {
			break
		}

		return e.complexity.CodingStats.TotalSeconds(childComplexity), true

	case "GithubAsset.assetID":
		if e.complexity.GithubAsset.AssetID == nil {
			break
		}

		return e.complexity.GithubAsset.AssetID(childComplexity), true

	case "GithubAsset.browserDownloadURL":
		if e.complexity.GithubAsset.BrowserDownloadURL == nil {
			break
		}

		return e.complexity.GithubAsset.BrowserDownloadURL(childComplexity), true

	case "GithubAsset.contentType":
		if e.complexity.GithubAsset.ContentType == nil {
			break
		}

		return e.complexity.GithubAsset.ContentType(childComplexity), true

	case "GithubAsset.createdAt":
		if e.complexity.GithubAsset.CreatedAt == nil {
			break
		}

		return e.complexity.GithubAsset.CreatedAt(childComplexity), true

	case "GithubAsset.downloadCount":
		if e.complexity.GithubAsset.DownloadCount == nil {
			break
		}

		return e.complexity.GithubAsset.DownloadCount(childComplexity), true

	case "GithubAsset.id":
		if e.complexity.GithubAsset.ID == nil {
			break
		}

		return e.complexity.GithubAsset.ID(childComplexity), true

	case "GithubAsset.label":
		if e.complexity.GithubAsset.Label == nil {
			break
		}

		return e.complexity.GithubAsset.Label(childComplexity), true

	case "GithubAsset.name":
		if e.complexity.GithubAsset.Name == nil {
			break
		}

		return e.complexity.GithubAsset.Name(childComplexity), true

	case "GithubAsset.release":
		if e.complexity.GithubAsset.Release == nil {
			break
		}

		return e.complexity.GithubAsset.Release(childComplexity), true

	case "GithubAsset.size":
		if e.complexity.GithubAsset.Size == nil {
			break
		}

		return e.complexity.GithubAsset.Size(childComplexity), true

	case "GithubAsset.state":
		if e.complexity.GithubAsset.State == nil {
			break
		}

		return e.complexity.GithubAsset.State(childComplexity), true

	case "GithubAsset.updatedAt":
		if e.complexity.GithubAsset.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubAsset.UpdatedAt(childComplexity), true

	case "GithubAsset.uploader":
		if e.complexity.GithubAsset.Uploader == nil {
			break
		}

		return e.complexity.GithubAsset.Uploader(childComplexity), true

	case "GithubAssetConnection.edges":
		if e.complexity.GithubAssetConnection.Edges == nil {
			break
		}

		return e.complexity.GithubAssetConnection.Edges(childComplexity), true

	case "GithubAssetConnection.pageInfo":
		if e.complexity.GithubAssetConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubAssetConnection.PageInfo(childComplexity), true

	case "GithubAssetConnection.totalCount":
		if e.complexity.GithubAssetConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubAssetConnection.TotalCount(childComplexity), true

	case "GithubAssetEdge.cursor":
		if e.complexity.GithubAssetEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubAssetEdge.Cursor(childComplexity), true

	case "GithubAssetEdge.node":
		if e.complexity.GithubAssetEdge.Node == nil {
			break
		}

		return e.complexity.GithubAssetEdge.Node(childComplexity), true

	case "GithubEvent.actor":
		if e.complexity.GithubEvent.Actor == nil {
			break
		}

		return e.complexity.GithubEvent.Actor(childComplexity), true

	case "GithubEvent.actorID":
		if e.complexity.GithubEvent.ActorID == nil {
			break
		}

		return e.complexity.GithubEvent.ActorID(childComplexity), true

	case "GithubEvent.createdAt":
		if e.complexity.GithubEvent.CreatedAt == nil {
			break
		}

		return e.complexity.GithubEvent.CreatedAt(childComplexity), true

	case "GithubEvent.eventID":
		if e.complexity.GithubEvent.EventID == nil {
			break
		}

		return e.complexity.GithubEvent.EventID(childComplexity), true

	case "GithubEvent.eventType":
		if e.complexity.GithubEvent.EventType == nil {
			break
		}

		return e.complexity.GithubEvent.EventType(childComplexity), true

	case "GithubEvent.id":
		if e.complexity.GithubEvent.ID == nil {
			break
		}

		return e.complexity.GithubEvent.ID(childComplexity), true

	case "GithubEvent.payload":
		if e.complexity.GithubEvent.Payload == nil {
			break
		}

		return e.complexity.GithubEvent.Payload(childComplexity), true

	case "GithubEvent.public":
		if e.complexity.GithubEvent.Public == nil {
			break
		}

		return e.complexity.GithubEvent.Public(childComplexity), true

	case "GithubEvent.repo":
		if e.complexity.GithubEvent.Repo == nil {
			break
		}

		return e.complexity.GithubEvent.Repo(childComplexity), true

	case "GithubEvent.repoID":
		if e.complexity.GithubEvent.RepoID == nil {
			break
		}

		return e.complexity.GithubEvent.RepoID(childComplexity), true

	case "GithubEventConnection.edges":
		if e.complexity.GithubEventConnection.Edges == nil {
			break
		}

		return e.complexity.GithubEventConnection.Edges(childComplexity), true

	case "GithubEventConnection.pageInfo":
		if e.complexity.GithubEventConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubEventConnection.PageInfo(childComplexity), true

	case "GithubEventConnection.totalCount":
		if e.complexity.GithubEventConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubEventConnection.TotalCount(childComplexity), true

	case "GithubEventEdge.cursor":
		if e.complexity.GithubEventEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubEventEdge.Cursor(childComplexity), true

	case "GithubEventEdge.node":
		if e.complexity.GithubEventEdge.Node == nil {
			break
		}

		return e.complexity.GithubEventEdge.Node(childComplexity), true

	case "GithubEventRepo.id":
		if e.complexity.GithubEventRepo.ID == nil {
			break
		}

		return e.complexity.GithubEventRepo.ID(childComplexity), true

	case "GithubEventRepo.name":
		if e.complexity.GithubEventRepo.Name == nil {
			break
		}

		return e.complexity.GithubEventRepo.Name(childComplexity), true

	case "GithubEventRepo.url":
		if e.complexity.GithubEventRepo.URL == nil {
			break
		}

		return e.complexity.GithubEventRepo.URL(childComplexity), true

	case "GithubGist.content":
		if e.complexity.GithubGist.Content == nil {
			break
		}

		return e.complexity.GithubGist.Content(childComplexity), true

	case "GithubGist.createdAt":
		if e.complexity.GithubGist.CreatedAt == nil {
			break
		}

		return e.complexity.GithubGist.CreatedAt(childComplexity), true

	case "GithubGist.description":
		if e.complexity.GithubGist.Description == nil {
			break
		}

		return e.complexity.GithubGist.Description(childComplexity), true

	case "GithubGist.gistID":
		if e.complexity.GithubGist.GistID == nil {
			break
		}

		return e.complexity.GithubGist.GistID(childComplexity), true

	case "GithubGist.htmlURL":
		if e.complexity.GithubGist.HTMLURL == nil {
			break
		}

		return e.complexity.GithubGist.HTMLURL(childComplexity), true

	case "GithubGist.id":
		if e.complexity.GithubGist.ID == nil {
			break
		}

		return e.complexity.GithubGist.ID(childComplexity), true

	case "GithubGist.language":
		if e.complexity.GithubGist.Language == nil {
			break
		}

		return e.complexity.GithubGist.Language(childComplexity), true

	case "GithubGist.name":
		if e.complexity.GithubGist.Name == nil {
			break
		}

		return e.complexity.GithubGist.Name(childComplexity), true

	case "GithubGist.owner":
		if e.complexity.GithubGist.Owner == nil {
			break
		}

		return e.complexity.GithubGist.Owner(childComplexity), true

	case "GithubGist.public":
		if e.complexity.GithubGist.Public == nil {
			break
		}

		return e.complexity.GithubGist.Public(childComplexity), true

	case "GithubGist.rawURL":
		if e.complexity.GithubGist.RawURL == nil {
			break
		}

		return e.complexity.GithubGist.RawURL(childComplexity), true

	case "GithubGist.size":
		if e.complexity.GithubGist.Size == nil {
			break
		}

		return e.complexity.GithubGist.Size(childComplexity), true

	case "GithubGist.type":
		if e.complexity.GithubGist.Type == nil {
			break
		}

		return e.complexity.GithubGist.Type(childComplexity), true

	case "GithubGist.updatedAt":
		if e.complexity.GithubGist.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubGist.UpdatedAt(childComplexity), true

	case "GithubGistConnection.edges":
		if e.complexity.GithubGistConnection.Edges == nil {
			break
		}

		return e.complexity.GithubGistConnection.Edges(childComplexity), true

	case "GithubGistConnection.pageInfo":
		if e.complexity.GithubGistConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubGistConnection.PageInfo(childComplexity), true

	case "GithubGistConnection.totalCount":
		if e.complexity.GithubGistConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubGistConnection.TotalCount(childComplexity), true

	case "GithubGistEdge.cursor":
		if e.complexity.GithubGistEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubGistEdge.Cursor(childComplexity), true

	case "GithubGistEdge.node":
		if e.complexity.GithubGistEdge.Node == nil {
			break
		}

		return e.complexity.GithubGistEdge.Node(childComplexity), true

	case "GithubLicense.htmlURL":
		if e.complexity.GithubLicense.HTMLURL == nil {
			break
		}

		return e.complexity.GithubLicense.HTMLURL(childComplexity), true

	case "GithubLicense.key":
		if e.complexity.GithubLicense.Key == nil {
			break
		}

		return e.complexity.GithubLicense.Key(childComplexity), true

	case "GithubLicense.name":
		if e.complexity.GithubLicense.Name == nil {
			break
		}

		return e.complexity.GithubLicense.Name(childComplexity), true

	case "GithubLicense.spdxId":
		if e.complexity.GithubLicense.SPDXID == nil {
			break
		}

		return e.complexity.GithubLicense.SPDXID(childComplexity), true

	case "GithubRelease.assets":
		if e.complexity.GithubRelease.Assets == nil {
			break
		}

		args, err := ec.field_GithubRelease_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GithubRelease.Assets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubAssetOrder), args["where"].(*ent.GithubAssetWhereInput)), true

	case "GithubRelease.author":
		if e.complexity.GithubRelease.Author == nil {
			break
		}

		return e.complexity.GithubRelease.Author(childComplexity), true

	case "GithubRelease.createdAt":
		if e.complexity.GithubRelease.CreatedAt == nil {
			break
		}

		return e.complexity.GithubRelease.CreatedAt(childComplexity), true

	case "GithubRelease.draft":
		if e.complexity.GithubRelease.Draft == nil {
			break
		}

		return e.complexity.GithubRelease.Draft(childComplexity), true

	case "GithubRelease.htmlURL":
		if e.complexity.GithubRelease.HTMLURL == nil {
			break
		}

		return e.complexity.GithubRelease.HTMLURL(childComplexity), true

	case "GithubRelease.id":
		if e.complexity.GithubRelease.ID == nil {
			break
		}

		return e.complexity.GithubRelease.ID(childComplexity), true

	case "GithubRelease.name":
		if e.complexity.GithubRelease.Name == nil {
			break
		}

		return e.complexity.GithubRelease.Name(childComplexity), true

	case "GithubRelease.prerelease":
		if e.complexity.GithubRelease.Prerelease == nil {
			break
		}

		return e.complexity.GithubRelease.Prerelease(childComplexity), true

	case "GithubRelease.publishedAt":
		if e.complexity.GithubRelease.PublishedAt == nil {
			break
		}

		return e.complexity.GithubRelease.PublishedAt(childComplexity), true

	case "GithubRelease.releaseID":
		if e.complexity.GithubRelease.ReleaseID == nil {
			break
		}

		return e.complexity.GithubRelease.ReleaseID(childComplexity), true

	case "GithubRelease.repository":
		if e.complexity.GithubRelease.Repository == nil {
			break
		}

		return e.complexity.GithubRelease.Repository(childComplexity), true

	case "GithubRelease.tagName":
		if e.complexity.GithubRelease.TagName == nil {
			break
		}

		return e.complexity.GithubRelease.TagName(childComplexity), true

	case "GithubRelease.targetCommitish":
		if e.complexity.GithubRelease.TargetCommitish == nil {
			break
		}

		return e.complexity.GithubRelease.TargetCommitish(childComplexity), true

	case "GithubReleaseConnection.edges":
		if e.complexity.GithubReleaseConnection.Edges == nil {
			break
		}

		return e.complexity.GithubReleaseConnection.Edges(childComplexity), true

	case "GithubReleaseConnection.pageInfo":
		if e.complexity.GithubReleaseConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubReleaseConnection.PageInfo(childComplexity), true

	case "GithubReleaseConnection.totalCount":
		if e.complexity.GithubReleaseConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubReleaseConnection.TotalCount(childComplexity), true

	case "GithubReleaseEdge.cursor":
		if e.complexity.GithubReleaseEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubReleaseEdge.Cursor(childComplexity), true

	case "GithubReleaseEdge.node":
		if e.complexity.GithubReleaseEdge.Node == nil {
			break
		}

		return e.complexity.GithubReleaseEdge.Node(childComplexity), true

	case "GithubRepository.archived":
		if e.complexity.GithubRepository.Archived == nil {
			break
		}

		return e.complexity.GithubRepository.Archived(childComplexity), true

	case "GithubRepository.createdAt":
		if e.complexity.GithubRepository.CreatedAt == nil {
			break
		}

		return e.complexity.GithubRepository.CreatedAt(childComplexity), true

	case "GithubRepository.defaultBranch":
		if e.complexity.GithubRepository.DefaultBranch == nil {
			break
		}

		return e.complexity.GithubRepository.DefaultBranch(childComplexity), true

	case "GithubRepository.description":
		if e.complexity.GithubRepository.Description == nil {
			break
		}

		return e.complexity.GithubRepository.Description(childComplexity), true

	case "GithubRepository.fork":
		if e.complexity.GithubRepository.Fork == nil {
			break
		}

		return e.complexity.GithubRepository.Fork(childComplexity), true

	case "GithubRepository.fullName":
		if e.complexity.GithubRepository.FullName == nil {
			break
		}

		return e.complexity.GithubRepository.FullName(childComplexity), true

	case "GithubRepository.htmlURL":
		if e.complexity.GithubRepository.HTMLURL == nil {
			break
		}

		return e.complexity.GithubRepository.HTMLURL(childComplexity), true

	case "GithubRepository.hasIssues":
		if e.complexity.GithubRepository.HasIssues == nil {
			break
		}

		return e.complexity.GithubRepository.HasIssues(childComplexity), true

	case "GithubRepository.homepage":
		if e.complexity.GithubRepository.Homepage == nil {
			break
		}

		return e.complexity.GithubRepository.Homepage(childComplexity), true

	case "GithubRepository.id":
		if e.complexity.GithubRepository.ID == nil {
			break
		}

		return e.complexity.GithubRepository.ID(childComplexity), true

	case "GithubRepository.isTemplate":
		if e.complexity.GithubRepository.IsTemplate == nil {
			break
		}

		return e.complexity.GithubRepository.IsTemplate(childComplexity), true

	case "GithubRepository.labels":
		if e.complexity.GithubRepository.Labels == nil {
			break
		}

		args, err := ec.field_GithubRepository_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GithubRepository.Labels(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.LabelOrder), args["where"].(*ent.LabelWhereInput)), true

	case "GithubRepository.license":
		if e.complexity.GithubRepository.License == nil {
			break
		}

		return e.complexity.GithubRepository.License(childComplexity), true

	case "GithubRepository.name":
		if e.complexity.GithubRepository.Name == nil {
			break
		}

		return e.complexity.GithubRepository.Name(childComplexity), true

	case "GithubRepository.owner":
		if e.complexity.GithubRepository.Owner == nil {
			break
		}

		return e.complexity.GithubRepository.Owner(childComplexity), true

	case "GithubRepository.ownerLogin":
		if e.complexity.GithubRepository.OwnerLogin == nil {
			break
		}

		return e.complexity.GithubRepository.OwnerLogin(childComplexity), true

	case "GithubRepository.public":
		if e.complexity.GithubRepository.Public == nil {
			break
		}

		return e.complexity.GithubRepository.Public(childComplexity), true

	case "GithubRepository.pushedAt":
		if e.complexity.GithubRepository.PushedAt == nil {
			break
		}

		return e.complexity.GithubRepository.PushedAt(childComplexity), true

	case "GithubRepository.releases":
		if e.complexity.GithubRepository.Releases == nil {
			break
		}

		args, err := ec.field_GithubRepository_releases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GithubRepository.Releases(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubReleaseOrder), args["where"].(*ent.GithubReleaseWhereInput)), true

	case "GithubRepository.repoID":
		if e.complexity.GithubRepository.RepoID == nil {
			break
		}

		return e.complexity.GithubRepository.RepoID(childComplexity), true

	case "GithubRepository.starCount":
		if e.complexity.GithubRepository.StarCount == nil {
			break
		}

		return e.complexity.GithubRepository.StarCount(childComplexity), true

	case "GithubRepository.updatedAt":
		if e.complexity.GithubRepository.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubRepository.UpdatedAt(childComplexity), true

	case "GithubRepositoryConnection.edges":
		if e.complexity.GithubRepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.GithubRepositoryConnection.Edges(childComplexity), true

	case "GithubRepositoryConnection.pageInfo":
		if e.complexity.GithubRepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.GithubRepositoryConnection.PageInfo(childComplexity), true

	case "GithubRepositoryConnection.totalCount":
		if e.complexity.GithubRepositoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.GithubRepositoryConnection.TotalCount(childComplexity), true

	case "GithubRepositoryEdge.cursor":
		if e.complexity.GithubRepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.GithubRepositoryEdge.Cursor(childComplexity), true

	case "GithubRepositoryEdge.node":
		if e.complexity.GithubRepositoryEdge.Node == nil {
			break
		}

		return e.complexity.GithubRepositoryEdge.Node(childComplexity), true

	case "GithubStats.closedIssues":
		if e.complexity.GithubStats.ClosedIssues == nil {
			break
		}

		return e.complexity.GithubStats.ClosedIssues(childComplexity), true

	case "GithubStats.commitsYear":
		if e.complexity.GithubStats.CommitsYear == nil {
			break
		}

		return e.complexity.GithubStats.CommitsYear(childComplexity), true

	case "GithubStats.contributedRepos":
		if e.complexity.GithubStats.ContributedRepos == nil {
			break
		}

		return e.complexity.GithubStats.ContributedRepos(childComplexity), true

	case "GithubStats.issues":
		if e.complexity.GithubStats.Issues == nil {
			break
		}

		return e.complexity.GithubStats.Issues(childComplexity), true

	case "GithubStats.openIssues":
		if e.complexity.GithubStats.OpenIssues == nil {
			break
		}

		return e.complexity.GithubStats.OpenIssues(childComplexity), true

	case "GithubStats.pullRequests":
		if e.complexity.GithubStats.PullRequests == nil {
			break
		}

		return e.complexity.GithubStats.PullRequests(childComplexity), true

	case "GithubStats.repos":
		if e.complexity.GithubStats.Repos == nil {
			break
		}

		return e.complexity.GithubStats.Repos(childComplexity), true

	case "GithubStats.stars":
		if e.complexity.GithubStats.Stars == nil {
			break
		}

		return e.complexity.GithubStats.Stars(childComplexity), true

	case "GithubUser.avatarURL":
		if e.complexity.GithubUser.AvatarURL == nil {
			break
		}

		return e.complexity.GithubUser.AvatarURL(childComplexity), true

	case "GithubUser.bio":
		if e.complexity.GithubUser.Bio == nil {
			break
		}

		return e.complexity.GithubUser.Bio(childComplexity), true

	case "GithubUser.createdAt":
		if e.complexity.GithubUser.CreatedAt == nil {
			break
		}

		return e.complexity.GithubUser.CreatedAt(childComplexity), true

	case "GithubUser.email":
		if e.complexity.GithubUser.Email == nil {
			break
		}

		return e.complexity.GithubUser.Email(childComplexity), true

	case "GithubUser.followers":
		if e.complexity.GithubUser.Followers == nil {
			break
		}

		return e.complexity.GithubUser.Followers(childComplexity), true

	case "GithubUser.following":
		if e.complexity.GithubUser.Following == nil {
			break
		}

		return e.complexity.GithubUser.Following(childComplexity), true

	case "GithubUser.htmlurl":
		if e.complexity.GithubUser.HTMLURL == nil {
			break
		}

		return e.complexity.GithubUser.HTMLURL(childComplexity), true

	case "GithubUser.id":
		if e.complexity.GithubUser.ID == nil {
			break
		}

		return e.complexity.GithubUser.ID(childComplexity), true

	case "GithubUser.location":
		if e.complexity.GithubUser.Location == nil {
			break
		}

		return e.complexity.GithubUser.Location(childComplexity), true

	case "GithubUser.login":
		if e.complexity.GithubUser.Login == nil {
			break
		}

		return e.complexity.GithubUser.Login(childComplexity), true

	case "GithubUser.name":
		if e.complexity.GithubUser.Name == nil {
			break
		}

		return e.complexity.GithubUser.Name(childComplexity), true

	case "GithubUser.publicRepos":
		if e.complexity.GithubUser.PublicRepos == nil {
			break
		}

		return e.complexity.GithubUser.PublicRepos(childComplexity), true

	case "GithubUser.updatedAt":
		if e.complexity.GithubUser.UpdatedAt == nil {
			break
		}

		return e.complexity.GithubUser.UpdatedAt(childComplexity), true

	case "Label.createTime":
		if e.complexity.Label.CreateTime == nil {
			break
		}

		return e.complexity.Label.CreateTime(childComplexity), true

	case "Label.githubRepositories":
		if e.complexity.Label.GithubRepositories == nil {
			break
		}

		args, err := ec.field_Label_githubRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.GithubRepositories(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubRepositoryOrder), args["where"].(*ent.GithubRepositoryWhereInput)), true

	case "Label.id":
		if e.complexity.Label.ID == nil {
			break
		}

		return e.complexity.Label.ID(childComplexity), true

	case "Label.name":
		if e.complexity.Label.Name == nil {
			break
		}

		return e.complexity.Label.Name(childComplexity), true

	case "Label.posts":
		if e.complexity.Label.Posts == nil {
			break
		}

		args, err := ec.field_Label_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.Posts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PostOrder), args["where"].(*ent.PostWhereInput)), true

	case "Label.updateTime":
		if e.complexity.Label.UpdateTime == nil {
			break
		}

		return e.complexity.Label.UpdateTime(childComplexity), true

	case "LabelConnection.edges":
		if e.complexity.LabelConnection.Edges == nil {
			break
		}

		return e.complexity.LabelConnection.Edges(childComplexity), true

	case "LabelConnection.pageInfo":
		if e.complexity.LabelConnection.PageInfo == nil {
			break
		}

		return e.complexity.LabelConnection.PageInfo(childComplexity), true

	case "LabelConnection.totalCount":
		if e.complexity.LabelConnection.TotalCount == nil {
			break
		}

		return e.complexity.LabelConnection.TotalCount(childComplexity), true

	case "LabelEdge.cursor":
		if e.complexity.LabelEdge.Cursor == nil {
			break
		}

		return e.complexity.LabelEdge.Cursor(childComplexity), true

	case "LabelEdge.node":
		if e.complexity.LabelEdge.Node == nil {
			break
		}

		return e.complexity.LabelEdge.Node(childComplexity), true

	case "LanguageStat.hexColor":
		if e.complexity.LanguageStat.HexColor == nil {
			break
		}

		return e.complexity.LanguageStat.HexColor(childComplexity), true

	case "LanguageStat.language":
		if e.complexity.LanguageStat.Language == nil {
			break
		}

		return e.complexity.LanguageStat.Language(childComplexity), true

	case "LanguageStat.totalDuration":
		if e.complexity.LanguageStat.TotalDuration == nil {
			break
		}

		return e.complexity.LanguageStat.TotalDuration(childComplexity), true

	case "LanguageStat.totalSeconds":
		if e.complexity.LanguageStat.TotalSeconds == nil {
			break
		}

		return e.complexity.LanguageStat.TotalSeconds(childComplexity), true

	case "Link.name":
		if e.complexity.Link.Name == nil {
			break
		}

		return e.complexity.Link.Name(childComplexity), true

	case "Link.url":
		if e.complexity.Link.URL == nil {
			break
		}

		return e.complexity.Link.URL(childComplexity), true

	case "Mutation.createLabel":
		if e.complexity.Mutation.CreateLabel == nil {
			break
		}

		args, err := ec.field_Mutation_createLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLabel(childComplexity, args["input"].(ent.CreateLabelInput)), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(ent.CreatePostInput)), true

	case "Mutation.deleteLabel":
		if e.complexity.Mutation.DeleteLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLabel(childComplexity, args["id"].(int)), true

	case "Mutation.deletePost":
		if e.complexity.Mutation.DeletePost == nil {
			break
		}

		args, err := ec.field_Mutation_deletePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePost(childComplexity, args["id"].(int)), true

	case "Mutation.ping":
		if e.complexity.Mutation.Ping == nil {
			break
		}

		return e.complexity.Mutation.Ping(childComplexity), true

	case "Mutation.regeneratePosts":
		if e.complexity.Mutation.RegeneratePosts == nil {
			break
		}

		return e.complexity.Mutation.RegeneratePosts(childComplexity), true

	case "Mutation.updateLabel":
		if e.complexity.Mutation.UpdateLabel == nil {
			break
		}

		args, err := ec.field_Mutation_updateLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLabel(childComplexity, args["id"].(int), args["input"].(ent.UpdateLabelInput)), true

	case "Mutation.updatePost":
		if e.complexity.Mutation.UpdatePost == nil {
			break
		}

		args, err := ec.field_Mutation_updatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePost(childComplexity, args["id"].(int), args["input"].(ent.UpdatePostInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Post.author":
		if e.complexity.Post.Author == nil {
			break
		}

		return e.complexity.Post.Author(childComplexity), true

	case "Post.content":
		if e.complexity.Post.Content == nil {
			break
		}

		return e.complexity.Post.Content(childComplexity), true

	case "Post.contentHTML":
		if e.complexity.Post.ContentHTML == nil {
			break
		}

		return e.complexity.Post.ContentHTML(childComplexity), true

	case "Post.createTime":
		if e.complexity.Post.CreateTime == nil {
			break
		}

		return e.complexity.Post.CreateTime(childComplexity), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.labels":
		if e.complexity.Post.Labels == nil {
			break
		}

		args, err := ec.field_Post_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.Labels(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.LabelOrder), args["where"].(*ent.LabelWhereInput)), true

	case "Post.public":
		if e.complexity.Post.Public == nil {
			break
		}

		return e.complexity.Post.Public(childComplexity), true

	case "Post.publishedAt":
		if e.complexity.Post.PublishedAt == nil {
			break
		}

		return e.complexity.Post.PublishedAt(childComplexity), true

	case "Post.slug":
		if e.complexity.Post.Slug == nil {
			break
		}

		return e.complexity.Post.Slug(childComplexity), true

	case "Post.summary":
		if e.complexity.Post.Summary == nil {
			break
		}

		return e.complexity.Post.Summary(childComplexity), true

	case "Post.title":
		if e.complexity.Post.Title == nil {
			break
		}

		return e.complexity.Post.Title(childComplexity), true

	case "Post.updateTime":
		if e.complexity.Post.UpdateTime == nil {
			break
		}

		return e.complexity.Post.UpdateTime(childComplexity), true

	case "Post.viewCount":
		if e.complexity.Post.ViewCount == nil {
			break
		}

		return e.complexity.Post.ViewCount(childComplexity), true

	case "PostConnection.edges":
		if e.complexity.PostConnection.Edges == nil {
			break
		}

		return e.complexity.PostConnection.Edges(childComplexity), true

	case "PostConnection.pageInfo":
		if e.complexity.PostConnection.PageInfo == nil {
			break
		}

		return e.complexity.PostConnection.PageInfo(childComplexity), true

	case "PostConnection.totalCount":
		if e.complexity.PostConnection.TotalCount == nil {
			break
		}

		return e.complexity.PostConnection.TotalCount(childComplexity), true

	case "PostEdge.cursor":
		if e.complexity.PostEdge.Cursor == nil {
			break
		}

		return e.complexity.PostEdge.Cursor(childComplexity), true

	case "PostEdge.node":
		if e.complexity.PostEdge.Node == nil {
			break
		}

		return e.complexity.PostEdge.Node(childComplexity), true

	case "Query.codingStats":
		if e.complexity.Query.CodingStats == nil {
			break
		}

		return e.complexity.Query.CodingStats(childComplexity), true

	case "Query.githubAssets":
		if e.complexity.Query.GithubAssets == nil {
			break
		}

		args, err := ec.field_Query_githubAssets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubAssets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubAssetOrder), args["where"].(*ent.GithubAssetWhereInput)), true

	case "Query.githubEvents":
		if e.complexity.Query.GithubEvents == nil {
			break
		}

		args, err := ec.field_Query_githubEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubEvents(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubEventOrder), args["where"].(*ent.GithubEventWhereInput)), true

	case "Query.githubGists":
		if e.complexity.Query.GithubGists == nil {
			break
		}

		args, err := ec.field_Query_githubGists_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubGists(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubGistOrder), args["where"].(*ent.GithubGistWhereInput)), true

	case "Query.githubReleases":
		if e.complexity.Query.GithubReleases == nil {
			break
		}

		args, err := ec.field_Query_githubReleases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubReleases(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubReleaseOrder), args["where"].(*ent.GithubReleaseWhereInput)), true

	case "Query.githubRepositories":
		if e.complexity.Query.GithubRepositories == nil {
			break
		}

		args, err := ec.field_Query_githubRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubRepositories(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.GithubRepositoryOrder), args["where"].(*ent.GithubRepositoryWhereInput)), true

	case "Query.githubStats":
		if e.complexity.Query.GithubStats == nil {
			break
		}

		return e.complexity.Query.GithubStats(childComplexity), true

	case "Query.githubUser":
		if e.complexity.Query.GithubUser == nil {
			break
		}

		return e.complexity.Query.GithubUser(childComplexity), true

	case "Query.labels":
		if e.complexity.Query.Labels == nil {
			break
		}

		args, err := ec.field_Query_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Labels(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.LabelOrder), args["where"].(*ent.LabelWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PostOrder), args["where"].(*ent.PostWhereInput)), true

	case "Query.self":
		if e.complexity.Query.Self == nil {
			break
		}

		return e.complexity.Query.Self(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "Timestamp.Time":
		if e.complexity.Timestamp.Time == nil {
			break
		}

		return e.complexity.Timestamp.Time(childComplexity), true

	case "User.avatarURL":
		if e.complexity.User.AvatarURL == nil {
			break
		}

		return e.complexity.User.AvatarURL(childComplexity), true

	case "User.bio":
		if e.complexity.User.Bio == nil {
			break
		}

		return e.complexity.User.Bio(childComplexity), true

	case "User.createTime":
		if e.complexity.User.CreateTime == nil {
			break
		}

		return e.complexity.User.CreateTime(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.htmlURL":
		if e.complexity.User.HTMLURL == nil {
			break
		}

		return e.complexity.User.HTMLURL(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.location":
		if e.complexity.User.Location == nil {
			break
		}

		return e.complexity.User.Location(childComplexity), true

	case "User.login":
		if e.complexity.User.Login == nil {
			break
		}

		return e.complexity.User.Login(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.posts":
		if e.complexity.User.Posts == nil {
			break
		}

		args, err := ec.field_User_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Posts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PostOrder), args["where"].(*ent.PostWhereInput)), true

	case "User.updateTime":
		if e.complexity.User.UpdateTime == nil {
			break
		}

		return e.complexity.User.UpdateTime(childComplexity), true

	case "User.userID":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "VersionInfo.arch":
		if e.complexity.VersionInfo.Arch == nil {
			break
		}

		return e.complexity.VersionInfo.Arch(childComplexity), true

	case "VersionInfo.command":
		if e.complexity.VersionInfo.Command == nil {
			break
		}

		return e.complexity.VersionInfo.Command(childComplexity), true

	case "VersionInfo.commit":
		if e.complexity.VersionInfo.Commit == nil {
			break
		}

		return e.complexity.VersionInfo.Commit(childComplexity), true

	case "VersionInfo.date":
		if e.complexity.VersionInfo.Date == nil {
			break
		}

		return e.complexity.VersionInfo.Date(childComplexity), true

	case "VersionInfo.goVersion":
		if e.complexity.VersionInfo.GoVersion == nil {
			break
		}

		return e.complexity.VersionInfo.GoVersion(childComplexity), true

	case "VersionInfo.links":
		if e.complexity.VersionInfo.Links == nil {
			break
		}

		return e.complexity.VersionInfo.Links(childComplexity), true

	case "VersionInfo.name":
		if e.complexity.VersionInfo.Name == nil {
			break
		}

		return e.complexity.VersionInfo.Name(childComplexity), true

	case "VersionInfo.os":
		if e.complexity.VersionInfo.OS == nil {
			break
		}

		return e.complexity.VersionInfo.OS(childComplexity), true

	case "VersionInfo.version":
		if e.complexity.VersionInfo.Version == nil {
			break
		}

		return e.complexity.VersionInfo.Version(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateLabelInput,
		ec.unmarshalInputCreatePostInput,
		ec.unmarshalInputGithubAssetOrder,
		ec.unmarshalInputGithubAssetWhereInput,
		ec.unmarshalInputGithubEventOrder,
		ec.unmarshalInputGithubEventWhereInput,
		ec.unmarshalInputGithubGistOrder,
		ec.unmarshalInputGithubGistWhereInput,
		ec.unmarshalInputGithubReleaseOrder,
		ec.unmarshalInputGithubReleaseWhereInput,
		ec.unmarshalInputGithubRepositoryOrder,
		ec.unmarshalInputGithubRepositoryWhereInput,
		ec.unmarshalInputLabelOrder,
		ec.unmarshalInputLabelWhereInput,
		ec.unmarshalInputPostOrder,
		ec.unmarshalInputPostWhereInput,
		ec.unmarshalInputUpdateLabelInput,
		ec.unmarshalInputUpdatePostInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/core.gql", Input: `scalar Upload
scalar Any

# stub that other mutations should extend.
type Mutation {
    ping: String
}
`, BuiltIn: false},
	{Name: "../schema/ent.gql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateLabelInput is used for create Label object.
Input was generated by ent.
"""
input CreateLabelInput {
  createTime: Time
  updateTime: Time
  name: String!
  postIDs: [ID!]
  githubRepositoryIDs: [ID!]
}
"""
CreatePostInput is used for create Post object.
Input was generated by ent.
"""
input CreatePostInput {
  createTime: Time
  updateTime: Time
  slug: String!
  title: String!
  content: String!
  publishedAt: Time
  public: Boolean
  labelIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type GithubAsset implements Node {
  id: ID!
  assetID: Int!
  browserDownloadURL: String!
  name: String!
  label: String
  state: String
  contentType: String!
  size: Int!
  downloadCount: Int!
  createdAt: Time!
  updatedAt: Time
  uploader: GithubUser!
  release: GithubRelease!
}
"""A connection to a list of items."""
type GithubAssetConnection {
  """A list of edges."""
  edges: [GithubAssetEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GithubAssetEdge {
  """The item at the end of the edge."""
  node: GithubAsset
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for GithubAsset connections"""
input GithubAssetOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order GithubAssets."""
  field: GithubAssetOrderField!
}
"""Properties by which GithubAsset connections can be ordered."""
enum GithubAssetOrderField {
  NAME
  DOWNLOAD_COUNT
  CREATED_AT
  UPDATED_AT
}
"""
GithubAssetWhereInput is used for filtering GithubAsset objects.
Input was generated by ent.
"""
input GithubAssetWhereInput {
  not: GithubAssetWhereInput
  and: [GithubAssetWhereInput!]
  or: [GithubAssetWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """asset_id field predicates"""
  assetID: Int
  assetIDNEQ: Int
  assetIDIn: [Int!]
  assetIDNotIn: [Int!]
  assetIDGT: Int
  assetIDGTE: Int
  assetIDLT: Int
  assetIDLTE: Int
  """browser_download_url field predicates"""
  browserDownloadURL: String
  browserDownloadURLNEQ: String
  browserDownloadURLIn: [String!]
  browserDownloadURLNotIn: [String!]
  browserDownloadURLGT: String
  browserDownloadURLGTE: String
  browserDownloadURLLT: String
  browserDownloadURLLTE: String
  browserDownloadURLContains: String
  browserDownloadURLHasPrefix: String
  browserDownloadURLHasSuffix: String
  browserDownloadURLEqualFold: String
  browserDownloadURLContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """label field predicates"""
  label: String
  labelNEQ: String
  labelIn: [String!]
  labelNotIn: [String!]
  labelGT: String
  labelGTE: String
  labelLT: String
  labelLTE: String
  labelContains: String
  labelHasPrefix: String
  labelHasSuffix: String
  labelIsNil: Boolean
  labelNotNil: Boolean
  labelEqualFold: String
  labelContainsFold: String
  """state field predicates"""
  state: String
  stateNEQ: String
  stateIn: [String!]
  stateNotIn: [String!]
  stateGT: String
  stateGTE: String
  stateLT: String
  stateLTE: String
  stateContains: String
  stateHasPrefix: String
  stateHasSuffix: String
  stateIsNil: Boolean
  stateNotNil: Boolean
  stateEqualFold: String
  stateContainsFold: String
  """content_type field predicates"""
  contentType: String
  contentTypeNEQ: String
  contentTypeIn: [String!]
  contentTypeNotIn: [String!]
  contentTypeGT: String
  contentTypeGTE: String
  contentTypeLT: String
  contentTypeLTE: String
  contentTypeContains: String
  contentTypeHasPrefix: String
  contentTypeHasSuffix: String
  contentTypeEqualFold: String
  contentTypeContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """download_count field predicates"""
  downloadCount: Int
  downloadCountNEQ: Int
  downloadCountIn: [Int!]
  downloadCountNotIn: [Int!]
  downloadCountGT: Int
  downloadCountGTE: Int
  downloadCountLT: Int
  downloadCountLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """release edge predicates"""
  hasRelease: Boolean
  hasReleaseWith: [GithubReleaseWhereInput!]
}
type GithubEvent implements Node {
  id: ID!
  eventID: String!
  eventType: String!
  createdAt: Time!
  public: Boolean!
  actorID: Int!
  actor: GithubUser!
  repoID: Int!
  repo: GithubEventRepo!
  payload: Map!
}
"""A connection to a list of items."""
type GithubEventConnection {
  """A list of edges."""
  edges: [GithubEventEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GithubEventEdge {
  """The item at the end of the edge."""
  node: GithubEvent
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for GithubEvent connections"""
input GithubEventOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order GithubEvents."""
  field: GithubEventOrderField!
}
"""Properties by which GithubEvent connections can be ordered."""
enum GithubEventOrderField {
  EVENT_ID
  EVENT_TYPE
  CREATED_AT
  ACTOR_ID
  REPO_ID
}
"""
GithubEventWhereInput is used for filtering GithubEvent objects.
Input was generated by ent.
"""
input GithubEventWhereInput {
  not: GithubEventWhereInput
  and: [GithubEventWhereInput!]
  or: [GithubEventWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """event_id field predicates"""
  eventID: String
  eventIDNEQ: String
  eventIDIn: [String!]
  eventIDNotIn: [String!]
  eventIDGT: String
  eventIDGTE: String
  eventIDLT: String
  eventIDLTE: String
  eventIDContains: String
  eventIDHasPrefix: String
  eventIDHasSuffix: String
  eventIDEqualFold: String
  eventIDContainsFold: String
  """event_type field predicates"""
  eventType: String
  eventTypeNEQ: String
  eventTypeIn: [String!]
  eventTypeNotIn: [String!]
  eventTypeGT: String
  eventTypeGTE: String
  eventTypeLT: String
  eventTypeLTE: String
  eventTypeContains: String
  eventTypeHasPrefix: String
  eventTypeHasSuffix: String
  eventTypeEqualFold: String
  eventTypeContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """public field predicates"""
  public: Boolean
  publicNEQ: Boolean
  """actor_id field predicates"""
  actorID: Int
  actorIDNEQ: Int
  actorIDIn: [Int!]
  actorIDNotIn: [Int!]
  actorIDGT: Int
  actorIDGTE: Int
  actorIDLT: Int
  actorIDLTE: Int
  """repo_id field predicates"""
  repoID: Int
  repoIDNEQ: Int
  repoIDIn: [Int!]
  repoIDNotIn: [Int!]
  repoIDGT: Int
  repoIDGTE: Int
  repoIDLT: Int
  repoIDLTE: Int
}
type GithubGist implements Node {
  id: ID!
  gistID: String!
  htmlURL: String!
  public: Boolean!
  createdAt: Time!
  updatedAt: Time!
  description: String
  owner: GithubUser!
  name: String!
  type: String!
  language: String
  size: Int!
  rawURL: String!
  content: String!
}
"""A connection to a list of items."""
type GithubGistConnection {
  """A list of edges."""
  edges: [GithubGistEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GithubGistEdge {
  """The item at the end of the edge."""
  node: GithubGist
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for GithubGist connections"""
input GithubGistOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order GithubGists."""
  field: GithubGistOrderField!
}
"""Properties by which GithubGist connections can be ordered."""
enum GithubGistOrderField {
  CREATED_AT
  UPDATED_AT
  NAME
  TYPE
  LANGUAGE
  SIZE
}
"""
GithubGistWhereInput is used for filtering GithubGist objects.
Input was generated by ent.
"""
input GithubGistWhereInput {
  not: GithubGistWhereInput
  and: [GithubGistWhereInput!]
  or: [GithubGistWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """gist_id field predicates"""
  gistID: String
  gistIDNEQ: String
  gistIDIn: [String!]
  gistIDNotIn: [String!]
  gistIDGT: String
  gistIDGTE: String
  gistIDLT: String
  gistIDLTE: String
  gistIDContains: String
  gistIDHasPrefix: String
  gistIDHasSuffix: String
  gistIDEqualFold: String
  gistIDContainsFold: String
  """html_url field predicates"""
  htmlURL: String
  htmlURLNEQ: String
  htmlURLIn: [String!]
  htmlURLNotIn: [String!]
  htmlURLGT: String
  htmlURLGTE: String
  htmlURLLT: String
  htmlURLLTE: String
  htmlURLContains: String
  htmlURLHasPrefix: String
  htmlURLHasSuffix: String
  htmlURLEqualFold: String
  htmlURLContainsFold: String
  """public field predicates"""
  public: Boolean
  publicNEQ: Boolean
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """type field predicates"""
  type: String
  typeNEQ: String
  typeIn: [String!]
  typeNotIn: [String!]
  typeGT: String
  typeGTE: String
  typeLT: String
  typeLTE: String
  typeContains: String
  typeHasPrefix: String
  typeHasSuffix: String
  typeEqualFold: String
  typeContainsFold: String
  """language field predicates"""
  language: String
  languageNEQ: String
  languageIn: [String!]
  languageNotIn: [String!]
  languageGT: String
  languageGTE: String
  languageLT: String
  languageLTE: String
  languageContains: String
  languageHasPrefix: String
  languageHasSuffix: String
  languageIsNil: Boolean
  languageNotNil: Boolean
  languageEqualFold: String
  languageContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """raw_url field predicates"""
  rawURL: String
  rawURLNEQ: String
  rawURLIn: [String!]
  rawURLNotIn: [String!]
  rawURLGT: String
  rawURLGTE: String
  rawURLLT: String
  rawURLLTE: String
  rawURLContains: String
  rawURLHasPrefix: String
  rawURLHasSuffix: String
  rawURLEqualFold: String
  rawURLContainsFold: String
  """content field predicates"""
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentEqualFold: String
  contentContainsFold: String
}
type GithubRelease implements Node {
  id: ID!
  releaseID: Int!
  htmlURL: String!
  tagName: String!
  targetCommitish: String!
  name: String
  draft: Boolean!
  prerelease: Boolean!
  createdAt: Time!
  publishedAt: Time!
  author: GithubUser!
  repository: GithubRepository!
  assets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubAssets returned from the connection."""
    orderBy: GithubAssetOrder

    """Filtering options for GithubAssets returned from the connection."""
    where: GithubAssetWhereInput
  ): GithubAssetConnection!
}
"""A connection to a list of items."""
type GithubReleaseConnection {
  """A list of edges."""
  edges: [GithubReleaseEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GithubReleaseEdge {
  """The item at the end of the edge."""
  node: GithubRelease
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for GithubRelease connections"""
input GithubReleaseOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order GithubReleases."""
  field: GithubReleaseOrderField!
}
"""Properties by which GithubRelease connections can be ordered."""
enum GithubReleaseOrderField {
  TAG_NAME
  NAME
  CREATED_AT
  PUBLISHED_AT
}
"""
GithubReleaseWhereInput is used for filtering GithubRelease objects.
Input was generated by ent.
"""
input GithubReleaseWhereInput {
  not: GithubReleaseWhereInput
  and: [GithubReleaseWhereInput!]
  or: [GithubReleaseWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """release_id field predicates"""
  releaseID: Int
  releaseIDNEQ: Int
  releaseIDIn: [Int!]
  releaseIDNotIn: [Int!]
  releaseIDGT: Int
  releaseIDGTE: Int
  releaseIDLT: Int
  releaseIDLTE: Int
  """html_url field predicates"""
  htmlURL: String
  htmlURLNEQ: String
  htmlURLIn: [String!]
  htmlURLNotIn: [String!]
  htmlURLGT: String
  htmlURLGTE: String
  htmlURLLT: String
  htmlURLLTE: String
  htmlURLContains: String
  htmlURLHasPrefix: String
  htmlURLHasSuffix: String
  htmlURLEqualFold: String
  htmlURLContainsFold: String
  """tag_name field predicates"""
  tagName: String
  tagNameNEQ: String
  tagNameIn: [String!]
  tagNameNotIn: [String!]
  tagNameGT: String
  tagNameGTE: String
  tagNameLT: String
  tagNameLTE: String
  tagNameContains: String
  tagNameHasPrefix: String
  tagNameHasSuffix: String
  tagNameEqualFold: String
  tagNameContainsFold: String
  """target_commitish field predicates"""
  targetCommitish: String
  targetCommitishNEQ: String
  targetCommitishIn: [String!]
  targetCommitishNotIn: [String!]
  targetCommitishGT: String
  targetCommitishGTE: String
  targetCommitishLT: String
  targetCommitishLTE: String
  targetCommitishContains: String
  targetCommitishHasPrefix: String
  targetCommitishHasSuffix: String
  targetCommitishEqualFold: String
  targetCommitishContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """draft field predicates"""
  draft: Boolean
  draftNEQ: Boolean
  """prerelease field predicates"""
  prerelease: Boolean
  prereleaseNEQ: Boolean
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """published_at field predicates"""
  publishedAt: Time
  publishedAtNEQ: Time
  publishedAtIn: [Time!]
  publishedAtNotIn: [Time!]
  publishedAtGT: Time
  publishedAtGTE: Time
  publishedAtLT: Time
  publishedAtLTE: Time
  """repository edge predicates"""
  hasRepository: Boolean
  hasRepositoryWith: [GithubRepositoryWhereInput!]
  """assets edge predicates"""
  hasAssets: Boolean
  hasAssetsWith: [GithubAssetWhereInput!]
}
type GithubRepository implements Node {
  id: ID!
  repoID: Int!
  name: String!
  fullName: String!
  ownerLogin: String!
  owner: GithubUser!
  public: Boolean!
  htmlURL: String!
  description: String
  fork: Boolean!
  homepage: String
  starCount: Int!
  defaultBranch: String!
  isTemplate: Boolean!
  hasIssues: Boolean!
  archived: Boolean!
  pushedAt: Time
  createdAt: Time!
  updatedAt: Time
  license: GithubLicense
  labels(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Labels returned from the connection."""
    orderBy: LabelOrder

    """Filtering options for Labels returned from the connection."""
    where: LabelWhereInput
  ): LabelConnection!
  releases(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubReleases returned from the connection."""
    orderBy: GithubReleaseOrder

    """Filtering options for GithubReleases returned from the connection."""
    where: GithubReleaseWhereInput
  ): GithubReleaseConnection!
}
"""A connection to a list of items."""
type GithubRepositoryConnection {
  """A list of edges."""
  edges: [GithubRepositoryEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GithubRepositoryEdge {
  """The item at the end of the edge."""
  node: GithubRepository
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for GithubRepository connections"""
input GithubRepositoryOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order GithubRepositories."""
  field: GithubRepositoryOrderField!
}
"""Properties by which GithubRepository connections can be ordered."""
enum GithubRepositoryOrderField {
  NAME
  FULL_NAME
  OWNER_LOGIN
  STAR_COUNT
  PUSHED_AT
  CREATED_AT
  UPDATED_AT
}
"""
GithubRepositoryWhereInput is used for filtering GithubRepository objects.
Input was generated by ent.
"""
input GithubRepositoryWhereInput {
  not: GithubRepositoryWhereInput
  and: [GithubRepositoryWhereInput!]
  or: [GithubRepositoryWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """repo_id field predicates"""
  repoID: Int
  repoIDNEQ: Int
  repoIDIn: [Int!]
  repoIDNotIn: [Int!]
  repoIDGT: Int
  repoIDGTE: Int
  repoIDLT: Int
  repoIDLTE: Int
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """full_name field predicates"""
  fullName: String
  fullNameNEQ: String
  fullNameIn: [String!]
  fullNameNotIn: [String!]
  fullNameGT: String
  fullNameGTE: String
  fullNameLT: String
  fullNameLTE: String
  fullNameContains: String
  fullNameHasPrefix: String
  fullNameHasSuffix: String
  fullNameEqualFold: String
  fullNameContainsFold: String
  """owner_login field predicates"""
  ownerLogin: String
  ownerLoginNEQ: String
  ownerLoginIn: [String!]
  ownerLoginNotIn: [String!]
  ownerLoginGT: String
  ownerLoginGTE: String
  ownerLoginLT: String
  ownerLoginLTE: String
  ownerLoginContains: String
  ownerLoginHasPrefix: String
  ownerLoginHasSuffix: String
  ownerLoginEqualFold: String
  ownerLoginContainsFold: String
  """public field predicates"""
  public: Boolean
  publicNEQ: Boolean
  """html_url field predicates"""
  htmlURL: String
  htmlURLNEQ: String
  htmlURLIn: [String!]
  htmlURLNotIn: [String!]
  htmlURLGT: String
  htmlURLGTE: String
  htmlURLLT: String
  htmlURLLTE: String
  htmlURLContains: String
  htmlURLHasPrefix: String
  htmlURLHasSuffix: String
  htmlURLEqualFold: String
  htmlURLContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """fork field predicates"""
  fork: Boolean
  forkNEQ: Boolean
  """homepage field predicates"""
  homepage: String
  homepageNEQ: String
  homepageIn: [String!]
  homepageNotIn: [String!]
  homepageGT: String
  homepageGTE: String
  homepageLT: String
  homepageLTE: String
  homepageContains: String
  homepageHasPrefix: String
  homepageHasSuffix: String
  homepageIsNil: Boolean
  homepageNotNil: Boolean
  homepageEqualFold: String
  homepageContainsFold: String
  """star_count field predicates"""
  starCount: Int
  starCountNEQ: Int
  starCountIn: [Int!]
  starCountNotIn: [Int!]
  starCountGT: Int
  starCountGTE: Int
  starCountLT: Int
  starCountLTE: Int
  """default_branch field predicates"""
  defaultBranch: String
  defaultBranchNEQ: String
  defaultBranchIn: [String!]
  defaultBranchNotIn: [String!]
  defaultBranchGT: String
  defaultBranchGTE: String
  defaultBranchLT: String
  defaultBranchLTE: String
  defaultBranchContains: String
  defaultBranchHasPrefix: String
  defaultBranchHasSuffix: String
  defaultBranchEqualFold: String
  defaultBranchContainsFold: String
  """is_template field predicates"""
  isTemplate: Boolean
  isTemplateNEQ: Boolean
  """has_issues field predicates"""
  hasIssues: Boolean
  hasIssuesNEQ: Boolean
  """archived field predicates"""
  archived: Boolean
  archivedNEQ: Boolean
  """pushed_at field predicates"""
  pushedAt: Time
  pushedAtNEQ: Time
  pushedAtIn: [Time!]
  pushedAtNotIn: [Time!]
  pushedAtGT: Time
  pushedAtGTE: Time
  pushedAtLT: Time
  pushedAtLTE: Time
  pushedAtIsNil: Boolean
  pushedAtNotNil: Boolean
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """labels edge predicates"""
  hasLabels: Boolean
  hasLabelsWith: [LabelWhereInput!]
  """releases edge predicates"""
  hasReleases: Boolean
  hasReleasesWith: [GithubReleaseWhereInput!]
}
type Label implements Node {
  id: ID!
  createTime: Time!
  updateTime: Time!
  name: String!
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Posts returned from the connection."""
    orderBy: PostOrder

    """Filtering options for Posts returned from the connection."""
    where: PostWhereInput
  ): PostConnection!
  githubRepositories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubRepositories returned from the connection."""
    orderBy: GithubRepositoryOrder

    """Filtering options for GithubRepositories returned from the connection."""
    where: GithubRepositoryWhereInput
  ): GithubRepositoryConnection!
}
"""A connection to a list of items."""
type LabelConnection {
  """A list of edges."""
  edges: [LabelEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LabelEdge {
  """The item at the end of the edge."""
  node: Label
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Label connections"""
input LabelOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Labels."""
  field: LabelOrderField!
}
"""Properties by which Label connections can be ordered."""
enum LabelOrderField {
  NAME
}
"""
LabelWhereInput is used for filtering Label objects.
Input was generated by ent.
"""
input LabelWhereInput {
  not: LabelWhereInput
  and: [LabelWhereInput!]
  or: [LabelWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """create_time field predicates"""
  createTime: Time
  createTimeNEQ: Time
  createTimeIn: [Time!]
  createTimeNotIn: [Time!]
  createTimeGT: Time
  createTimeGTE: Time
  createTimeLT: Time
  createTimeLTE: Time
  """update_time field predicates"""
  updateTime: Time
  updateTimeNEQ: Time
  updateTimeIn: [Time!]
  updateTimeNotIn: [Time!]
  updateTimeGT: Time
  updateTimeGTE: Time
  updateTimeLT: Time
  updateTimeLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """posts edge predicates"""
  hasPosts: Boolean
  hasPostsWith: [PostWhereInput!]
  """github_repositories edge predicates"""
  hasGithubRepositories: Boolean
  hasGithubRepositoriesWith: [GithubRepositoryWhereInput!]
}
"""The builtin Map type"""
scalar Map
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/lrstanley/liam.sh/internal/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Post implements Node {
  id: ID!
  createTime: Time!
  updateTime: Time!
  slug: String!
  title: String!
  content: String!
  contentHTML: String!
  summary: String!
  publishedAt: Time!
  viewCount: Int!
  public: Boolean!
  author: User!
  labels(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Labels returned from the connection."""
    orderBy: LabelOrder

    """Filtering options for Labels returned from the connection."""
    where: LabelWhereInput
  ): LabelConnection!
}
"""A connection to a list of items."""
type PostConnection {
  """A list of edges."""
  edges: [PostEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PostEdge {
  """The item at the end of the edge."""
  node: Post
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Post connections"""
input PostOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Posts."""
  field: PostOrderField!
}
"""Properties by which Post connections can be ordered."""
enum PostOrderField {
  SLUG
  TITLE
  DATE
  VIEW_COUNT
}
"""
PostWhereInput is used for filtering Post objects.
Input was generated by ent.
"""
input PostWhereInput {
  not: PostWhereInput
  and: [PostWhereInput!]
  or: [PostWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """create_time field predicates"""
  createTime: Time
  createTimeNEQ: Time
  createTimeIn: [Time!]
  createTimeNotIn: [Time!]
  createTimeGT: Time
  createTimeGTE: Time
  createTimeLT: Time
  createTimeLTE: Time
  """update_time field predicates"""
  updateTime: Time
  updateTimeNEQ: Time
  updateTimeIn: [Time!]
  updateTimeNotIn: [Time!]
  updateTimeGT: Time
  updateTimeGTE: Time
  updateTimeLT: Time
  updateTimeLTE: Time
  """slug field predicates"""
  slug: String
  slugNEQ: String
  slugIn: [String!]
  slugNotIn: [String!]
  slugGT: String
  slugGTE: String
  slugLT: String
  slugLTE: String
  slugContains: String
  slugHasPrefix: String
  slugHasSuffix: String
  slugEqualFold: String
  slugContainsFold: String
  """title field predicates"""
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleEqualFold: String
  titleContainsFold: String
  """content field predicates"""
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentEqualFold: String
  contentContainsFold: String
  """content_html field predicates"""
  contentHTML: String
  contentHTMLNEQ: String
  contentHTMLIn: [String!]
  contentHTMLNotIn: [String!]
  contentHTMLGT: String
  contentHTMLGTE: String
  contentHTMLLT: String
  contentHTMLLTE: String
  contentHTMLContains: String
  contentHTMLHasPrefix: String
  contentHTMLHasSuffix: String
  contentHTMLEqualFold: String
  contentHTMLContainsFold: String
  """summary field predicates"""
  summary: String
  summaryNEQ: String
  summaryIn: [String!]
  summaryNotIn: [String!]
  summaryGT: String
  summaryGTE: String
  summaryLT: String
  summaryLTE: String
  summaryContains: String
  summaryHasPrefix: String
  summaryHasSuffix: String
  summaryEqualFold: String
  summaryContainsFold: String
  """published_at field predicates"""
  publishedAt: Time
  publishedAtNEQ: Time
  publishedAtIn: [Time!]
  publishedAtNotIn: [Time!]
  publishedAtGT: Time
  publishedAtGTE: Time
  publishedAtLT: Time
  publishedAtLTE: Time
  """view_count field predicates"""
  viewCount: Int
  viewCountNEQ: Int
  viewCountIn: [Int!]
  viewCountNotIn: [Int!]
  viewCountGT: Int
  viewCountGTE: Int
  viewCountLT: Int
  viewCountLTE: Int
  """public field predicates"""
  public: Boolean
  publicNEQ: Boolean
  """author edge predicates"""
  hasAuthor: Boolean
  hasAuthorWith: [UserWhereInput!]
  """labels edge predicates"""
  hasLabels: Boolean
  hasLabelsWith: [LabelWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  githubAssets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubAssets returned from the connection."""
    orderBy: GithubAssetOrder

    """Filtering options for GithubAssets returned from the connection."""
    where: GithubAssetWhereInput
  ): GithubAssetConnection!
  githubEvents(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubEvents returned from the connection."""
    orderBy: GithubEventOrder

    """Filtering options for GithubEvents returned from the connection."""
    where: GithubEventWhereInput
  ): GithubEventConnection!
  githubGists(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubGists returned from the connection."""
    orderBy: GithubGistOrder

    """Filtering options for GithubGists returned from the connection."""
    where: GithubGistWhereInput
  ): GithubGistConnection!
  githubReleases(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubReleases returned from the connection."""
    orderBy: GithubReleaseOrder

    """Filtering options for GithubReleases returned from the connection."""
    where: GithubReleaseWhereInput
  ): GithubReleaseConnection!
  githubRepositories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for GithubRepositories returned from the connection."""
    orderBy: GithubRepositoryOrder

    """Filtering options for GithubRepositories returned from the connection."""
    where: GithubRepositoryWhereInput
  ): GithubRepositoryConnection!
  labels(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Labels returned from the connection."""
    orderBy: LabelOrder

    """Filtering options for Labels returned from the connection."""
    where: LabelWhereInput
  ): LabelConnection!
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Posts returned from the connection."""
    orderBy: PostOrder

    """Filtering options for Posts returned from the connection."""
    where: PostWhereInput
  ): PostConnection!
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Users returned from the connection."""
    orderBy: UserOrder

    """Filtering options for Users returned from the connection."""
    where: UserWhereInput
  ): UserConnection!
}
"""The builtin Time type"""
scalar Time
"""
UpdateLabelInput is used for update Label object.
Input was generated by ent.
"""
input UpdateLabelInput {
  updateTime: Time
  name: String
  addPostIDs: [ID!]
  removePostIDs: [ID!]
  addGithubRepositoryIDs: [ID!]
  removeGithubRepositoryIDs: [ID!]
}
"""
UpdatePostInput is used for update Post object.
Input was generated by ent.
"""
input UpdatePostInput {
  updateTime: Time
  slug: String
  title: String
  content: String
  publishedAt: Time
  public: Boolean
  addLabelIDs: [ID!]
  removeLabelIDs: [ID!]
}
type User implements Node {
  id: ID!
  createTime: Time!
  updateTime: Time!
  userID: Int!
  login: String!
  name: String
  avatarURL: String
  htmlURL: String
  email: String
  location: String
  bio: String
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Posts returned from the connection."""
    orderBy: PostOrder

    """Filtering options for Posts returned from the connection."""
    where: PostWhereInput
  ): PostConnection!
}
"""A connection to a list of items."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for User connections"""
input UserOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Users."""
  field: UserOrderField!
}
"""Properties by which User connections can be ordered."""
enum UserOrderField {
  LOGIN
  NAME
  EMAIL
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """create_time field predicates"""
  createTime: Time
  createTimeNEQ: Time
  createTimeIn: [Time!]
  createTimeNotIn: [Time!]
  createTimeGT: Time
  createTimeGTE: Time
  createTimeLT: Time
  createTimeLTE: Time
  """update_time field predicates"""
  updateTime: Time
  updateTimeNEQ: Time
  updateTimeIn: [Time!]
  updateTimeNotIn: [Time!]
  updateTimeGT: Time
  updateTimeGTE: Time
  updateTimeLT: Time
  updateTimeLTE: Time
  """user_id field predicates"""
  userID: Int
  userIDNEQ: Int
  userIDIn: [Int!]
  userIDNotIn: [Int!]
  userIDGT: Int
  userIDGTE: Int
  userIDLT: Int
  userIDLTE: Int
  """login field predicates"""
  login: String
  loginNEQ: String
  loginIn: [String!]
  loginNotIn: [String!]
  loginGT: String
  loginGTE: String
  loginLT: String
  loginLTE: String
  loginContains: String
  loginHasPrefix: String
  loginHasSuffix: String
  loginEqualFold: String
  loginContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """avatar_url field predicates"""
  avatarURL: String
  avatarURLNEQ: String
  avatarURLIn: [String!]
  avatarURLNotIn: [String!]
  avatarURLGT: String
  avatarURLGTE: String
  avatarURLLT: String
  avatarURLLTE: String
  avatarURLContains: String
  avatarURLHasPrefix: String
  avatarURLHasSuffix: String
  avatarURLIsNil: Boolean
  avatarURLNotNil: Boolean
  avatarURLEqualFold: String
  avatarURLContainsFold: String
  """html_url field predicates"""
  htmlURL: String
  htmlURLNEQ: String
  htmlURLIn: [String!]
  htmlURLNotIn: [String!]
  htmlURLGT: String
  htmlURLGTE: String
  htmlURLLT: String
  htmlURLLTE: String
  htmlURLContains: String
  htmlURLHasPrefix: String
  htmlURLHasSuffix: String
  htmlURLIsNil: Boolean
  htmlURLNotNil: Boolean
  htmlURLEqualFold: String
  htmlURLContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailIsNil: Boolean
  emailNotNil: Boolean
  emailEqualFold: String
  emailContainsFold: String
  """location field predicates"""
  location: String
  locationNEQ: String
  locationIn: [String!]
  locationNotIn: [String!]
  locationGT: String
  locationGTE: String
  locationLT: String
  locationLTE: String
  locationContains: String
  locationHasPrefix: String
  locationHasSuffix: String
  locationIsNil: Boolean
  locationNotNil: Boolean
  locationEqualFold: String
  locationContainsFold: String
  """bio field predicates"""
  bio: String
  bioNEQ: String
  bioIn: [String!]
  bioNotIn: [String!]
  bioGT: String
  bioGTE: String
  bioLT: String
  bioLTE: String
  bioContains: String
  bioHasPrefix: String
  bioHasSuffix: String
  bioIsNil: Boolean
  bioNotNil: Boolean
  bioEqualFold: String
  bioContainsFold: String
  """posts edge predicates"""
  hasPosts: Boolean
  hasPostsWith: [PostWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/github.gql", Input: `extend type Query {
    githubUser: GithubUser!
}

# the Github API client aliases the time.Time type.
type Timestamp {
    Time: Time!
}

type GithubUser {
    id: Int!
    login: String!
    name: String
    avatarURL: String!
    email: String
    location: String
    bio: String
    htmlurl: String
    publicRepos: Int
    followers: Int
    following: Int
    createdAt: Timestamp
    updatedAt: Timestamp
}

type GithubEventRepo {
    id: Int!
    name: String!
    url: String!
}

type GithubLicense {
    key: String!
    name: String!
    spdxId: String
    htmlURL: String!
}
`, BuiltIn: false},
	{Name: "../schema/label.gql", Input: `extend type Mutation {
    createLabel(input: CreateLabelInput!): Label!
    updateLabel(id: ID!, input: UpdateLabelInput!): Label!
    deleteLabel(id: ID!): ID!
}
`, BuiltIn: false},
	{Name: "../schema/post.gql", Input: `extend type Mutation {
    createPost(input: CreatePostInput!): Post!
    updatePost(id: ID!, input: UpdatePostInput!): Post!
    deletePost(id: ID!): ID!
    regeneratePosts: Boolean!
}
`, BuiltIn: false},
	{Name: "../schema/stats.gql", Input: `type CodingStats {
    languages: [LanguageStat!]
    totalSeconds: Int!
    totalDuration: String!
    totalDurationShort: String!
    calculatedDays: Int!
}

type LanguageStat {
    language: String!
    hexColor: String!
    totalSeconds: Int!
    totalDuration: String!
}

type GithubStats {
    commitsYear: Int!
    pullRequests: Int!
    openIssues: Int!
    closedIssues: Int!
    issues: Int!
    repos: Int!
    contributedRepos: Int!
    stars: Int!
}

extend type Query {
    codingStats: CodingStats!
    githubStats: GithubStats!
}
`, BuiltIn: false},
	{Name: "../schema/user.gql", Input: `extend type Query {
    self: User
}
`, BuiltIn: false},
	{Name: "../schema/version.gql", Input: `type VersionInfo {
    name: String!
    version: String!
    commit: String!
    date: String!
    command: String!
    goVersion: String!
    os: String!
    arch: String!
    links: [Link!]
}

type Link {
    name: String!
    url: String!
}

extend type Query {
    version: VersionInfo!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_GithubRelease_assets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubAssetOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubAssetOrder2githubcomlrstanleyliamshinternalentGithubAssetOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubAssetWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_GithubRepository_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.LabelOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLabelOrder2githubcomlrstanleyliamshinternalentLabelOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LabelWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_GithubRepository_releases_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubReleaseOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubReleaseOrder2githubcomlrstanleyliamshinternalentGithubReleaseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubReleaseWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Label_githubRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubRepositoryOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubRepositoryOrder2githubcomlrstanleyliamshinternalentGithubRepositoryOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Label_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PostOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOPostOrder2githubcomlrstanleyliamshinternalentPostOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.PostWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_createLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateLabelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLabelInput2githubcomlrstanleyliamshinternalentCreateLabelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreatePostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreatePostInput2githubcomlrstanleyliamshinternalentCreatePostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateLabelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateLabelInput2githubcomlrstanleyliamshinternalentUpdateLabelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdatePostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdatePostInput2githubcomlrstanleyliamshinternalentUpdatePostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Post_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.LabelOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLabelOrder2githubcomlrstanleyliamshinternalentLabelOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LabelWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_githubAssets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubAssetOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubAssetOrder2githubcomlrstanleyliamshinternalentGithubAssetOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubAssetWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubEventOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubEventOrder2githubcomlrstanleyliamshinternalentGithubEventOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubEventWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubGists_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubGistOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubGistOrder2githubcomlrstanleyliamshinternalentGithubGistOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubGistWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubReleases_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubReleaseOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubReleaseOrder2githubcomlrstanleyliamshinternalentGithubReleaseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubReleaseWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_githubRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.GithubRepositoryOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGithubRepositoryOrder2githubcomlrstanleyliamshinternalentGithubRepositoryOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.GithubRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.LabelOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLabelOrder2githubcomlrstanleyliamshinternalentLabelOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LabelWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PostOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOPostOrder2githubcomlrstanleyliamshinternalentPostOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.PostWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.UserOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOUserOrder2githubcomlrstanleyliamshinternalentUserOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_User_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PostOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOPostOrder2githubcomlrstanleyliamshinternalentPostOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.PostWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CodingStats_languages(ctx context.Context, field graphql.CollectedField, obj *models.CodingStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodingStats_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Languages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.LanguageStat)
	fc.Result = res
	return ec.marshalOLanguageStat2githubcomlrstanleyliamshinternalmodelsLanguageStat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodingStats_languages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodingStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "language":
				return ec.fieldContext_LanguageStat_language(ctx, field)
			case "hexColor":
				return ec.fieldContext_LanguageStat_hexColor(ctx, field)
			case "totalSeconds":
				return ec.fieldContext_LanguageStat_totalSeconds(ctx, field)
			case "totalDuration":
				return ec.fieldContext_LanguageStat_totalDuration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LanguageStat", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodingStats_totalSeconds(ctx context.Context, field graphql.CollectedField, obj *models.CodingStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodingStats_totalSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodingStats_totalSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodingStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodingStats_totalDuration(ctx context.Context, field graphql.CollectedField, obj *models.CodingStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodingStats_totalDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodingStats_totalDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodingStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodingStats_totalDurationShort(ctx context.Context, field graphql.CollectedField, obj *models.CodingStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodingStats_totalDurationShort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalDurationShort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodingStats_totalDurationShort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodingStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodingStats_calculatedDays(ctx context.Context, field graphql.CollectedField, obj *models.CodingStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodingStats_calculatedDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalculatedDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodingStats_calculatedDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodingStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_assetID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_assetID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_assetID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_browserDownloadURL(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_browserDownloadURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrowserDownloadURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_browserDownloadURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_name(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_label(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_state(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_contentType(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_contentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_contentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_size(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_downloadCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_downloadCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DownloadCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_downloadCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_uploader(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_uploader(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uploader, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_uploader(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAsset_release(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAsset_release(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Release(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRelease)
	fc.Result = res
	return ec.marshalNGithubRelease2githubcomlrstanleyliamshinternalentGithubRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAsset_release(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAsset",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubRelease_id(ctx, field)
			case "releaseID":
				return ec.fieldContext_GithubRelease_releaseID(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubRelease_htmlURL(ctx, field)
			case "tagName":
				return ec.fieldContext_GithubRelease_tagName(ctx, field)
			case "targetCommitish":
				return ec.fieldContext_GithubRelease_targetCommitish(ctx, field)
			case "name":
				return ec.fieldContext_GithubRelease_name(ctx, field)
			case "draft":
				return ec.fieldContext_GithubRelease_draft(ctx, field)
			case "prerelease":
				return ec.fieldContext_GithubRelease_prerelease(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubRelease_createdAt(ctx, field)
			case "publishedAt":
				return ec.fieldContext_GithubRelease_publishedAt(ctx, field)
			case "author":
				return ec.fieldContext_GithubRelease_author(ctx, field)
			case "repository":
				return ec.fieldContext_GithubRelease_repository(ctx, field)
			case "assets":
				return ec.fieldContext_GithubRelease_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRelease", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAssetConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAssetConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAssetConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubAssetEdge)
	fc.Result = res
	return ec.marshalOGithubAssetEdge2githubcomlrstanleyliamshinternalentGithubAssetEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAssetConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAssetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubAssetEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubAssetEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAssetEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAssetConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAssetConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAssetConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAssetConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAssetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAssetConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAssetConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAssetConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAssetConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAssetConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAssetEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAssetEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAssetEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAsset)
	fc.Result = res
	return ec.marshalOGithubAsset2githubcomlrstanleyliamshinternalentGithubAsset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAssetEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAssetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubAsset_id(ctx, field)
			case "assetID":
				return ec.fieldContext_GithubAsset_assetID(ctx, field)
			case "browserDownloadURL":
				return ec.fieldContext_GithubAsset_browserDownloadURL(ctx, field)
			case "name":
				return ec.fieldContext_GithubAsset_name(ctx, field)
			case "label":
				return ec.fieldContext_GithubAsset_label(ctx, field)
			case "state":
				return ec.fieldContext_GithubAsset_state(ctx, field)
			case "contentType":
				return ec.fieldContext_GithubAsset_contentType(ctx, field)
			case "size":
				return ec.fieldContext_GithubAsset_size(ctx, field)
			case "downloadCount":
				return ec.fieldContext_GithubAsset_downloadCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubAsset_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubAsset_updatedAt(ctx, field)
			case "uploader":
				return ec.fieldContext_GithubAsset_uploader(ctx, field)
			case "release":
				return ec.fieldContext_GithubAsset_release(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAsset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAssetEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubAssetEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAssetEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAssetEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAssetEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_eventID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_eventType(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_public(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_actorID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_actorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_actorID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_actor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_actor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_repoID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_repoID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_repoID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_repo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.Repository)
	fc.Result = res
	return ec.marshalNGithubEventRepo2githubcomgooglegogithubv48githubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubEventRepo_id(ctx, field)
			case "name":
				return ec.fieldContext_GithubEventRepo_name(ctx, field)
			case "url":
				return ec.fieldContext_GithubEventRepo_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubEventRepo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEvent_payload(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEvent_payload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Payload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEvent_payload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubEventEdge)
	fc.Result = res
	return ec.marshalOGithubEventEdge2githubcomlrstanleyliamshinternalentGithubEventEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubEventEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubEventEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubEventEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubEvent)
	fc.Result = res
	return ec.marshalOGithubEvent2githubcomlrstanleyliamshinternalentGithubEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubEvent_id(ctx, field)
			case "eventID":
				return ec.fieldContext_GithubEvent_eventID(ctx, field)
			case "eventType":
				return ec.fieldContext_GithubEvent_eventType(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubEvent_createdAt(ctx, field)
			case "public":
				return ec.fieldContext_GithubEvent_public(ctx, field)
			case "actorID":
				return ec.fieldContext_GithubEvent_actorID(ctx, field)
			case "actor":
				return ec.fieldContext_GithubEvent_actor(ctx, field)
			case "repoID":
				return ec.fieldContext_GithubEvent_repoID(ctx, field)
			case "repo":
				return ec.fieldContext_GithubEvent_repo(ctx, field)
			case "payload":
				return ec.fieldContext_GithubEvent_payload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubEventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventRepo_id(ctx context.Context, field graphql.CollectedField, obj *github.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventRepo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventRepo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventRepo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventRepo_name(ctx context.Context, field graphql.CollectedField, obj *github.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventRepo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventRepo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventRepo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubEventRepo_url(ctx context.Context, field graphql.CollectedField, obj *github.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubEventRepo_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubEventRepo_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubEventRepo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_gistID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_gistID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GistID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_gistID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_htmlURL(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_htmlURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_htmlURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_public(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_description(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_owner(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_name(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_type(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_language(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_size(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_rawURL(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_rawURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_rawURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGist_content(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGist) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGist_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGist_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGistConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGistConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGistConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubGistEdge)
	fc.Result = res
	return ec.marshalOGithubGistEdge2githubcomlrstanleyliamshinternalentGithubGistEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGistConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGistConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubGistEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubGistEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubGistEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGistConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGistConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGistConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGistConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGistConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGistConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGistConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGistConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGistConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGistConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGistEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGistEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGistEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubGist)
	fc.Result = res
	return ec.marshalOGithubGist2githubcomlrstanleyliamshinternalentGithubGist(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGistEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGistEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubGist_id(ctx, field)
			case "gistID":
				return ec.fieldContext_GithubGist_gistID(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubGist_htmlURL(ctx, field)
			case "public":
				return ec.fieldContext_GithubGist_public(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubGist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubGist_updatedAt(ctx, field)
			case "description":
				return ec.fieldContext_GithubGist_description(ctx, field)
			case "owner":
				return ec.fieldContext_GithubGist_owner(ctx, field)
			case "name":
				return ec.fieldContext_GithubGist_name(ctx, field)
			case "type":
				return ec.fieldContext_GithubGist_type(ctx, field)
			case "language":
				return ec.fieldContext_GithubGist_language(ctx, field)
			case "size":
				return ec.fieldContext_GithubGist_size(ctx, field)
			case "rawURL":
				return ec.fieldContext_GithubGist_rawURL(ctx, field)
			case "content":
				return ec.fieldContext_GithubGist_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubGist", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubGistEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubGistEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubGistEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubGistEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubGistEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubLicense_key(ctx context.Context, field graphql.CollectedField, obj *github.License) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubLicense_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubLicense_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubLicense_name(ctx context.Context, field graphql.CollectedField, obj *github.License) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubLicense_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubLicense_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubLicense_spdxId(ctx context.Context, field graphql.CollectedField, obj *github.License) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubLicense_spdxId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SPDXID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubLicense_spdxId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubLicense_htmlURL(ctx context.Context, field graphql.CollectedField, obj *github.License) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubLicense_htmlURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubLicense_htmlURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_releaseID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_releaseID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_releaseID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_htmlURL(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_htmlURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_htmlURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_tagName(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_tagName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_tagName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_targetCommitish(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_targetCommitish(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetCommitish, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_targetCommitish(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_name(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_draft(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_draft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Draft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_draft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_prerelease(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_prerelease(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prerelease, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_prerelease(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_publishedAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_publishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_publishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_author(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_repository(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRepository)
	fc.Result = res
	return ec.marshalNGithubRepository2githubcomlrstanleyliamshinternalentGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubRepository_id(ctx, field)
			case "repoID":
				return ec.fieldContext_GithubRepository_repoID(ctx, field)
			case "name":
				return ec.fieldContext_GithubRepository_name(ctx, field)
			case "fullName":
				return ec.fieldContext_GithubRepository_fullName(ctx, field)
			case "ownerLogin":
				return ec.fieldContext_GithubRepository_ownerLogin(ctx, field)
			case "owner":
				return ec.fieldContext_GithubRepository_owner(ctx, field)
			case "public":
				return ec.fieldContext_GithubRepository_public(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubRepository_htmlURL(ctx, field)
			case "description":
				return ec.fieldContext_GithubRepository_description(ctx, field)
			case "fork":
				return ec.fieldContext_GithubRepository_fork(ctx, field)
			case "homepage":
				return ec.fieldContext_GithubRepository_homepage(ctx, field)
			case "starCount":
				return ec.fieldContext_GithubRepository_starCount(ctx, field)
			case "defaultBranch":
				return ec.fieldContext_GithubRepository_defaultBranch(ctx, field)
			case "isTemplate":
				return ec.fieldContext_GithubRepository_isTemplate(ctx, field)
			case "hasIssues":
				return ec.fieldContext_GithubRepository_hasIssues(ctx, field)
			case "archived":
				return ec.fieldContext_GithubRepository_archived(ctx, field)
			case "pushedAt":
				return ec.fieldContext_GithubRepository_pushedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubRepository_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubRepository_updatedAt(ctx, field)
			case "license":
				return ec.fieldContext_GithubRepository_license(ctx, field)
			case "labels":
				return ec.fieldContext_GithubRepository_labels(ctx, field)
			case "releases":
				return ec.fieldContext_GithubRepository_releases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRelease_assets(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRelease) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRelease_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Assets(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubAssetOrder), fc.Args["where"].(*ent.GithubAssetWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAssetConnection)
	fc.Result = res
	return ec.marshalNGithubAssetConnection2githubcomlrstanleyliamshinternalentGithubAssetConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRelease_assets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRelease",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubAssetConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubAssetConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubAssetConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAssetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GithubRelease_assets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _GithubReleaseConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubReleaseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubReleaseConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubReleaseEdge)
	fc.Result = res
	return ec.marshalOGithubReleaseEdge2githubcomlrstanleyliamshinternalentGithubReleaseEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubReleaseConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubReleaseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubReleaseEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubReleaseEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubReleaseEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubReleaseConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubReleaseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubReleaseConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubReleaseConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubReleaseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubReleaseConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubReleaseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubReleaseConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubReleaseConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubReleaseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubReleaseEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubReleaseEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubReleaseEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRelease)
	fc.Result = res
	return ec.marshalOGithubRelease2githubcomlrstanleyliamshinternalentGithubRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubReleaseEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubReleaseEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubRelease_id(ctx, field)
			case "releaseID":
				return ec.fieldContext_GithubRelease_releaseID(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubRelease_htmlURL(ctx, field)
			case "tagName":
				return ec.fieldContext_GithubRelease_tagName(ctx, field)
			case "targetCommitish":
				return ec.fieldContext_GithubRelease_targetCommitish(ctx, field)
			case "name":
				return ec.fieldContext_GithubRelease_name(ctx, field)
			case "draft":
				return ec.fieldContext_GithubRelease_draft(ctx, field)
			case "prerelease":
				return ec.fieldContext_GithubRelease_prerelease(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubRelease_createdAt(ctx, field)
			case "publishedAt":
				return ec.fieldContext_GithubRelease_publishedAt(ctx, field)
			case "author":
				return ec.fieldContext_GithubRelease_author(ctx, field)
			case "repository":
				return ec.fieldContext_GithubRelease_repository(ctx, field)
			case "assets":
				return ec.fieldContext_GithubRelease_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRelease", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubReleaseEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubReleaseEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubReleaseEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubReleaseEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubReleaseEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_id(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_repoID(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_repoID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_repoID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_name(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_fullName(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_fullName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_fullName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_ownerLogin(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_ownerLogin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerLogin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_ownerLogin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_owner(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_public(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_htmlURL(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_htmlURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_htmlURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_description(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_fork(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_fork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fork, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_fork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_homepage(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_homepage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Homepage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_homepage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_starCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_starCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StarCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_starCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_defaultBranch(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_defaultBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_defaultBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_isTemplate(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_isTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_isTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_hasIssues(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_hasIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_hasIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_archived(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_archived(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Archived, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_archived(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_pushedAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_pushedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_pushedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_license(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_license(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.License, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*github.License)
	fc.Result = res
	return ec.marshalOGithubLicense2githubcomgooglegogithubv48githubLicense(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_license(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GithubLicense_key(ctx, field)
			case "name":
				return ec.fieldContext_GithubLicense_name(ctx, field)
			case "spdxId":
				return ec.fieldContext_GithubLicense_spdxId(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubLicense_htmlURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubLicense", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_labels(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.LabelOrder), fc.Args["where"].(*ent.LabelWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LabelConnection)
	fc.Result = res
	return ec.marshalNLabelConnection2githubcomlrstanleyliamshinternalentLabelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LabelConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LabelConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LabelConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GithubRepository_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepository_releases(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepository_releases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Releases(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubReleaseOrder), fc.Args["where"].(*ent.GithubReleaseWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubReleaseConnection)
	fc.Result = res
	return ec.marshalNGithubReleaseConnection2githubcomlrstanleyliamshinternalentGithubReleaseConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepository_releases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubReleaseConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubReleaseConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubReleaseConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubReleaseConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GithubRepository_releases_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepositoryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GithubRepositoryEdge)
	fc.Result = res
	return ec.marshalOGithubRepositoryEdge2githubcomlrstanleyliamshinternalentGithubRepositoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepositoryConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GithubRepositoryEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GithubRepositoryEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepositoryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepositoryConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepositoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepositoryConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepositoryConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepositoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRepository)
	fc.Result = res
	return ec.marshalOGithubRepository2githubcomlrstanleyliamshinternalentGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepositoryEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubRepository_id(ctx, field)
			case "repoID":
				return ec.fieldContext_GithubRepository_repoID(ctx, field)
			case "name":
				return ec.fieldContext_GithubRepository_name(ctx, field)
			case "fullName":
				return ec.fieldContext_GithubRepository_fullName(ctx, field)
			case "ownerLogin":
				return ec.fieldContext_GithubRepository_ownerLogin(ctx, field)
			case "owner":
				return ec.fieldContext_GithubRepository_owner(ctx, field)
			case "public":
				return ec.fieldContext_GithubRepository_public(ctx, field)
			case "htmlURL":
				return ec.fieldContext_GithubRepository_htmlURL(ctx, field)
			case "description":
				return ec.fieldContext_GithubRepository_description(ctx, field)
			case "fork":
				return ec.fieldContext_GithubRepository_fork(ctx, field)
			case "homepage":
				return ec.fieldContext_GithubRepository_homepage(ctx, field)
			case "starCount":
				return ec.fieldContext_GithubRepository_starCount(ctx, field)
			case "defaultBranch":
				return ec.fieldContext_GithubRepository_defaultBranch(ctx, field)
			case "isTemplate":
				return ec.fieldContext_GithubRepository_isTemplate(ctx, field)
			case "hasIssues":
				return ec.fieldContext_GithubRepository_hasIssues(ctx, field)
			case "archived":
				return ec.fieldContext_GithubRepository_archived(ctx, field)
			case "pushedAt":
				return ec.fieldContext_GithubRepository_pushedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubRepository_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubRepository_updatedAt(ctx, field)
			case "license":
				return ec.fieldContext_GithubRepository_license(ctx, field)
			case "labels":
				return ec.fieldContext_GithubRepository_labels(ctx, field)
			case "releases":
				return ec.fieldContext_GithubRepository_releases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubRepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.GithubRepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubRepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubRepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubRepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_commitsYear(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_commitsYear(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitsYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_commitsYear(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_pullRequests(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_pullRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PullRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_pullRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_openIssues(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_openIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_openIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_closedIssues(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_closedIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_closedIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_issues(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_issues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_repos(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_repos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_repos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_contributedRepos(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_contributedRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContributedRepos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_contributedRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubStats_stars(ctx context.Context, field graphql.CollectedField, obj *models.GithubStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubStats_stars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubStats_stars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_id(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_login(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Login, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_name(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_avatarURL(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_avatarURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_avatarURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_email(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_location(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_bio(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_bio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_htmlurl(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_htmlurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_htmlurl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_publicRepos(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_publicRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicRepos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_publicRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_followers(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Followers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_following(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_following(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Following, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_following(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*github.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomgooglegogithubv48githubTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Time":
				return ec.fieldContext_Timestamp_Time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Timestamp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *github.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*github.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomgooglegogithubv48githubTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Time":
				return ec.fieldContext_Timestamp_Time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Timestamp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_id(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_name(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_posts(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.PostOrder), fc.Args["where"].(*ent.PostWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.PostConnection)
	fc.Result = res
	return ec.marshalNPostConnection2githubcomlrstanleyliamshinternalentPostConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PostConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PostConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PostConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Label_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Label_githubRepositories(ctx context.Context, field graphql.CollectedField, obj *ent.Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_githubRepositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubRepositories(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubRepositoryOrder), fc.Args["where"].(*ent.GithubRepositoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRepositoryConnection)
	fc.Result = res
	return ec.marshalNGithubRepositoryConnection2githubcomlrstanleyliamshinternalentGithubRepositoryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_githubRepositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubRepositoryConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubRepositoryConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubRepositoryConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRepositoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Label_githubRepositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _LabelConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.LabelConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.LabelEdge)
	fc.Result = res
	return ec.marshalOLabelEdge2githubcomlrstanleyliamshinternalentLabelEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LabelEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LabelEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.LabelConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.LabelConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.LabelEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Label)
	fc.Result = res
	return ec.marshalOLabel2githubcomlrstanleyliamshinternalentLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Label_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Label_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Label_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Label_name(ctx, field)
			case "posts":
				return ec.fieldContext_Label_posts(ctx, field)
			case "githubRepositories":
				return ec.fieldContext_Label_githubRepositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.LabelEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageStat_language(ctx context.Context, field graphql.CollectedField, obj *models.LanguageStat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageStat_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageStat_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageStat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageStat_hexColor(ctx context.Context, field graphql.CollectedField, obj *models.LanguageStat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageStat_hexColor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HexColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageStat_hexColor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageStat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageStat_totalSeconds(ctx context.Context, field graphql.CollectedField, obj *models.LanguageStat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageStat_totalSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageStat_totalSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageStat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageStat_totalDuration(ctx context.Context, field graphql.CollectedField, obj *models.LanguageStat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageStat_totalDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageStat_totalDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageStat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Link_name(ctx context.Context, field graphql.CollectedField, obj *clix.Link) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Link_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Link_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Link",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *clix.Link) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Link_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Link_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Link",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Ping(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLabel(rctx, fc.Args["input"].(ent.CreateLabelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomlrstanleyliamshinternalentLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Label_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Label_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Label_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Label_name(ctx, field)
			case "posts":
				return ec.fieldContext_Label_posts(ctx, field)
			case "githubRepositories":
				return ec.fieldContext_Label_githubRepositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLabel(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateLabelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomlrstanleyliamshinternalentLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Label_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Label_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Label_updateTime(ctx, field)
			case "name":
				return ec.fieldContext_Label_name(ctx, field)
			case "posts":
				return ec.fieldContext_Label_posts(ctx, field)
			case "githubRepositories":
				return ec.fieldContext_Label_githubRepositories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLabel(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePost(rctx, fc.Args["input"].(ent.CreatePostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomlrstanleyliamshinternalentPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Post_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Post_updateTime(ctx, field)
			case "slug":
				return ec.fieldContext_Post_slug(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "contentHTML":
				return ec.fieldContext_Post_contentHTML(ctx, field)
			case "summary":
				return ec.fieldContext_Post_summary(ctx, field)
			case "publishedAt":
				return ec.fieldContext_Post_publishedAt(ctx, field)
			case "viewCount":
				return ec.fieldContext_Post_viewCount(ctx, field)
			case "public":
				return ec.fieldContext_Post_public(ctx, field)
			case "author":
				return ec.fieldContext_Post_author(ctx, field)
			case "labels":
				return ec.fieldContext_Post_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePost(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdatePostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomlrstanleyliamshinternalentPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Post_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Post_updateTime(ctx, field)
			case "slug":
				return ec.fieldContext_Post_slug(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "contentHTML":
				return ec.fieldContext_Post_contentHTML(ctx, field)
			case "summary":
				return ec.fieldContext_Post_summary(ctx, field)
			case "publishedAt":
				return ec.fieldContext_Post_publishedAt(ctx, field)
			case "viewCount":
				return ec.fieldContext_Post_viewCount(ctx, field)
			case "public":
				return ec.fieldContext_Post_public(ctx, field)
			case "author":
				return ec.fieldContext_Post_author(ctx, field)
			case "labels":
				return ec.fieldContext_Post_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deletePost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deletePost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePost(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deletePost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deletePost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_regeneratePosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_regeneratePosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegeneratePosts(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_regeneratePosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_id(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_slug(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_slug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_title(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_content(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_contentHTML(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_contentHTML(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentHTML, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_contentHTML(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_summary(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_summary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_publishedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_publishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_publishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_viewCount(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_viewCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_viewCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_public(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_author(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomlrstanleyliamshinternalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_User_userID(ctx, field)
			case "login":
				return ec.fieldContext_User_login(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "htmlURL":
				return ec.fieldContext_User_htmlURL(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "posts":
				return ec.fieldContext_User_posts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_labels(ctx context.Context, field graphql.CollectedField, obj *ent.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.LabelOrder), fc.Args["where"].(*ent.LabelWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LabelConnection)
	fc.Result = res
	return ec.marshalNLabelConnection2githubcomlrstanleyliamshinternalentLabelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LabelConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LabelConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LabelConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Post_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PostConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.PostConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PostEdge)
	fc.Result = res
	return ec.marshalOPostEdge2githubcomlrstanleyliamshinternalentPostEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PostEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PostEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.PostConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.PostConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.PostEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Post)
	fc.Result = res
	return ec.marshalOPost2githubcomlrstanleyliamshinternalentPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Post_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Post_updateTime(ctx, field)
			case "slug":
				return ec.fieldContext_Post_slug(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "contentHTML":
				return ec.fieldContext_Post_contentHTML(ctx, field)
			case "summary":
				return ec.fieldContext_Post_summary(ctx, field)
			case "publishedAt":
				return ec.fieldContext_Post_publishedAt(ctx, field)
			case "viewCount":
				return ec.fieldContext_Post_viewCount(ctx, field)
			case "public":
				return ec.fieldContext_Post_public(ctx, field)
			case "author":
				return ec.fieldContext_Post_author(ctx, field)
			case "labels":
				return ec.fieldContext_Post_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.PostEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomlrstanleyliamshinternalentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2githubcomlrstanleyliamshinternalentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubAssets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubAssets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubAssets(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubAssetOrder), fc.Args["where"].(*ent.GithubAssetWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubAssetConnection)
	fc.Result = res
	return ec.marshalNGithubAssetConnection2githubcomlrstanleyliamshinternalentGithubAssetConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubAssets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubAssetConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubAssetConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubAssetConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAssetConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubAssets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubEvents(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubEventOrder), fc.Args["where"].(*ent.GithubEventWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubEventConnection)
	fc.Result = res
	return ec.marshalNGithubEventConnection2githubcomlrstanleyliamshinternalentGithubEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubEventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubEventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubEventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubEventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubGists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubGists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubGists(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubGistOrder), fc.Args["where"].(*ent.GithubGistWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubGistConnection)
	fc.Result = res
	return ec.marshalNGithubGistConnection2githubcomlrstanleyliamshinternalentGithubGistConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubGists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubGistConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubGistConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubGistConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubGistConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubGists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubReleases(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubReleases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubReleases(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubReleaseOrder), fc.Args["where"].(*ent.GithubReleaseWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubReleaseConnection)
	fc.Result = res
	return ec.marshalNGithubReleaseConnection2githubcomlrstanleyliamshinternalentGithubReleaseConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubReleases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubReleaseConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubReleaseConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubReleaseConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubReleaseConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubReleases_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubRepositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubRepositories(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.GithubRepositoryOrder), fc.Args["where"].(*ent.GithubRepositoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.GithubRepositoryConnection)
	fc.Result = res
	return ec.marshalNGithubRepositoryConnection2githubcomlrstanleyliamshinternalentGithubRepositoryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubRepositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GithubRepositoryConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GithubRepositoryConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubRepositoryConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubRepositoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubRepositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_labels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Labels(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.LabelOrder), fc.Args["where"].(*ent.LabelWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LabelConnection)
	fc.Result = res
	return ec.marshalNLabelConnection2githubcomlrstanleyliamshinternalentLabelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LabelConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LabelConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LabelConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_posts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Posts(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.PostOrder), fc.Args["where"].(*ent.PostWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.PostConnection)
	fc.Result = res
	return ec.marshalNPostConnection2githubcomlrstanleyliamshinternalentPostConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PostConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PostConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PostConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.UserOrder), fc.Args["where"].(*ent.UserWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UserConnection)
	fc.Result = res
	return ec.marshalNUserConnection2githubcomlrstanleyliamshinternalentUserConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubUser(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*github.User)
	fc.Result = res
	return ec.marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GithubUser_id(ctx, field)
			case "login":
				return ec.fieldContext_GithubUser_login(ctx, field)
			case "name":
				return ec.fieldContext_GithubUser_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_GithubUser_avatarURL(ctx, field)
			case "email":
				return ec.fieldContext_GithubUser_email(ctx, field)
			case "location":
				return ec.fieldContext_GithubUser_location(ctx, field)
			case "bio":
				return ec.fieldContext_GithubUser_bio(ctx, field)
			case "htmlurl":
				return ec.fieldContext_GithubUser_htmlurl(ctx, field)
			case "publicRepos":
				return ec.fieldContext_GithubUser_publicRepos(ctx, field)
			case "followers":
				return ec.fieldContext_GithubUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_GithubUser_following(ctx, field)
			case "createdAt":
				return ec.fieldContext_GithubUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GithubUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_codingStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_codingStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CodingStats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CodingStats)
	fc.Result = res
	return ec.marshalNCodingStats2githubcomlrstanleyliamshinternalmodelsCodingStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_codingStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "languages":
				return ec.fieldContext_CodingStats_languages(ctx, field)
			case "totalSeconds":
				return ec.fieldContext_CodingStats_totalSeconds(ctx, field)
			case "totalDuration":
				return ec.fieldContext_CodingStats_totalDuration(ctx, field)
			case "totalDurationShort":
				return ec.fieldContext_CodingStats_totalDurationShort(ctx, field)
			case "calculatedDays":
				return ec.fieldContext_CodingStats_calculatedDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CodingStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubStats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.GithubStats)
	fc.Result = res
	return ec.marshalNGithubStats2githubcomlrstanleyliamshinternalmodelsGithubStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitsYear":
				return ec.fieldContext_GithubStats_commitsYear(ctx, field)
			case "pullRequests":
				return ec.fieldContext_GithubStats_pullRequests(ctx, field)
			case "openIssues":
				return ec.fieldContext_GithubStats_openIssues(ctx, field)
			case "closedIssues":
				return ec.fieldContext_GithubStats_closedIssues(ctx, field)
			case "issues":
				return ec.fieldContext_GithubStats_issues(ctx, field)
			case "repos":
				return ec.fieldContext_GithubStats_repos(ctx, field)
			case "contributedRepos":
				return ec.fieldContext_GithubStats_contributedRepos(ctx, field)
			case "stars":
				return ec.fieldContext_GithubStats_stars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_self(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_self(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Self(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomlrstanleyliamshinternalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_self(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_User_userID(ctx, field)
			case "login":
				return ec.fieldContext_User_login(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "htmlURL":
				return ec.fieldContext_User_htmlURL(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "posts":
				return ec.fieldContext_User_posts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*clix.NonSensitiveVersion)
	fc.Result = res
	return ec.marshalNVersionInfo2githubcomlrstanleyclixNonSensitiveVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VersionInfo_name(ctx, field)
			case "version":
				return ec.fieldContext_VersionInfo_version(ctx, field)
			case "commit":
				return ec.fieldContext_VersionInfo_commit(ctx, field)
			case "date":
				return ec.fieldContext_VersionInfo_date(ctx, field)
			case "command":
				return ec.fieldContext_VersionInfo_command(ctx, field)
			case "goVersion":
				return ec.fieldContext_VersionInfo_goVersion(ctx, field)
			case "os":
				return ec.fieldContext_VersionInfo_os(ctx, field)
			case "arch":
				return ec.fieldContext_VersionInfo_arch(ctx, field)
			case "links":
				return ec.fieldContext_VersionInfo_links(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Timestamp_Time(ctx context.Context, field graphql.CollectedField, obj *github.Timestamp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Timestamp_Time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Timestamp_Time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Timestamp",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userID(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_login(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Login, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarURL(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_htmlURL(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_htmlURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_htmlURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_location(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_bio(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_bio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_posts(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.PostOrder), fc.Args["where"].(*ent.PostWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.PostConnection)
	fc.Result = res
	return ec.marshalNPostConnection2githubcomlrstanleyliamshinternalentPostConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PostConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PostConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PostConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.UserEdge)
	fc.Result = res
	return ec.marshalOUserEdge2githubcomlrstanleyliamshinternalentUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomlrstanleyliamshinternalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createTime":
				return ec.fieldContext_User_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_User_updateTime(ctx, field)
			case "userID":
				return ec.fieldContext_User_userID(ctx, field)
			case "login":
				return ec.fieldContext_User_login(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarURL":
				return ec.fieldContext_User_avatarURL(ctx, field)
			case "htmlURL":
				return ec.fieldContext_User_htmlURL(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "posts":
				return ec.fieldContext_User_posts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_name(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_version(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_commit(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_commit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_commit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_date(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_command(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_goVersion(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_goVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_goVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_os(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_os(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_arch(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_arch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionInfo_links(ctx context.Context, field graphql.CollectedField, obj *clix.NonSensitiveVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionInfo_links(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Links, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]clix.Link)
	fc.Result = res
	return ec.marshalOLink2githubcomlrstanleyclixLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionInfo_links(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Link_name(ctx, field)
			case "url":
				return ec.fieldContext_Link_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Link", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateLabelInput(ctx context.Context, obj interface{}) (ent.CreateLabelInput, error) {
	var it ent.CreateLabelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createTime", "updateTime", "name", "postIDs", "githubRepositoryIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			it.CreateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "postIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postIDs"))
			it.PostIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubRepositoryIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubRepositoryIDs"))
			it.GithubRepositoryIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePostInput(ctx context.Context, obj interface{}) (ent.CreatePostInput, error) {
	var it ent.CreatePostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createTime", "updateTime", "slug", "title", "content", "publishedAt", "public", "labelIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			it.CreateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "slug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			it.Slug, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			it.Title, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			it.Content, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAt"))
			it.PublishedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelIDs"))
			it.LabelIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAssetOrder(ctx context.Context, obj interface{}) (ent.GithubAssetOrder, error) {
	var it ent.GithubAssetOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubAssetOrderField2githubcomlrstanleyliamshinternalentGithubAssetOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAssetWhereInput(ctx context.Context, obj interface{}) (ent.GithubAssetWhereInput, error) {
	var it ent.GithubAssetWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "assetID", "assetIDNEQ", "assetIDIn", "assetIDNotIn", "assetIDGT", "assetIDGTE", "assetIDLT", "assetIDLTE", "browserDownloadURL", "browserDownloadURLNEQ", "browserDownloadURLIn", "browserDownloadURLNotIn", "browserDownloadURLGT", "browserDownloadURLGTE", "browserDownloadURLLT", "browserDownloadURLLTE", "browserDownloadURLContains", "browserDownloadURLHasPrefix", "browserDownloadURLHasSuffix", "browserDownloadURLEqualFold", "browserDownloadURLContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "label", "labelNEQ", "labelIn", "labelNotIn", "labelGT", "labelGTE", "labelLT", "labelLTE", "labelContains", "labelHasPrefix", "labelHasSuffix", "labelIsNil", "labelNotNil", "labelEqualFold", "labelContainsFold", "state", "stateNEQ", "stateIn", "stateNotIn", "stateGT", "stateGTE", "stateLT", "stateLTE", "stateContains", "stateHasPrefix", "stateHasSuffix", "stateIsNil", "stateNotNil", "stateEqualFold", "stateContainsFold", "contentType", "contentTypeNEQ", "contentTypeIn", "contentTypeNotIn", "contentTypeGT", "contentTypeGTE", "contentTypeLT", "contentTypeLTE", "contentTypeContains", "contentTypeHasPrefix", "contentTypeHasSuffix", "contentTypeEqualFold", "contentTypeContainsFold", "size", "sizeNEQ", "sizeIn", "sizeNotIn", "sizeGT", "sizeGTE", "sizeLT", "sizeLTE", "downloadCount", "downloadCountNEQ", "downloadCountIn", "downloadCountNotIn", "downloadCountGT", "downloadCountGTE", "downloadCountLT", "downloadCountLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "updatedAtIsNil", "updatedAtNotNil", "hasRelease", "hasReleaseWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetID"))
			it.AssetID, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDNEQ"))
			it.AssetIDNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDIn"))
			it.AssetIDIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDNotIn"))
			it.AssetIDNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDGT"))
			it.AssetIDGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDGTE"))
			it.AssetIDGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDLT"))
			it.AssetIDLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "assetIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIDLTE"))
			it.AssetIDLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURL"))
			it.BrowserDownloadURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLNEQ"))
			it.BrowserDownloadURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLIn"))
			it.BrowserDownloadURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLNotIn"))
			it.BrowserDownloadURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLGT"))
			it.BrowserDownloadURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLGTE"))
			it.BrowserDownloadURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLLT"))
			it.BrowserDownloadURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLLTE"))
			it.BrowserDownloadURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLContains"))
			it.BrowserDownloadURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLHasPrefix"))
			it.BrowserDownloadURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLHasSuffix"))
			it.BrowserDownloadURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLEqualFold"))
			it.BrowserDownloadURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "browserDownloadURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("browserDownloadURLContainsFold"))
			it.BrowserDownloadURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "label":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			it.Label, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelNEQ"))
			it.LabelNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelIn"))
			it.LabelIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelNotIn"))
			it.LabelNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelGT"))
			it.LabelGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelGTE"))
			it.LabelGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelLT"))
			it.LabelLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelLTE"))
			it.LabelLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelContains"))
			it.LabelContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelHasPrefix"))
			it.LabelHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelHasSuffix"))
			it.LabelHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelIsNil"))
			it.LabelIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelNotNil"))
			it.LabelNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelEqualFold"))
			it.LabelEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "labelContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelContainsFold"))
			it.LabelContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			it.State, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateNEQ"))
			it.StateNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateIn"))
			it.StateIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateNotIn"))
			it.StateNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateGT"))
			it.StateGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateGTE"))
			it.StateGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateLT"))
			it.StateLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateLTE"))
			it.StateLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateContains"))
			it.StateContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateHasPrefix"))
			it.StateHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateHasSuffix"))
			it.StateHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateIsNil"))
			it.StateIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateNotNil"))
			it.StateNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateEqualFold"))
			it.StateEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateContainsFold"))
			it.StateContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentType"))
			it.ContentType, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeNEQ"))
			it.ContentTypeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeIn"))
			it.ContentTypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeNotIn"))
			it.ContentTypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeGT"))
			it.ContentTypeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeGTE"))
			it.ContentTypeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeLT"))
			it.ContentTypeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeLTE"))
			it.ContentTypeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeContains"))
			it.ContentTypeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeHasPrefix"))
			it.ContentTypeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeHasSuffix"))
			it.ContentTypeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeEqualFold"))
			it.ContentTypeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentTypeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeContainsFold"))
			it.ContentTypeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			it.Size, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNEQ"))
			it.SizeNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeIn"))
			it.SizeIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNotIn"))
			it.SizeNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGT"))
			it.SizeGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGTE"))
			it.SizeGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLT"))
			it.SizeLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLTE"))
			it.SizeLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCount"))
			it.DownloadCount, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountNEQ"))
			it.DownloadCountNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountIn"))
			it.DownloadCountIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountNotIn"))
			it.DownloadCountNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountGT"))
			it.DownloadCountGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountGTE"))
			it.DownloadCountGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountLT"))
			it.DownloadCountLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "downloadCountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadCountLTE"))
			it.DownloadCountLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIsNil"))
			it.UpdatedAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotNil"))
			it.UpdatedAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRelease":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRelease"))
			it.HasRelease, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasReleaseWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasReleaseWith"))
			it.HasReleaseWith, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubEventOrder(ctx context.Context, obj interface{}) (ent.GithubEventOrder, error) {
	var it ent.GithubEventOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubEventOrderField2githubcomlrstanleyliamshinternalentGithubEventOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubEventWhereInput(ctx context.Context, obj interface{}) (ent.GithubEventWhereInput, error) {
	var it ent.GithubEventWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "eventID", "eventIDNEQ", "eventIDIn", "eventIDNotIn", "eventIDGT", "eventIDGTE", "eventIDLT", "eventIDLTE", "eventIDContains", "eventIDHasPrefix", "eventIDHasSuffix", "eventIDEqualFold", "eventIDContainsFold", "eventType", "eventTypeNEQ", "eventTypeIn", "eventTypeNotIn", "eventTypeGT", "eventTypeGTE", "eventTypeLT", "eventTypeLTE", "eventTypeContains", "eventTypeHasPrefix", "eventTypeHasSuffix", "eventTypeEqualFold", "eventTypeContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "public", "publicNEQ", "actorID", "actorIDNEQ", "actorIDIn", "actorIDNotIn", "actorIDGT", "actorIDGTE", "actorIDLT", "actorIDLTE", "repoID", "repoIDNEQ", "repoIDIn", "repoIDNotIn", "repoIDGT", "repoIDGTE", "repoIDLT", "repoIDLTE"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventID"))
			it.EventID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDNEQ"))
			it.EventIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDIn"))
			it.EventIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDNotIn"))
			it.EventIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDGT"))
			it.EventIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDGTE"))
			it.EventIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDLT"))
			it.EventIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDLTE"))
			it.EventIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDContains"))
			it.EventIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDHasPrefix"))
			it.EventIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDHasSuffix"))
			it.EventIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDEqualFold"))
			it.EventIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIDContainsFold"))
			it.EventIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
			it.EventType, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeNEQ"))
			it.EventTypeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeIn"))
			it.EventTypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeNotIn"))
			it.EventTypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeGT"))
			it.EventTypeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeGTE"))
			it.EventTypeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeLT"))
			it.EventTypeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeLTE"))
			it.EventTypeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeContains"))
			it.EventTypeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeHasPrefix"))
			it.EventTypeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeHasSuffix"))
			it.EventTypeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeEqualFold"))
			it.EventTypeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventTypeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypeContainsFold"))
			it.EventTypeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNEQ"))
			it.PublicNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorID"))
			it.ActorID, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDNEQ"))
			it.ActorIDNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDIn"))
			it.ActorIDIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDNotIn"))
			it.ActorIDNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDGT"))
			it.ActorIDGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDGTE"))
			it.ActorIDGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDLT"))
			it.ActorIDLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "actorIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("actorIDLTE"))
			it.ActorIDLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoID"))
			it.RepoID, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDNEQ"))
			it.RepoIDNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDIn"))
			it.RepoIDIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDNotIn"))
			it.RepoIDNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDGT"))
			it.RepoIDGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDGTE"))
			it.RepoIDGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDLT"))
			it.RepoIDLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDLTE"))
			it.RepoIDLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubGistOrder(ctx context.Context, obj interface{}) (ent.GithubGistOrder, error) {
	var it ent.GithubGistOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubGistOrderField2githubcomlrstanleyliamshinternalentGithubGistOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubGistWhereInput(ctx context.Context, obj interface{}) (ent.GithubGistWhereInput, error) {
	var it ent.GithubGistWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "gistID", "gistIDNEQ", "gistIDIn", "gistIDNotIn", "gistIDGT", "gistIDGTE", "gistIDLT", "gistIDLTE", "gistIDContains", "gistIDHasPrefix", "gistIDHasSuffix", "gistIDEqualFold", "gistIDContainsFold", "htmlURL", "htmlURLNEQ", "htmlURLIn", "htmlURLNotIn", "htmlURLGT", "htmlURLGTE", "htmlURLLT", "htmlURLLTE", "htmlURLContains", "htmlURLHasPrefix", "htmlURLHasSuffix", "htmlURLEqualFold", "htmlURLContainsFold", "public", "publicNEQ", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "typeGT", "typeGTE", "typeLT", "typeLTE", "typeContains", "typeHasPrefix", "typeHasSuffix", "typeEqualFold", "typeContainsFold", "language", "languageNEQ", "languageIn", "languageNotIn", "languageGT", "languageGTE", "languageLT", "languageLTE", "languageContains", "languageHasPrefix", "languageHasSuffix", "languageIsNil", "languageNotNil", "languageEqualFold", "languageContainsFold", "size", "sizeNEQ", "sizeIn", "sizeNotIn", "sizeGT", "sizeGTE", "sizeLT", "sizeLTE", "rawURL", "rawURLNEQ", "rawURLIn", "rawURLNotIn", "rawURLGT", "rawURLGTE", "rawURLLT", "rawURLLTE", "rawURLContains", "rawURLHasPrefix", "rawURLHasSuffix", "rawURLEqualFold", "rawURLContainsFold", "content", "contentNEQ", "contentIn", "contentNotIn", "contentGT", "contentGTE", "contentLT", "contentLTE", "contentContains", "contentHasPrefix", "contentHasSuffix", "contentEqualFold", "contentContainsFold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistID"))
			it.GistID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDNEQ"))
			it.GistIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDIn"))
			it.GistIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDNotIn"))
			it.GistIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDGT"))
			it.GistIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDGTE"))
			it.GistIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDLT"))
			it.GistIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDLTE"))
			it.GistIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDContains"))
			it.GistIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDHasPrefix"))
			it.GistIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDHasSuffix"))
			it.GistIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDEqualFold"))
			it.GistIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gistIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gistIDContainsFold"))
			it.GistIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURL"))
			it.HTMLURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNEQ"))
			it.HTMLURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLIn"))
			it.HTMLURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNotIn"))
			it.HTMLURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGT"))
			it.HTMLURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGTE"))
			it.HTMLURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLT"))
			it.HTMLURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLTE"))
			it.HTMLURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContains"))
			it.HTMLURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasPrefix"))
			it.HTMLURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasSuffix"))
			it.HTMLURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLEqualFold"))
			it.HTMLURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContainsFold"))
			it.HTMLURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNEQ"))
			it.PublicNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			it.DescriptionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			it.DescriptionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGT"))
			it.TypeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGTE"))
			it.TypeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLT"))
			it.TypeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLTE"))
			it.TypeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContains"))
			it.TypeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasPrefix"))
			it.TypeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasSuffix"))
			it.TypeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeEqualFold"))
			it.TypeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContainsFold"))
			it.TypeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "language":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("language"))
			it.Language, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageNEQ"))
			it.LanguageNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageIn"))
			it.LanguageIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageNotIn"))
			it.LanguageNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageGT"))
			it.LanguageGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageGTE"))
			it.LanguageGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageLT"))
			it.LanguageLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageLTE"))
			it.LanguageLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageContains"))
			it.LanguageContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageHasPrefix"))
			it.LanguageHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageHasSuffix"))
			it.LanguageHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageIsNil"))
			it.LanguageIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageNotNil"))
			it.LanguageNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageEqualFold"))
			it.LanguageEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "languageContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageContainsFold"))
			it.LanguageContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			it.Size, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNEQ"))
			it.SizeNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeIn"))
			it.SizeIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNotIn"))
			it.SizeNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGT"))
			it.SizeGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGTE"))
			it.SizeGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLT"))
			it.SizeLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "sizeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLTE"))
			it.SizeLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURL"))
			it.RawURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLNEQ"))
			it.RawURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLIn"))
			it.RawURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLNotIn"))
			it.RawURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLGT"))
			it.RawURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLGTE"))
			it.RawURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLLT"))
			it.RawURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLLTE"))
			it.RawURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLContains"))
			it.RawURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLHasPrefix"))
			it.RawURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLHasSuffix"))
			it.RawURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLEqualFold"))
			it.RawURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawURLContainsFold"))
			it.RawURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			it.Content, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentNEQ"))
			it.ContentNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIn"))
			it.ContentIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentNotIn"))
			it.ContentNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentGT"))
			it.ContentGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentGTE"))
			it.ContentGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentLT"))
			it.ContentLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentLTE"))
			it.ContentLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentContains"))
			it.ContentContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHasPrefix"))
			it.ContentHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHasSuffix"))
			it.ContentHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentEqualFold"))
			it.ContentEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentContainsFold"))
			it.ContentContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubReleaseOrder(ctx context.Context, obj interface{}) (ent.GithubReleaseOrder, error) {
	var it ent.GithubReleaseOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubReleaseOrderField2githubcomlrstanleyliamshinternalentGithubReleaseOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubReleaseWhereInput(ctx context.Context, obj interface{}) (ent.GithubReleaseWhereInput, error) {
	var it ent.GithubReleaseWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "releaseID", "releaseIDNEQ", "releaseIDIn", "releaseIDNotIn", "releaseIDGT", "releaseIDGTE", "releaseIDLT", "releaseIDLTE", "htmlURL", "htmlURLNEQ", "htmlURLIn", "htmlURLNotIn", "htmlURLGT", "htmlURLGTE", "htmlURLLT", "htmlURLLTE", "htmlURLContains", "htmlURLHasPrefix", "htmlURLHasSuffix", "htmlURLEqualFold", "htmlURLContainsFold", "tagName", "tagNameNEQ", "tagNameIn", "tagNameNotIn", "tagNameGT", "tagNameGTE", "tagNameLT", "tagNameLTE", "tagNameContains", "tagNameHasPrefix", "tagNameHasSuffix", "tagNameEqualFold", "tagNameContainsFold", "targetCommitish", "targetCommitishNEQ", "targetCommitishIn", "targetCommitishNotIn", "targetCommitishGT", "targetCommitishGTE", "targetCommitishLT", "targetCommitishLTE", "targetCommitishContains", "targetCommitishHasPrefix", "targetCommitishHasSuffix", "targetCommitishEqualFold", "targetCommitishContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameIsNil", "nameNotNil", "nameEqualFold", "nameContainsFold", "draft", "draftNEQ", "prerelease", "prereleaseNEQ", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "publishedAt", "publishedAtNEQ", "publishedAtIn", "publishedAtNotIn", "publishedAtGT", "publishedAtGTE", "publishedAtLT", "publishedAtLTE", "hasRepository", "hasRepositoryWith", "hasAssets", "hasAssetsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseID"))
			it.ReleaseID, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDNEQ"))
			it.ReleaseIDNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDIn"))
			it.ReleaseIDIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDNotIn"))
			it.ReleaseIDNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDGT"))
			it.ReleaseIDGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDGTE"))
			it.ReleaseIDGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDLT"))
			it.ReleaseIDLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "releaseIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseIDLTE"))
			it.ReleaseIDLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURL"))
			it.HTMLURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNEQ"))
			it.HTMLURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLIn"))
			it.HTMLURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNotIn"))
			it.HTMLURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGT"))
			it.HTMLURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGTE"))
			it.HTMLURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLT"))
			it.HTMLURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLTE"))
			it.HTMLURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContains"))
			it.HTMLURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasPrefix"))
			it.HTMLURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasSuffix"))
			it.HTMLURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLEqualFold"))
			it.HTMLURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContainsFold"))
			it.HTMLURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagName"))
			it.TagName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameNEQ"))
			it.TagNameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameIn"))
			it.TagNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameNotIn"))
			it.TagNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameGT"))
			it.TagNameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameGTE"))
			it.TagNameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameLT"))
			it.TagNameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameLTE"))
			it.TagNameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameContains"))
			it.TagNameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameHasPrefix"))
			it.TagNameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameHasSuffix"))
			it.TagNameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameEqualFold"))
			it.TagNameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNameContainsFold"))
			it.TagNameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitish":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitish"))
			it.TargetCommitish, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishNEQ"))
			it.TargetCommitishNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishIn"))
			it.TargetCommitishIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishNotIn"))
			it.TargetCommitishNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishGT"))
			it.TargetCommitishGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishGTE"))
			it.TargetCommitishGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishLT"))
			it.TargetCommitishLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishLTE"))
			it.TargetCommitishLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishContains"))
			it.TargetCommitishContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishHasPrefix"))
			it.TargetCommitishHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishHasSuffix"))
			it.TargetCommitishHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishEqualFold"))
			it.TargetCommitishEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetCommitishContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetCommitishContainsFold"))
			it.TargetCommitishContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			it.NameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			it.NameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "draft":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("draft"))
			it.Draft, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "draftNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("draftNEQ"))
			it.DraftNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "prerelease":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prerelease"))
			it.Prerelease, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "prereleaseNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prereleaseNEQ"))
			it.PrereleaseNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAt"))
			it.PublishedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtNEQ"))
			it.PublishedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtIn"))
			it.PublishedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtNotIn"))
			it.PublishedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtGT"))
			it.PublishedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtGTE"))
			it.PublishedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtLT"))
			it.PublishedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtLTE"))
			it.PublishedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepository"))
			it.HasRepository, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRepositoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRepositoryWith"))
			it.HasRepositoryWith, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAssets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAssets"))
			it.HasAssets, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAssetsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAssetsWith"))
			it.HasAssetsWith, err = ec.unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubRepositoryOrder(ctx context.Context, obj interface{}) (ent.GithubRepositoryOrder, error) {
	var it ent.GithubRepositoryOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNGithubRepositoryOrderField2githubcomlrstanleyliamshinternalentGithubRepositoryOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubRepositoryWhereInput(ctx context.Context, obj interface{}) (ent.GithubRepositoryWhereInput, error) {
	var it ent.GithubRepositoryWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "repoID", "repoIDNEQ", "repoIDIn", "repoIDNotIn", "repoIDGT", "repoIDGTE", "repoIDLT", "repoIDLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "fullName", "fullNameNEQ", "fullNameIn", "fullNameNotIn", "fullNameGT", "fullNameGTE", "fullNameLT", "fullNameLTE", "fullNameContains", "fullNameHasPrefix", "fullNameHasSuffix", "fullNameEqualFold", "fullNameContainsFold", "ownerLogin", "ownerLoginNEQ", "ownerLoginIn", "ownerLoginNotIn", "ownerLoginGT", "ownerLoginGTE", "ownerLoginLT", "ownerLoginLTE", "ownerLoginContains", "ownerLoginHasPrefix", "ownerLoginHasSuffix", "ownerLoginEqualFold", "ownerLoginContainsFold", "public", "publicNEQ", "htmlURL", "htmlURLNEQ", "htmlURLIn", "htmlURLNotIn", "htmlURLGT", "htmlURLGTE", "htmlURLLT", "htmlURLLTE", "htmlURLContains", "htmlURLHasPrefix", "htmlURLHasSuffix", "htmlURLEqualFold", "htmlURLContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "fork", "forkNEQ", "homepage", "homepageNEQ", "homepageIn", "homepageNotIn", "homepageGT", "homepageGTE", "homepageLT", "homepageLTE", "homepageContains", "homepageHasPrefix", "homepageHasSuffix", "homepageIsNil", "homepageNotNil", "homepageEqualFold", "homepageContainsFold", "starCount", "starCountNEQ", "starCountIn", "starCountNotIn", "starCountGT", "starCountGTE", "starCountLT", "starCountLTE", "defaultBranch", "defaultBranchNEQ", "defaultBranchIn", "defaultBranchNotIn", "defaultBranchGT", "defaultBranchGTE", "defaultBranchLT", "defaultBranchLTE", "defaultBranchContains", "defaultBranchHasPrefix", "defaultBranchHasSuffix", "defaultBranchEqualFold", "defaultBranchContainsFold", "isTemplate", "isTemplateNEQ", "hasIssues", "hasIssuesNEQ", "archived", "archivedNEQ", "pushedAt", "pushedAtNEQ", "pushedAtIn", "pushedAtNotIn", "pushedAtGT", "pushedAtGTE", "pushedAtLT", "pushedAtLTE", "pushedAtIsNil", "pushedAtNotNil", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "updatedAtIsNil", "updatedAtNotNil", "hasLabels", "hasLabelsWith", "hasReleases", "hasReleasesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoID"))
			it.RepoID, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDNEQ"))
			it.RepoIDNEQ, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDIn"))
			it.RepoIDIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDNotIn"))
			it.RepoIDNotIn, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDGT"))
			it.RepoIDGT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDGTE"))
			it.RepoIDGTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDLT"))
			it.RepoIDLT, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoIDLTE"))
			it.RepoIDLTE, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullName"))
			it.FullName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNEQ"))
			it.FullNameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameIn"))
			it.FullNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNotIn"))
			it.FullNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGT"))
			it.FullNameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGTE"))
			it.FullNameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLT"))
			it.FullNameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLTE"))
			it.FullNameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContains"))
			it.FullNameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasPrefix"))
			it.FullNameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasSuffix"))
			it.FullNameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameEqualFold"))
			it.FullNameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContainsFold"))
			it.FullNameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLogin":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLogin"))
			it.OwnerLogin, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginNEQ"))
			it.OwnerLoginNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginIn"))
			it.OwnerLoginIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginNotIn"))
			it.OwnerLoginNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginGT"))
			it.OwnerLoginGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginGTE"))
			it.OwnerLoginGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginLT"))
			it.OwnerLoginLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginLTE"))
			it.OwnerLoginLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginContains"))
			it.OwnerLoginContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginHasPrefix"))
			it.OwnerLoginHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginHasSuffix"))
			it.OwnerLoginHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginEqualFold"))
			it.OwnerLoginEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerLoginContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerLoginContainsFold"))
			it.OwnerLoginContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNEQ"))
			it.PublicNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURL"))
			it.HTMLURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNEQ"))
			it.HTMLURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLIn"))
			it.HTMLURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNotIn"))
			it.HTMLURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGT"))
			it.HTMLURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGTE"))
			it.HTMLURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLT"))
			it.HTMLURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLTE"))
			it.HTMLURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContains"))
			it.HTMLURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasPrefix"))
			it.HTMLURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasSuffix"))
			it.HTMLURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLEqualFold"))
			it.HTMLURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContainsFold"))
			it.HTMLURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			it.DescriptionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			it.DescriptionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fork":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fork"))
			it.Fork, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "forkNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forkNEQ"))
			it.ForkNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepage"))
			it.Homepage, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageNEQ"))
			it.HomepageNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageIn"))
			it.HomepageIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageNotIn"))
			it.HomepageNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageGT"))
			it.HomepageGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageGTE"))
			it.HomepageGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageLT"))
			it.HomepageLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageLTE"))
			it.HomepageLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageContains"))
			it.HomepageContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageHasPrefix"))
			it.HomepageHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageHasSuffix"))
			it.HomepageHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageIsNil"))
			it.HomepageIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageNotNil"))
			it.HomepageNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageEqualFold"))
			it.HomepageEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homepageContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homepageContainsFold"))
			it.HomepageContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCount"))
			it.StarCount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountNEQ"))
			it.StarCountNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountIn"))
			it.StarCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountNotIn"))
			it.StarCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountGT"))
			it.StarCountGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountGTE"))
			it.StarCountGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountLT"))
			it.StarCountLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "starCountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("starCountLTE"))
			it.StarCountLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranch"))
			it.DefaultBranch, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchNEQ"))
			it.DefaultBranchNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchIn"))
			it.DefaultBranchIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchNotIn"))
			it.DefaultBranchNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchGT"))
			it.DefaultBranchGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchGTE"))
			it.DefaultBranchGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchLT"))
			it.DefaultBranchLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchLTE"))
			it.DefaultBranchLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchContains"))
			it.DefaultBranchContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchHasPrefix"))
			it.DefaultBranchHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchHasSuffix"))
			it.DefaultBranchHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchEqualFold"))
			it.DefaultBranchEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "defaultBranchContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultBranchContainsFold"))
			it.DefaultBranchContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isTemplate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isTemplate"))
			it.IsTemplate, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isTemplateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isTemplateNEQ"))
			it.IsTemplateNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIssues":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIssues"))
			it.HasIssues, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasIssuesNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIssuesNEQ"))
			it.HasIssuesNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "archived":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("archived"))
			it.Archived, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "archivedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("archivedNEQ"))
			it.ArchivedNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAt"))
			it.PushedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtNEQ"))
			it.PushedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtIn"))
			it.PushedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtNotIn"))
			it.PushedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtGT"))
			it.PushedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtGTE"))
			it.PushedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtLT"))
			it.PushedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtLTE"))
			it.PushedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtIsNil"))
			it.PushedAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushedAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushedAtNotNil"))
			it.PushedAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIsNil"))
			it.UpdatedAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotNil"))
			it.UpdatedAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLabels"))
			it.HasLabels, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLabelsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLabelsWith"))
			it.HasLabelsWith, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasReleases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasReleases"))
			it.HasReleases, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasReleasesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasReleasesWith"))
			it.HasReleasesWith, err = ec.unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelOrder(ctx context.Context, obj interface{}) (ent.LabelOrder, error) {
	var it ent.LabelOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNLabelOrderField2githubcomlrstanleyliamshinternalentLabelOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelWhereInput(ctx context.Context, obj interface{}) (ent.LabelWhereInput, error) {
	var it ent.LabelWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasPosts", "hasPostsWith", "hasGithubRepositories", "hasGithubRepositoriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			it.CreateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			it.CreateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			it.CreateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			it.CreateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			it.CreateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			it.CreateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			it.CreateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			it.CreateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			it.UpdateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			it.UpdateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			it.UpdateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			it.UpdateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			it.UpdateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			it.UpdateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			it.UpdateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPosts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPosts"))
			it.HasPosts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPostsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPostsWith"))
			it.HasPostsWith, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubRepositories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubRepositories"))
			it.HasGithubRepositories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGithubRepositoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGithubRepositoriesWith"))
			it.HasGithubRepositoriesWith, err = ec.unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPostOrder(ctx context.Context, obj interface{}) (ent.PostOrder, error) {
	var it ent.PostOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNPostOrderField2githubcomlrstanleyliamshinternalentPostOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPostWhereInput(ctx context.Context, obj interface{}) (ent.PostWhereInput, error) {
	var it ent.PostWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "slug", "slugNEQ", "slugIn", "slugNotIn", "slugGT", "slugGTE", "slugLT", "slugLTE", "slugContains", "slugHasPrefix", "slugHasSuffix", "slugEqualFold", "slugContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "content", "contentNEQ", "contentIn", "contentNotIn", "contentGT", "contentGTE", "contentLT", "contentLTE", "contentContains", "contentHasPrefix", "contentHasSuffix", "contentEqualFold", "contentContainsFold", "contentHTML", "contentHTMLNEQ", "contentHTMLIn", "contentHTMLNotIn", "contentHTMLGT", "contentHTMLGTE", "contentHTMLLT", "contentHTMLLTE", "contentHTMLContains", "contentHTMLHasPrefix", "contentHTMLHasSuffix", "contentHTMLEqualFold", "contentHTMLContainsFold", "summary", "summaryNEQ", "summaryIn", "summaryNotIn", "summaryGT", "summaryGTE", "summaryLT", "summaryLTE", "summaryContains", "summaryHasPrefix", "summaryHasSuffix", "summaryEqualFold", "summaryContainsFold", "publishedAt", "publishedAtNEQ", "publishedAtIn", "publishedAtNotIn", "publishedAtGT", "publishedAtGTE", "publishedAtLT", "publishedAtLTE", "viewCount", "viewCountNEQ", "viewCountIn", "viewCountNotIn", "viewCountGT", "viewCountGTE", "viewCountLT", "viewCountLTE", "public", "publicNEQ", "hasAuthor", "hasAuthorWith", "hasLabels", "hasLabelsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			it.CreateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			it.CreateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			it.CreateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			it.CreateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			it.CreateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			it.CreateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			it.CreateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			it.CreateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			it.UpdateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			it.UpdateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			it.UpdateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			it.UpdateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			it.UpdateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			it.UpdateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			it.UpdateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "slug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			it.Slug, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugNEQ"))
			it.SlugNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugIn"))
			it.SlugIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugNotIn"))
			it.SlugNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugGT"))
			it.SlugGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugGTE"))
			it.SlugGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugLT"))
			it.SlugLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugLTE"))
			it.SlugLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugContains"))
			it.SlugContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugHasPrefix"))
			it.SlugHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugHasSuffix"))
			it.SlugHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugEqualFold"))
			it.SlugEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "slugContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slugContainsFold"))
			it.SlugContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			it.Title, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			it.TitleNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			it.TitleIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			it.TitleNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			it.TitleGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			it.TitleGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			it.TitleLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			it.TitleLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			it.TitleContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			it.TitleHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			it.TitleHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			it.TitleEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "titleContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			it.TitleContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			it.Content, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentNEQ"))
			it.ContentNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIn"))
			it.ContentIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentNotIn"))
			it.ContentNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentGT"))
			it.ContentGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentGTE"))
			it.ContentGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentLT"))
			it.ContentLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentLTE"))
			it.ContentLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentContains"))
			it.ContentContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHasPrefix"))
			it.ContentHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHasSuffix"))
			it.ContentHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentEqualFold"))
			it.ContentEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentContainsFold"))
			it.ContentContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTML":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTML"))
			it.ContentHTML, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLNEQ"))
			it.ContentHTMLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLIn"))
			it.ContentHTMLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLNotIn"))
			it.ContentHTMLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLGT"))
			it.ContentHTMLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLGTE"))
			it.ContentHTMLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLLT"))
			it.ContentHTMLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLLTE"))
			it.ContentHTMLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLContains"))
			it.ContentHTMLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLHasPrefix"))
			it.ContentHTMLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLHasSuffix"))
			it.ContentHTMLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLEqualFold"))
			it.ContentHTMLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentHTMLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentHTMLContainsFold"))
			it.ContentHTMLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summary"))
			it.Summary, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryNEQ"))
			it.SummaryNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryIn"))
			it.SummaryIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryNotIn"))
			it.SummaryNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryGT"))
			it.SummaryGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryGTE"))
			it.SummaryGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryLT"))
			it.SummaryLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryLTE"))
			it.SummaryLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryContains"))
			it.SummaryContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryHasPrefix"))
			it.SummaryHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryHasSuffix"))
			it.SummaryHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryEqualFold"))
			it.SummaryEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "summaryContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("summaryContainsFold"))
			it.SummaryContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAt"))
			it.PublishedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtNEQ"))
			it.PublishedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtIn"))
			it.PublishedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtNotIn"))
			it.PublishedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtGT"))
			it.PublishedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtGTE"))
			it.PublishedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtLT"))
			it.PublishedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAtLTE"))
			it.PublishedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCount"))
			it.ViewCount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountNEQ"))
			it.ViewCountNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountIn"))
			it.ViewCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountNotIn"))
			it.ViewCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountGT"))
			it.ViewCountGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountGTE"))
			it.ViewCountGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountLT"))
			it.ViewCountLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "viewCountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewCountLTE"))
			it.ViewCountLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNEQ"))
			it.PublicNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAuthor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAuthor"))
			it.HasAuthor, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAuthorWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAuthorWith"))
			it.HasAuthorWith, err = ec.unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLabels"))
			it.HasLabels, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLabelsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLabelsWith"))
			it.HasLabelsWith, err = ec.unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLabelInput(ctx context.Context, obj interface{}) (ent.UpdateLabelInput, error) {
	var it ent.UpdateLabelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updateTime", "name", "addPostIDs", "removePostIDs", "addGithubRepositoryIDs", "removeGithubRepositoryIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "addPostIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPostIDs"))
			it.AddPostIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "removePostIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removePostIDs"))
			it.RemovePostIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "addGithubRepositoryIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addGithubRepositoryIDs"))
			it.AddGithubRepositoryIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeGithubRepositoryIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeGithubRepositoryIDs"))
			it.RemoveGithubRepositoryIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePostInput(ctx context.Context, obj interface{}) (ent.UpdatePostInput, error) {
	var it ent.UpdatePostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updateTime", "slug", "title", "content", "publishedAt", "public", "addLabelIDs", "removeLabelIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "slug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slug"))
			it.Slug, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			it.Title, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			it.Content, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publishedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedAt"))
			it.PublishedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "public":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			it.Public, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "addLabelIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addLabelIDs"))
			it.AddLabelIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeLabelIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeLabelIDs"))
			it.RemoveLabelIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (ent.UserOrder, error) {
	var it ent.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNUserOrderField2githubcomlrstanleyliamshinternalentUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "userIDGT", "userIDGTE", "userIDLT", "userIDLTE", "login", "loginNEQ", "loginIn", "loginNotIn", "loginGT", "loginGTE", "loginLT", "loginLTE", "loginContains", "loginHasPrefix", "loginHasSuffix", "loginEqualFold", "loginContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameIsNil", "nameNotNil", "nameEqualFold", "nameContainsFold", "avatarURL", "avatarURLNEQ", "avatarURLIn", "avatarURLNotIn", "avatarURLGT", "avatarURLGTE", "avatarURLLT", "avatarURLLTE", "avatarURLContains", "avatarURLHasPrefix", "avatarURLHasSuffix", "avatarURLIsNil", "avatarURLNotNil", "avatarURLEqualFold", "avatarURLContainsFold", "htmlURL", "htmlURLNEQ", "htmlURLIn", "htmlURLNotIn", "htmlURLGT", "htmlURLGTE", "htmlURLLT", "htmlURLLTE", "htmlURLContains", "htmlURLHasPrefix", "htmlURLHasSuffix", "htmlURLIsNil", "htmlURLNotNil", "htmlURLEqualFold", "htmlURLContainsFold", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailIsNil", "emailNotNil", "emailEqualFold", "emailContainsFold", "location", "locationNEQ", "locationIn", "locationNotIn", "locationGT", "locationGTE", "locationLT", "locationLTE", "locationContains", "locationHasPrefix", "locationHasSuffix", "locationIsNil", "locationNotNil", "locationEqualFold", "locationContainsFold", "bio", "bioNEQ", "bioIn", "bioNotIn", "bioGT", "bioGTE", "bioLT", "bioLTE", "bioContains", "bioHasPrefix", "bioHasSuffix", "bioIsNil", "bioNotNil", "bioEqualFold", "bioContainsFold", "hasPosts", "hasPostsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			it.CreateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			it.CreateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			it.CreateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			it.CreateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			it.CreateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			it.CreateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			it.CreateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			it.CreateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			it.UpdateTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			it.UpdateTimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			it.UpdateTimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			it.UpdateTimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			it.UpdateTimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			it.UpdateTimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			it.UpdateTimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updateTimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			it.UpdateTimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "userID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			it.UserID, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			it.UserIDNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			it.UserIDIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			it.UserIDNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGT"))
			it.UserIDGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGTE"))
			it.UserIDGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLT"))
			it.UserIDLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "userIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLTE"))
			it.UserIDLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "login":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("login"))
			it.Login, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginNEQ"))
			it.LoginNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginIn"))
			it.LoginIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginNotIn"))
			it.LoginNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginGT"))
			it.LoginGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginGTE"))
			it.LoginGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginLT"))
			it.LoginLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginLTE"))
			it.LoginLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginContains"))
			it.LoginContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginHasPrefix"))
			it.LoginHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginHasSuffix"))
			it.LoginHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginEqualFold"))
			it.LoginEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "loginContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginContainsFold"))
			it.LoginContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			it.NameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			it.NameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURL"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNEQ"))
			it.AvatarURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLIn"))
			it.AvatarURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNotIn"))
			it.AvatarURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLGT"))
			it.AvatarURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLGTE"))
			it.AvatarURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLLT"))
			it.AvatarURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLLTE"))
			it.AvatarURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLContains"))
			it.AvatarURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLHasPrefix"))
			it.AvatarURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLHasSuffix"))
			it.AvatarURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLIsNil"))
			it.AvatarURLIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLNotNil"))
			it.AvatarURLNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLEqualFold"))
			it.AvatarURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "avatarURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarURLContainsFold"))
			it.AvatarURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURL"))
			it.HTMLURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNEQ"))
			it.HTMLURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLIn"))
			it.HTMLURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNotIn"))
			it.HTMLURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGT"))
			it.HTMLURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLGTE"))
			it.HTMLURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLT"))
			it.HTMLURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLLTE"))
			it.HTMLURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContains"))
			it.HTMLURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasPrefix"))
			it.HTMLURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLHasSuffix"))
			it.HTMLURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLIsNil"))
			it.HTMLURLIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLNotNil"))
			it.HTMLURLNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLEqualFold"))
			it.HTMLURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "htmlURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("htmlURLContainsFold"))
			it.HTMLURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			it.EmailNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			it.EmailIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			it.EmailNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			it.EmailGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			it.EmailGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			it.EmailLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			it.EmailLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			it.EmailContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			it.EmailHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			it.EmailHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIsNil"))
			it.EmailIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotNil"))
			it.EmailNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			it.EmailEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			it.EmailContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "location":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			it.Location, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationNEQ"))
			it.LocationNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationIn"))
			it.LocationIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationNotIn"))
			it.LocationNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationGT"))
			it.LocationGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationGTE"))
			it.LocationGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLT"))
			it.LocationLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLTE"))
			it.LocationLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationContains"))
			it.LocationContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationHasPrefix"))
			it.LocationHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationHasSuffix"))
			it.LocationHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationIsNil"))
			it.LocationIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationNotNil"))
			it.LocationNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationEqualFold"))
			it.LocationEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationContainsFold"))
			it.LocationContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bio":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			it.Bio, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioNEQ"))
			it.BioNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioIn"))
			it.BioIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioNotIn"))
			it.BioNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioGT"))
			it.BioGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioGTE"))
			it.BioGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioLT"))
			it.BioLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioLTE"))
			it.BioLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioContains"))
			it.BioContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioHasPrefix"))
			it.BioHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioHasSuffix"))
			it.BioHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioIsNil"))
			it.BioIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioNotNil"))
			it.BioNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioEqualFold"))
			it.BioEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bioContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioContainsFold"))
			it.BioContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPosts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPosts"))
			it.HasPosts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPostsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPostsWith"))
			it.HasPostsWith, err = ec.unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.GithubAsset:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubAsset(ctx, sel, obj)
	case *ent.GithubEvent:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubEvent(ctx, sel, obj)
	case *ent.GithubGist:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubGist(ctx, sel, obj)
	case *ent.GithubRelease:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubRelease(ctx, sel, obj)
	case *ent.GithubRepository:
		if obj == nil {
			return graphql.Null
		}
		return ec._GithubRepository(ctx, sel, obj)
	case *ent.Label:
		if obj == nil {
			return graphql.Null
		}
		return ec._Label(ctx, sel, obj)
	case *ent.Post:
		if obj == nil {
			return graphql.Null
		}
		return ec._Post(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var codingStatsImplementors = []string{"CodingStats"}

func (ec *executionContext) _CodingStats(ctx context.Context, sel ast.SelectionSet, obj *models.CodingStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, codingStatsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CodingStats")
		case "languages":

			out.Values[i] = ec._CodingStats_languages(ctx, field, obj)

		case "totalSeconds":

			out.Values[i] = ec._CodingStats_totalSeconds(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalDuration":

			out.Values[i] = ec._CodingStats_totalDuration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalDurationShort":

			out.Values[i] = ec._CodingStats_totalDurationShort(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "calculatedDays":

			out.Values[i] = ec._CodingStats_calculatedDays(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAssetImplementors = []string{"GithubAsset", "Node"}

func (ec *executionContext) _GithubAsset(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAssetImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAsset")
		case "id":

			out.Values[i] = ec._GithubAsset_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "assetID":

			out.Values[i] = ec._GithubAsset_assetID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "browserDownloadURL":

			out.Values[i] = ec._GithubAsset_browserDownloadURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._GithubAsset_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "label":

			out.Values[i] = ec._GithubAsset_label(ctx, field, obj)

		case "state":

			out.Values[i] = ec._GithubAsset_state(ctx, field, obj)

		case "contentType":

			out.Values[i] = ec._GithubAsset_contentType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "size":

			out.Values[i] = ec._GithubAsset_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "downloadCount":

			out.Values[i] = ec._GithubAsset_downloadCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._GithubAsset_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._GithubAsset_updatedAt(ctx, field, obj)

		case "uploader":

			out.Values[i] = ec._GithubAsset_uploader(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "release":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubAsset_release(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAssetConnectionImplementors = []string{"GithubAssetConnection"}

func (ec *executionContext) _GithubAssetConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAssetConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAssetConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAssetConnection")
		case "edges":

			out.Values[i] = ec._GithubAssetConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubAssetConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubAssetConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubAssetEdgeImplementors = []string{"GithubAssetEdge"}

func (ec *executionContext) _GithubAssetEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubAssetEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAssetEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAssetEdge")
		case "node":

			out.Values[i] = ec._GithubAssetEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubAssetEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubEventImplementors = []string{"GithubEvent", "Node"}

func (ec *executionContext) _GithubEvent(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubEvent")
		case "id":

			out.Values[i] = ec._GithubEvent_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventID":

			out.Values[i] = ec._GithubEvent_eventID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":

			out.Values[i] = ec._GithubEvent_eventType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._GithubEvent_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "public":

			out.Values[i] = ec._GithubEvent_public(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "actorID":

			out.Values[i] = ec._GithubEvent_actorID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "actor":

			out.Values[i] = ec._GithubEvent_actor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoID":

			out.Values[i] = ec._GithubEvent_repoID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._GithubEvent_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "payload":

			out.Values[i] = ec._GithubEvent_payload(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubEventConnectionImplementors = []string{"GithubEventConnection"}

func (ec *executionContext) _GithubEventConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubEventConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubEventConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubEventConnection")
		case "edges":

			out.Values[i] = ec._GithubEventConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubEventConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubEventConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubEventEdgeImplementors = []string{"GithubEventEdge"}

func (ec *executionContext) _GithubEventEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubEventEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubEventEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubEventEdge")
		case "node":

			out.Values[i] = ec._GithubEventEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubEventEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubEventRepoImplementors = []string{"GithubEventRepo"}

func (ec *executionContext) _GithubEventRepo(ctx context.Context, sel ast.SelectionSet, obj *github.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubEventRepoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubEventRepo")
		case "id":

			out.Values[i] = ec._GithubEventRepo_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._GithubEventRepo_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._GithubEventRepo_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubGistImplementors = []string{"GithubGist", "Node"}

func (ec *executionContext) _GithubGist(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubGist) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubGistImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubGist")
		case "id":

			out.Values[i] = ec._GithubGist_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gistID":

			out.Values[i] = ec._GithubGist_gistID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "htmlURL":

			out.Values[i] = ec._GithubGist_htmlURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "public":

			out.Values[i] = ec._GithubGist_public(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._GithubGist_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":

			out.Values[i] = ec._GithubGist_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._GithubGist_description(ctx, field, obj)

		case "owner":

			out.Values[i] = ec._GithubGist_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._GithubGist_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._GithubGist_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "language":

			out.Values[i] = ec._GithubGist_language(ctx, field, obj)

		case "size":

			out.Values[i] = ec._GithubGist_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rawURL":

			out.Values[i] = ec._GithubGist_rawURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "content":

			out.Values[i] = ec._GithubGist_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubGistConnectionImplementors = []string{"GithubGistConnection"}

func (ec *executionContext) _GithubGistConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubGistConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubGistConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubGistConnection")
		case "edges":

			out.Values[i] = ec._GithubGistConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubGistConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubGistConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubGistEdgeImplementors = []string{"GithubGistEdge"}

func (ec *executionContext) _GithubGistEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubGistEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubGistEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubGistEdge")
		case "node":

			out.Values[i] = ec._GithubGistEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubGistEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubLicenseImplementors = []string{"GithubLicense"}

func (ec *executionContext) _GithubLicense(ctx context.Context, sel ast.SelectionSet, obj *github.License) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubLicenseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubLicense")
		case "key":

			out.Values[i] = ec._GithubLicense_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._GithubLicense_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spdxId":

			out.Values[i] = ec._GithubLicense_spdxId(ctx, field, obj)

		case "htmlURL":

			out.Values[i] = ec._GithubLicense_htmlURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubReleaseImplementors = []string{"GithubRelease", "Node"}

func (ec *executionContext) _GithubRelease(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubRelease) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubReleaseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubRelease")
		case "id":

			out.Values[i] = ec._GithubRelease_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "releaseID":

			out.Values[i] = ec._GithubRelease_releaseID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "htmlURL":

			out.Values[i] = ec._GithubRelease_htmlURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tagName":

			out.Values[i] = ec._GithubRelease_tagName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "targetCommitish":

			out.Values[i] = ec._GithubRelease_targetCommitish(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._GithubRelease_name(ctx, field, obj)

		case "draft":

			out.Values[i] = ec._GithubRelease_draft(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prerelease":

			out.Values[i] = ec._GithubRelease_prerelease(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._GithubRelease_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "publishedAt":

			out.Values[i] = ec._GithubRelease_publishedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":

			out.Values[i] = ec._GithubRelease_author(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubRelease_repository(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "assets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubRelease_assets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubReleaseConnectionImplementors = []string{"GithubReleaseConnection"}

func (ec *executionContext) _GithubReleaseConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubReleaseConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubReleaseConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubReleaseConnection")
		case "edges":

			out.Values[i] = ec._GithubReleaseConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubReleaseConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubReleaseConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubReleaseEdgeImplementors = []string{"GithubReleaseEdge"}

func (ec *executionContext) _GithubReleaseEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubReleaseEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubReleaseEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubReleaseEdge")
		case "node":

			out.Values[i] = ec._GithubReleaseEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubReleaseEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubRepositoryImplementors = []string{"GithubRepository", "Node"}

func (ec *executionContext) _GithubRepository(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubRepository")
		case "id":

			out.Values[i] = ec._GithubRepository_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repoID":

			out.Values[i] = ec._GithubRepository_repoID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._GithubRepository_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fullName":

			out.Values[i] = ec._GithubRepository_fullName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ownerLogin":

			out.Values[i] = ec._GithubRepository_ownerLogin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":

			out.Values[i] = ec._GithubRepository_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "public":

			out.Values[i] = ec._GithubRepository_public(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "htmlURL":

			out.Values[i] = ec._GithubRepository_htmlURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._GithubRepository_description(ctx, field, obj)

		case "fork":

			out.Values[i] = ec._GithubRepository_fork(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "homepage":

			out.Values[i] = ec._GithubRepository_homepage(ctx, field, obj)

		case "starCount":

			out.Values[i] = ec._GithubRepository_starCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "defaultBranch":

			out.Values[i] = ec._GithubRepository_defaultBranch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isTemplate":

			out.Values[i] = ec._GithubRepository_isTemplate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hasIssues":

			out.Values[i] = ec._GithubRepository_hasIssues(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "archived":

			out.Values[i] = ec._GithubRepository_archived(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pushedAt":

			out.Values[i] = ec._GithubRepository_pushedAt(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._GithubRepository_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._GithubRepository_updatedAt(ctx, field, obj)

		case "license":

			out.Values[i] = ec._GithubRepository_license(ctx, field, obj)

		case "labels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubRepository_labels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "releases":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubRepository_releases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubRepositoryConnectionImplementors = []string{"GithubRepositoryConnection"}

func (ec *executionContext) _GithubRepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubRepositoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubRepositoryConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubRepositoryConnection")
		case "edges":

			out.Values[i] = ec._GithubRepositoryConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GithubRepositoryConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._GithubRepositoryConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubRepositoryEdgeImplementors = []string{"GithubRepositoryEdge"}

func (ec *executionContext) _GithubRepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.GithubRepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubRepositoryEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubRepositoryEdge")
		case "node":

			out.Values[i] = ec._GithubRepositoryEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GithubRepositoryEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubStatsImplementors = []string{"GithubStats"}

func (ec *executionContext) _GithubStats(ctx context.Context, sel ast.SelectionSet, obj *models.GithubStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubStatsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubStats")
		case "commitsYear":

			out.Values[i] = ec._GithubStats_commitsYear(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pullRequests":

			out.Values[i] = ec._GithubStats_pullRequests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "openIssues":

			out.Values[i] = ec._GithubStats_openIssues(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "closedIssues":

			out.Values[i] = ec._GithubStats_closedIssues(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "issues":

			out.Values[i] = ec._GithubStats_issues(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repos":

			out.Values[i] = ec._GithubStats_repos(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contributedRepos":

			out.Values[i] = ec._GithubStats_contributedRepos(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stars":

			out.Values[i] = ec._GithubStats_stars(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubUserImplementors = []string{"GithubUser"}

func (ec *executionContext) _GithubUser(ctx context.Context, sel ast.SelectionSet, obj *github.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubUser")
		case "id":

			out.Values[i] = ec._GithubUser_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "login":

			out.Values[i] = ec._GithubUser_login(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._GithubUser_name(ctx, field, obj)

		case "avatarURL":

			out.Values[i] = ec._GithubUser_avatarURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":

			out.Values[i] = ec._GithubUser_email(ctx, field, obj)

		case "location":

			out.Values[i] = ec._GithubUser_location(ctx, field, obj)

		case "bio":

			out.Values[i] = ec._GithubUser_bio(ctx, field, obj)

		case "htmlurl":

			out.Values[i] = ec._GithubUser_htmlurl(ctx, field, obj)

		case "publicRepos":

			out.Values[i] = ec._GithubUser_publicRepos(ctx, field, obj)

		case "followers":

			out.Values[i] = ec._GithubUser_followers(ctx, field, obj)

		case "following":

			out.Values[i] = ec._GithubUser_following(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._GithubUser_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._GithubUser_updatedAt(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var labelImplementors = []string{"Label", "Node"}

func (ec *executionContext) _Label(ctx context.Context, sel ast.SelectionSet, obj *ent.Label) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Label")
		case "id":

			out.Values[i] = ec._Label_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createTime":

			out.Values[i] = ec._Label_createTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":

			out.Values[i] = ec._Label_updateTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Label_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "posts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Label_posts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubRepositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Label_githubRepositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var labelConnectionImplementors = []string{"LabelConnection"}

func (ec *executionContext) _LabelConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.LabelConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelConnection")
		case "edges":

			out.Values[i] = ec._LabelConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._LabelConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._LabelConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var labelEdgeImplementors = []string{"LabelEdge"}

func (ec *executionContext) _LabelEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.LabelEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelEdge")
		case "node":

			out.Values[i] = ec._LabelEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._LabelEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var languageStatImplementors = []string{"LanguageStat"}

func (ec *executionContext) _LanguageStat(ctx context.Context, sel ast.SelectionSet, obj *models.LanguageStat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageStatImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LanguageStat")
		case "language":

			out.Values[i] = ec._LanguageStat_language(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hexColor":

			out.Values[i] = ec._LanguageStat_hexColor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalSeconds":

			out.Values[i] = ec._LanguageStat_totalSeconds(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalDuration":

			out.Values[i] = ec._LanguageStat_totalDuration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkImplementors = []string{"Link"}

func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *clix.Link) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "name":

			out.Values[i] = ec._Link_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._Link_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "ping":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ping(ctx, field)
			})

		case "createLabel":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLabel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateLabel":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLabel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteLabel":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteLabel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deletePost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "regeneratePosts":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_regeneratePosts(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var postImplementors = []string{"Post", "Node"}

func (ec *executionContext) _Post(ctx context.Context, sel ast.SelectionSet, obj *ent.Post) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Post")
		case "id":

			out.Values[i] = ec._Post_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createTime":

			out.Values[i] = ec._Post_createTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":

			out.Values[i] = ec._Post_updateTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "slug":

			out.Values[i] = ec._Post_slug(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "title":

			out.Values[i] = ec._Post_title(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":

			out.Values[i] = ec._Post_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "contentHTML":

			out.Values[i] = ec._Post_contentHTML(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "summary":

			out.Values[i] = ec._Post_summary(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "publishedAt":

			out.Values[i] = ec._Post_publishedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "viewCount":

			out.Values[i] = ec._Post_viewCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "public":

			out.Values[i] = ec._Post_public(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "labels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_labels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var postConnectionImplementors = []string{"PostConnection"}

func (ec *executionContext) _PostConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.PostConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostConnection")
		case "edges":

			out.Values[i] = ec._PostConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._PostConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._PostConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var postEdgeImplementors = []string{"PostEdge"}

func (ec *executionContext) _PostEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.PostEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostEdge")
		case "node":

			out.Values[i] = ec._PostEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._PostEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubAssets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubAssets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubEvents":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubGists":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubGists(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubReleases":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubReleases(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubRepositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubRepositories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "labels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labels(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "posts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_posts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "codingStats":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_codingStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubStats":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "self":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_self(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var timestampImplementors = []string{"Timestamp"}

func (ec *executionContext) _Timestamp(ctx context.Context, sel ast.SelectionSet, obj *github.Timestamp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, timestampImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Timestamp")
		case "Time":

			out.Values[i] = ec._Timestamp_Time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createTime":

			out.Values[i] = ec._User_createTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":

			out.Values[i] = ec._User_updateTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "userID":

			out.Values[i] = ec._User_userID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "login":

			out.Values[i] = ec._User_login(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

		case "avatarURL":

			out.Values[i] = ec._User_avatarURL(ctx, field, obj)

		case "htmlURL":

			out.Values[i] = ec._User_htmlURL(ctx, field, obj)

		case "email":

			out.Values[i] = ec._User_email(ctx, field, obj)

		case "location":

			out.Values[i] = ec._User_location(ctx, field, obj)

		case "bio":

			out.Values[i] = ec._User_bio(ctx, field, obj)

		case "posts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_posts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.UserConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "edges":

			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._UserConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":

			out.Values[i] = ec._UserEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionInfoImplementors = []string{"VersionInfo"}

func (ec *executionContext) _VersionInfo(ctx context.Context, sel ast.SelectionSet, obj *clix.NonSensitiveVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionInfo")
		case "name":

			out.Values[i] = ec._VersionInfo_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._VersionInfo_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "commit":

			out.Values[i] = ec._VersionInfo_commit(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "date":

			out.Values[i] = ec._VersionInfo_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "command":

			out.Values[i] = ec._VersionInfo_command(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "goVersion":

			out.Values[i] = ec._VersionInfo_goVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "os":

			out.Values[i] = ec._VersionInfo_os(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "arch":

			out.Values[i] = ec._VersionInfo_arch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "links":

			out.Values[i] = ec._VersionInfo_links(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCodingStats2githubcomlrstanleyliamshinternalmodelsCodingStats(ctx context.Context, sel ast.SelectionSet, v models.CodingStats) graphql.Marshaler {
	return ec._CodingStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNCodingStats2githubcomlrstanleyliamshinternalmodelsCodingStats(ctx context.Context, sel ast.SelectionSet, v *models.CodingStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CodingStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateLabelInput2githubcomlrstanleyliamshinternalentCreateLabelInput(ctx context.Context, v interface{}) (ent.CreateLabelInput, error) {
	res, err := ec.unmarshalInputCreateLabelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreatePostInput2githubcomlrstanleyliamshinternalentCreatePostInput(ctx context.Context, v interface{}) (ent.CreatePostInput, error) {
	res, err := ec.unmarshalInputCreatePostInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx context.Context, v interface{}) (ent.Cursor, error) {
	var res ent.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubcomlrstanleyliamshinternalentCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGithubAssetConnection2githubcomlrstanleyliamshinternalentGithubAssetConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubAssetConnection) graphql.Marshaler {
	return ec._GithubAssetConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubAssetConnection2githubcomlrstanleyliamshinternalentGithubAssetConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAssetConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubAssetConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubAssetOrderField2githubcomlrstanleyliamshinternalentGithubAssetOrderField(ctx context.Context, v interface{}) (*ent.GithubAssetOrderField, error) {
	var res = new(ent.GithubAssetOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubAssetOrderField2githubcomlrstanleyliamshinternalentGithubAssetOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAssetOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx context.Context, v interface{}) (*ent.GithubAssetWhereInput, error) {
	res, err := ec.unmarshalInputGithubAssetWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubEventConnection2githubcomlrstanleyliamshinternalentGithubEventConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubEventConnection) graphql.Marshaler {
	return ec._GithubEventConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubEventConnection2githubcomlrstanleyliamshinternalentGithubEventConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubEventConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubEventConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubEventOrderField2githubcomlrstanleyliamshinternalentGithubEventOrderField(ctx context.Context, v interface{}) (*ent.GithubEventOrderField, error) {
	var res = new(ent.GithubEventOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubEventOrderField2githubcomlrstanleyliamshinternalentGithubEventOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubEventOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNGithubEventRepo2githubcomgooglegogithubv48githubRepository(ctx context.Context, sel ast.SelectionSet, v *github.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubEventRepo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx context.Context, v interface{}) (*ent.GithubEventWhereInput, error) {
	res, err := ec.unmarshalInputGithubEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubGistConnection2githubcomlrstanleyliamshinternalentGithubGistConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubGistConnection) graphql.Marshaler {
	return ec._GithubGistConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubGistConnection2githubcomlrstanleyliamshinternalentGithubGistConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubGistConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubGistConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubGistOrderField2githubcomlrstanleyliamshinternalentGithubGistOrderField(ctx context.Context, v interface{}) (*ent.GithubGistOrderField, error) {
	var res = new(ent.GithubGistOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubGistOrderField2githubcomlrstanleyliamshinternalentGithubGistOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubGistOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx context.Context, v interface{}) (*ent.GithubGistWhereInput, error) {
	res, err := ec.unmarshalInputGithubGistWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubRelease2githubcomlrstanleyliamshinternalentGithubRelease(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRelease) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubRelease(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubReleaseConnection2githubcomlrstanleyliamshinternalentGithubReleaseConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubReleaseConnection) graphql.Marshaler {
	return ec._GithubReleaseConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubReleaseConnection2githubcomlrstanleyliamshinternalentGithubReleaseConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubReleaseConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubReleaseConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubReleaseOrderField2githubcomlrstanleyliamshinternalentGithubReleaseOrderField(ctx context.Context, v interface{}) (*ent.GithubReleaseOrderField, error) {
	var res = new(ent.GithubReleaseOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubReleaseOrderField2githubcomlrstanleyliamshinternalentGithubReleaseOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubReleaseOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx context.Context, v interface{}) (*ent.GithubReleaseWhereInput, error) {
	res, err := ec.unmarshalInputGithubReleaseWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubRepository2githubcomlrstanleyliamshinternalentGithubRepository(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRepository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubRepository(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubRepositoryConnection2githubcomlrstanleyliamshinternalentGithubRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v ent.GithubRepositoryConnection) graphql.Marshaler {
	return ec._GithubRepositoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubRepositoryConnection2githubcomlrstanleyliamshinternalentGithubRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRepositoryConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubRepositoryConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGithubRepositoryOrderField2githubcomlrstanleyliamshinternalentGithubRepositoryOrderField(ctx context.Context, v interface{}) (*ent.GithubRepositoryOrderField, error) {
	var res = new(ent.GithubRepositoryOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubRepositoryOrderField2githubcomlrstanleyliamshinternalentGithubRepositoryOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRepositoryOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx context.Context, v interface{}) (*ent.GithubRepositoryWhereInput, error) {
	res, err := ec.unmarshalInputGithubRepositoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGithubStats2githubcomlrstanleyliamshinternalmodelsGithubStats(ctx context.Context, sel ast.SelectionSet, v models.GithubStats) graphql.Marshaler {
	return ec._GithubStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubStats2githubcomlrstanleyliamshinternalmodelsGithubStats(ctx context.Context, sel ast.SelectionSet, v *models.GithubStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubStats(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx context.Context, sel ast.SelectionSet, v github.User) graphql.Marshaler {
	return ec._GithubUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubUser2githubcomgooglegogithubv48githubUser(ctx context.Context, sel ast.SelectionSet, v *github.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLabel2githubcomlrstanleyliamshinternalentLabel(ctx context.Context, sel ast.SelectionSet, v ent.Label) graphql.Marshaler {
	return ec._Label(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabel2githubcomlrstanleyliamshinternalentLabel(ctx context.Context, sel ast.SelectionSet, v *ent.Label) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Label(ctx, sel, v)
}

func (ec *executionContext) marshalNLabelConnection2githubcomlrstanleyliamshinternalentLabelConnection(ctx context.Context, sel ast.SelectionSet, v ent.LabelConnection) graphql.Marshaler {
	return ec._LabelConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabelConnection2githubcomlrstanleyliamshinternalentLabelConnection(ctx context.Context, sel ast.SelectionSet, v *ent.LabelConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LabelConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLabelOrderField2githubcomlrstanleyliamshinternalentLabelOrderField(ctx context.Context, v interface{}) (*ent.LabelOrderField, error) {
	var res = new(ent.LabelOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLabelOrderField2githubcomlrstanleyliamshinternalentLabelOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.LabelOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx context.Context, v interface{}) (*ent.LabelWhereInput, error) {
	res, err := ec.unmarshalInputLabelWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageStat2githubcomlrstanleyliamshinternalmodelsLanguageStat(ctx context.Context, sel ast.SelectionSet, v models.LanguageStat) graphql.Marshaler {
	return ec._LanguageStat(ctx, sel, &v)
}

func (ec *executionContext) marshalNLink2githubcomlrstanleyclixLink(ctx context.Context, sel ast.SelectionSet, v clix.Link) graphql.Marshaler {
	return ec._Link(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNNode2githubcomlrstanleyliamshinternalentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubcomlrstanleyliamshinternalentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubcomlrstanleyliamshinternalentOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubcomlrstanleyliamshinternalentPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPost2githubcomlrstanleyliamshinternalentPost(ctx context.Context, sel ast.SelectionSet, v ent.Post) graphql.Marshaler {
	return ec._Post(ctx, sel, &v)
}

func (ec *executionContext) marshalNPost2githubcomlrstanleyliamshinternalentPost(ctx context.Context, sel ast.SelectionSet, v *ent.Post) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) marshalNPostConnection2githubcomlrstanleyliamshinternalentPostConnection(ctx context.Context, sel ast.SelectionSet, v ent.PostConnection) graphql.Marshaler {
	return ec._PostConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPostConnection2githubcomlrstanleyliamshinternalentPostConnection(ctx context.Context, sel ast.SelectionSet, v *ent.PostConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PostConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPostOrderField2githubcomlrstanleyliamshinternalentPostOrderField(ctx context.Context, v interface{}) (*ent.PostOrderField, error) {
	var res = new(ent.PostOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPostOrderField2githubcomlrstanleyliamshinternalentPostOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.PostOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx context.Context, v interface{}) (*ent.PostWhereInput, error) {
	res, err := ec.unmarshalInputPostWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateLabelInput2githubcomlrstanleyliamshinternalentUpdateLabelInput(ctx context.Context, v interface{}) (ent.UpdateLabelInput, error) {
	res, err := ec.unmarshalInputUpdateLabelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdatePostInput2githubcomlrstanleyliamshinternalentUpdatePostInput(ctx context.Context, v interface{}) (ent.UpdatePostInput, error) {
	res, err := ec.unmarshalInputUpdatePostInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomlrstanleyliamshinternalentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubcomlrstanleyliamshinternalentUserConnection(ctx context.Context, sel ast.SelectionSet, v ent.UserConnection) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2githubcomlrstanleyliamshinternalentUserConnection(ctx context.Context, sel ast.SelectionSet, v *ent.UserConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserOrderField2githubcomlrstanleyliamshinternalentUserOrderField(ctx context.Context, v interface{}) (*ent.UserOrderField, error) {
	var res = new(ent.UserOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubcomlrstanleyliamshinternalentUserOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UserOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionInfo2githubcomlrstanleyclixNonSensitiveVersion(ctx context.Context, sel ast.SelectionSet, v clix.NonSensitiveVersion) graphql.Marshaler {
	return ec._VersionInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionInfo2githubcomlrstanleyclixNonSensitiveVersion(ctx context.Context, sel ast.SelectionSet, v *clix.NonSensitiveVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionInfo(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2githubcomlrstanleyliamshinternalentCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOGithubAsset2githubcomlrstanleyliamshinternalentGithubAsset(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAsset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAsset(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubAssetEdge2githubcomlrstanleyliamshinternalentGithubAssetEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubAssetEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubAssetEdge2githubcomlrstanleyliamshinternalentGithubAssetEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubAssetEdge2githubcomlrstanleyliamshinternalentGithubAssetEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubAssetEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAssetEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubAssetOrder2githubcomlrstanleyliamshinternalentGithubAssetOrder(ctx context.Context, v interface{}) (*ent.GithubAssetOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubAssetOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubAssetWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubAssetWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubAssetWhereInput2githubcomlrstanleyliamshinternalentGithubAssetWhereInput(ctx context.Context, v interface{}) (*ent.GithubAssetWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubAssetWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubEvent2githubcomlrstanleyliamshinternalentGithubEvent(ctx context.Context, sel ast.SelectionSet, v *ent.GithubEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubEvent(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubEventEdge2githubcomlrstanleyliamshinternalentGithubEventEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubEventEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubEventEdge2githubcomlrstanleyliamshinternalentGithubEventEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubEventEdge2githubcomlrstanleyliamshinternalentGithubEventEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubEventEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubEventEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubEventOrder2githubcomlrstanleyliamshinternalentGithubEventOrder(ctx context.Context, v interface{}) (*ent.GithubEventOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubEventOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubEventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubEventWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubEventWhereInput2githubcomlrstanleyliamshinternalentGithubEventWhereInput(ctx context.Context, v interface{}) (*ent.GithubEventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubGist2githubcomlrstanleyliamshinternalentGithubGist(ctx context.Context, sel ast.SelectionSet, v *ent.GithubGist) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubGist(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubGistEdge2githubcomlrstanleyliamshinternalentGithubGistEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubGistEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubGistEdge2githubcomlrstanleyliamshinternalentGithubGistEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubGistEdge2githubcomlrstanleyliamshinternalentGithubGistEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubGistEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubGistEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubGistOrder2githubcomlrstanleyliamshinternalentGithubGistOrder(ctx context.Context, v interface{}) (*ent.GithubGistOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubGistOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubGistWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubGistWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubGistWhereInput2githubcomlrstanleyliamshinternalentGithubGistWhereInput(ctx context.Context, v interface{}) (*ent.GithubGistWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubGistWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubLicense2githubcomgooglegogithubv48githubLicense(ctx context.Context, sel ast.SelectionSet, v *github.License) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubLicense(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubRelease2githubcomlrstanleyliamshinternalentGithubRelease(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRelease) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubRelease(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubReleaseEdge2githubcomlrstanleyliamshinternalentGithubReleaseEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubReleaseEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubReleaseEdge2githubcomlrstanleyliamshinternalentGithubReleaseEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubReleaseEdge2githubcomlrstanleyliamshinternalentGithubReleaseEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubReleaseEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubReleaseEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubReleaseOrder2githubcomlrstanleyliamshinternalentGithubReleaseOrder(ctx context.Context, v interface{}) (*ent.GithubReleaseOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubReleaseOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubReleaseWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubReleaseWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubReleaseWhereInput2githubcomlrstanleyliamshinternalentGithubReleaseWhereInput(ctx context.Context, v interface{}) (*ent.GithubReleaseWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubReleaseWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubRepository2githubcomlrstanleyliamshinternalentGithubRepository(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubRepositoryEdge2githubcomlrstanleyliamshinternalentGithubRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.GithubRepositoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubRepositoryEdge2githubcomlrstanleyliamshinternalentGithubRepositoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubRepositoryEdge2githubcomlrstanleyliamshinternalentGithubRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v *ent.GithubRepositoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubRepositoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubRepositoryOrder2githubcomlrstanleyliamshinternalentGithubRepositoryOrder(ctx context.Context, v interface{}) (*ent.GithubRepositoryOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubRepositoryOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx context.Context, v interface{}) ([]*ent.GithubRepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GithubRepositoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGithubRepositoryWhereInput2githubcomlrstanleyliamshinternalentGithubRepositoryWhereInput(ctx context.Context, v interface{}) (*ent.GithubRepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubRepositoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) ([]int64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v []int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOLabel2githubcomlrstanleyliamshinternalentLabel(ctx context.Context, sel ast.SelectionSet, v *ent.Label) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Label(ctx, sel, v)
}

func (ec *executionContext) marshalOLabelEdge2githubcomlrstanleyliamshinternalentLabelEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.LabelEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLabelEdge2githubcomlrstanleyliamshinternalentLabelEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLabelEdge2githubcomlrstanleyliamshinternalentLabelEdge(ctx context.Context, sel ast.SelectionSet, v *ent.LabelEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLabelOrder2githubcomlrstanleyliamshinternalentLabelOrder(ctx context.Context, v interface{}) (*ent.LabelOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLabelOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx context.Context, v interface{}) ([]*ent.LabelWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LabelWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLabelWhereInput2githubcomlrstanleyliamshinternalentLabelWhereInput(ctx context.Context, v interface{}) (*ent.LabelWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLabelWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageStat2githubcomlrstanleyliamshinternalmodelsLanguageStat(ctx context.Context, sel ast.SelectionSet, v []models.LanguageStat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageStat2githubcomlrstanleyliamshinternalmodelsLanguageStat(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLink2githubcomlrstanleyclixLink(ctx context.Context, sel ast.SelectionSet, v []clix.Link) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLink2githubcomlrstanleyclixLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONode2githubcomlrstanleyliamshinternalentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOPost2githubcomlrstanleyliamshinternalentPost(ctx context.Context, sel ast.SelectionSet, v *ent.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) marshalOPostEdge2githubcomlrstanleyliamshinternalentPostEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.PostEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPostEdge2githubcomlrstanleyliamshinternalentPostEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPostEdge2githubcomlrstanleyliamshinternalentPostEdge(ctx context.Context, sel ast.SelectionSet, v *ent.PostEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PostEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPostOrder2githubcomlrstanleyliamshinternalentPostOrder(ctx context.Context, v interface{}) (*ent.PostOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPostOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx context.Context, v interface{}) ([]*ent.PostWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PostWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPostWhereInput2githubcomlrstanleyliamshinternalentPostWhereInput(ctx context.Context, v interface{}) (*ent.PostWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPostWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTimestamp2githubcomgooglegogithubv48githubTimestamp(ctx context.Context, sel ast.SelectionSet, v *github.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Timestamp(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2githubcomlrstanleyliamshinternalentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEdge2githubcomlrstanleyliamshinternalentUserEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2githubcomlrstanleyliamshinternalentUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserEdge2githubcomlrstanleyliamshinternalentUserEdge(ctx context.Context, sel ast.SelectionSet, v *ent.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrder2githubcomlrstanleyliamshinternalentUserOrder(ctx context.Context, v interface{}) (*ent.UserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx context.Context, v interface{}) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomlrstanleyliamshinternalentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
