// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package rest

import (
	"context"
	"time"

	github "github.com/google/go-github/v63/github"
	"github.com/lrstanley/liam.sh/internal/database/ent"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubasset"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubevent"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubgist"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrelease"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrepository"
	"github.com/lrstanley/liam.sh/internal/database/ent/label"
	"github.com/lrstanley/liam.sh/internal/database/ent/post"
	"github.com/lrstanley/liam.sh/internal/database/ent/user"
)

// UpdateGithubAssetParams defines parameters for updating a GithubAsset via a PATCH request.
type UpdateGithubAssetParams struct {
	// The ID of the asset.
	AssetID Option[int64] `json:"asset_id"`
	// The URL of the asset.
	BrowserDownloadURL Option[string] `json:"browser_download_url"`
	// The name of the asset.
	Name Option[string] `json:"name"`
	// The label of the asset.
	Label Option[string] `json:"label,omitempty"`
	// The state of the asset.
	State Option[string] `json:"state,omitempty"`
	// The content type of the asset.
	ContentType Option[string] `json:"content_type"`
	// The size of the asset in bytes.
	Size          Option[int64] `json:"size"`
	DownloadCount Option[int64] `json:"download_count"`
	// The date the asset was created.
	CreatedAt Option[time.Time] `json:"created_at"`
	// The date the asset was last updated.
	UpdatedAt Option[time.Time] `json:"updated_at,omitempty"`
	// The data of the user that uploaded the asset.
	Uploader Option[*github.User] `json:"uploader"`
	Release  Option[int]          `json:"release"`
}

func (u *UpdateGithubAssetParams) ApplyInputs(builder *ent.GithubAssetUpdateOne) *ent.GithubAssetUpdateOne {
	if v, ok := u.AssetID.Get(); ok {
		builder.SetAssetID(v)
	}
	if v, ok := u.BrowserDownloadURL.Get(); ok {
		builder.SetBrowserDownloadURL(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}
	if v, ok := u.Label.Get(); ok {
		builder.SetLabel(v)
	}
	if v, ok := u.State.Get(); ok {
		builder.SetState(v)
	}
	if v, ok := u.ContentType.Get(); ok {
		builder.SetContentType(v)
	}
	if v, ok := u.Size.Get(); ok {
		builder.SetSize(v)
	}
	if v, ok := u.DownloadCount.Get(); ok {
		builder.SetDownloadCount(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.UpdatedAt.Get(); ok {
		builder.SetUpdatedAt(v)
	}
	if v, ok := u.Uploader.Get(); ok {
		builder.SetUploader(v)
	}

	if v, ok := u.Release.Get(); ok {
		builder.SetReleaseID(v)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateGithubAssetParams) Exec(ctx context.Context, builder *ent.GithubAssetUpdateOne, query *ent.GithubAssetQuery) (*ent.GithubAsset, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubAsset(query.Where(githubasset.ID(result.ID))).Only(ctx)
}

// UpdateGithubEventParams defines parameters for updating a GithubEvent via a PATCH request.
type UpdateGithubEventParams struct {
	// The ID of the event.
	EventID Option[string] `json:"event_id"`
	// The type of the event.
	EventType Option[string] `json:"event_type"`
	// The date the event was created.
	CreatedAt Option[time.Time] `json:"created_at"`
	// Whether the event is public or not.
	Public Option[bool] `json:"public"`
	// The ID of the actor.
	ActorID Option[int64] `json:"actor_id"`
	// The actor data of the event.
	Actor Option[*github.User] `json:"actor"`
	// The ID of the repository.
	RepoID Option[int64] `json:"repo_id"`
	// The repository of the event.
	Repo Option[*github.Repository] `json:"repo"`
	// The payload of the event.
	Payload Option[map[string]interface{}] `json:"payload"`
}

func (u *UpdateGithubEventParams) ApplyInputs(builder *ent.GithubEventUpdateOne) *ent.GithubEventUpdateOne {
	if v, ok := u.EventID.Get(); ok {
		builder.SetEventID(v)
	}
	if v, ok := u.EventType.Get(); ok {
		builder.SetEventType(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.Public.Get(); ok {
		builder.SetPublic(v)
	}
	if v, ok := u.ActorID.Get(); ok {
		builder.SetActorID(v)
	}
	if v, ok := u.Actor.Get(); ok {
		builder.SetActor(v)
	}
	if v, ok := u.RepoID.Get(); ok {
		builder.SetRepoID(v)
	}
	if v, ok := u.Repo.Get(); ok {
		builder.SetRepo(v)
	}
	if v, ok := u.Payload.Get(); ok {
		builder.SetPayload(v)
	}

	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateGithubEventParams) Exec(ctx context.Context, builder *ent.GithubEventUpdateOne, query *ent.GithubEventQuery) (*ent.GithubEvent, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubEvent(query.Where(githubevent.ID(result.ID))).Only(ctx)
}

// UpdateGithubGistParams defines parameters for updating a GithubGist via a PATCH request.
type UpdateGithubGistParams struct {
	// The ID of the gist.
	GistID Option[string] `json:"gist_id"`
	// The URL of the gist.
	HTMLURL Option[string] `json:"html_url"`
	// Whether the gist is public or not.
	Public Option[bool] `json:"public"`
	// The date the gist was created.
	CreatedAt Option[time.Time] `json:"created_at"`
	// The date the gist was last updated.
	UpdatedAt Option[time.Time] `json:"updated_at"`
	// The description of the gist.
	Description Option[string] `json:"description,omitempty"`
	// The owner data of the gist.
	Owner Option[*github.User] `json:"owner"`
	// The name of the file.
	Name Option[string] `json:"name"`
	// The type of the file.
	Type Option[string] `json:"type"`
	// The programming language of the file.
	Language Option[string] `json:"language,omitempty"`
	// The size of the file in bytes.
	Size Option[int64] `json:"size"`
	// The raw URL of the file.
	RawURL Option[string] `json:"raw_url"`
	// The content of the file.
	Content Option[string] `json:"content"`
}

func (u *UpdateGithubGistParams) ApplyInputs(builder *ent.GithubGistUpdateOne) *ent.GithubGistUpdateOne {
	if v, ok := u.GistID.Get(); ok {
		builder.SetGistID(v)
	}
	if v, ok := u.HTMLURL.Get(); ok {
		builder.SetHTMLURL(v)
	}
	if v, ok := u.Public.Get(); ok {
		builder.SetPublic(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.UpdatedAt.Get(); ok {
		builder.SetUpdatedAt(v)
	}
	if v, ok := u.Description.Get(); ok {
		builder.SetDescription(v)
	}
	if v, ok := u.Owner.Get(); ok {
		builder.SetOwner(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}
	if v, ok := u.Type.Get(); ok {
		builder.SetType(v)
	}
	if v, ok := u.Language.Get(); ok {
		builder.SetLanguage(v)
	}
	if v, ok := u.Size.Get(); ok {
		builder.SetSize(v)
	}
	if v, ok := u.RawURL.Get(); ok {
		builder.SetRawURL(v)
	}
	if v, ok := u.Content.Get(); ok {
		builder.SetContent(v)
	}

	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateGithubGistParams) Exec(ctx context.Context, builder *ent.GithubGistUpdateOne, query *ent.GithubGistQuery) (*ent.GithubGist, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubGist(query.Where(githubgist.ID(result.ID))).Only(ctx)
}

// UpdateGithubReleaseParams defines parameters for updating a GithubRelease via a PATCH request.
type UpdateGithubReleaseParams struct {
	// The ID of the release.
	ReleaseID Option[int64] `json:"release_id"`
	// The URL of the release.
	HTMLURL Option[string] `json:"html_url"`
	// The tag name of the release.
	TagName Option[string] `json:"tag_name"`
	// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
	TargetCommitish Option[string] `json:"target_commitish"`
	// The name of the release.
	Name Option[string] `json:"name,omitempty"`
	// Indicates whether the release is a draft.
	Draft Option[bool] `json:"draft"`
	// Indicates whether the release is a prerelease.
	Prerelease Option[bool] `json:"prerelease"`
	// The date the release was created.
	CreatedAt Option[time.Time] `json:"created_at"`
	// The date the release was published.
	PublishedAt  Option[time.Time]    `json:"published_at"`
	Author       Option[*github.User] `json:"author"`
	Repository   Option[int]          `json:"repository"`
	AddAssets    Option[[]int]        `json:"add_assets,omitempty"`
	RemoveAssets Option[[]int]        `json:"remove_assets,omitempty"`
}

func (u *UpdateGithubReleaseParams) ApplyInputs(builder *ent.GithubReleaseUpdateOne) *ent.GithubReleaseUpdateOne {
	if v, ok := u.ReleaseID.Get(); ok {
		builder.SetReleaseID(v)
	}
	if v, ok := u.HTMLURL.Get(); ok {
		builder.SetHTMLURL(v)
	}
	if v, ok := u.TagName.Get(); ok {
		builder.SetTagName(v)
	}
	if v, ok := u.TargetCommitish.Get(); ok {
		builder.SetTargetCommitish(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}
	if v, ok := u.Draft.Get(); ok {
		builder.SetDraft(v)
	}
	if v, ok := u.Prerelease.Get(); ok {
		builder.SetPrerelease(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.PublishedAt.Get(); ok {
		builder.SetPublishedAt(v)
	}
	if v, ok := u.Author.Get(); ok {
		builder.SetAuthor(v)
	}

	if v, ok := u.Repository.Get(); ok {
		builder.SetRepositoryID(v)
	}
	if v, ok := u.AddAssets.Get(); ok && v != nil {
		builder.AddAssetIDs(v...)
	}
	if v, ok := u.RemoveAssets.Get(); ok && v != nil {
		builder.RemoveAssetIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateGithubReleaseParams) Exec(ctx context.Context, builder *ent.GithubReleaseUpdateOne, query *ent.GithubReleaseQuery) (*ent.GithubRelease, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubRelease(query.Where(githubrelease.ID(result.ID))).Only(ctx)
}

// UpdateGithubRepositoryParams defines parameters for updating a GithubRepository via a PATCH request.
type UpdateGithubRepositoryParams struct {
	// The ID of the repository.
	RepoID Option[int64] `json:"repo_id"`
	// The name of the repository.
	Name Option[string] `json:"name"`
	// The full name of the repository, which includes the owner.
	FullName Option[string] `json:"full_name"`
	// The username which owns the repository (user or organization).
	OwnerLogin Option[string] `json:"owner_login"`
	// The owner data of the repository.
	Owner Option[*github.User] `json:"owner"`
	// Whether the repository is public or not.
	Public Option[bool] `json:"public"`
	// The URL of the repository.
	HTMLURL Option[string] `json:"html_url"`
	// The description of the repository.
	Description Option[string] `json:"description,omitempty"`
	// Whether the repository is a fork or not.
	Fork Option[bool] `json:"fork"`
	// The homepage of the repository.
	Homepage Option[string] `json:"homepage,omitempty"`
	// The number of stars the repository has.
	StarCount Option[int] `json:"star_count"`
	// The default branch of the repository.
	DefaultBranch Option[string] `json:"default_branch"`
	// Whether the repository is a template repo or not.
	IsTemplate Option[bool] `json:"is_template"`
	// Whether the repository has issues enabled or not.
	HasIssues Option[bool] `json:"has_issues"`
	// Whether the repository is archived or not.
	Archived Option[bool] `json:"archived"`
	// The date the repository was last pushed to.
	PushedAt Option[time.Time] `json:"pushed_at,omitempty"`
	// The date the repository was created.
	CreatedAt Option[time.Time] `json:"created_at"`
	// The date the repository was last updated.
	UpdatedAt      Option[time.Time]       `json:"updated_at,omitempty"`
	License        Option[*github.License] `json:"license,omitempty"`
	AddLabels      Option[[]int]           `json:"add_labels,omitempty"`
	RemoveLabels   Option[[]int]           `json:"remove_labels,omitempty"`
	AddReleases    Option[[]int]           `json:"add_releases,omitempty"`
	RemoveReleases Option[[]int]           `json:"remove_releases,omitempty"`
}

func (u *UpdateGithubRepositoryParams) ApplyInputs(builder *ent.GithubRepositoryUpdateOne) *ent.GithubRepositoryUpdateOne {
	if v, ok := u.RepoID.Get(); ok {
		builder.SetRepoID(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}
	if v, ok := u.FullName.Get(); ok {
		builder.SetFullName(v)
	}
	if v, ok := u.OwnerLogin.Get(); ok {
		builder.SetOwnerLogin(v)
	}
	if v, ok := u.Owner.Get(); ok {
		builder.SetOwner(v)
	}
	if v, ok := u.Public.Get(); ok {
		builder.SetPublic(v)
	}
	if v, ok := u.HTMLURL.Get(); ok {
		builder.SetHTMLURL(v)
	}
	if v, ok := u.Description.Get(); ok {
		builder.SetDescription(v)
	}
	if v, ok := u.Fork.Get(); ok {
		builder.SetFork(v)
	}
	if v, ok := u.Homepage.Get(); ok {
		builder.SetHomepage(v)
	}
	if v, ok := u.StarCount.Get(); ok {
		builder.SetStarCount(v)
	}
	if v, ok := u.DefaultBranch.Get(); ok {
		builder.SetDefaultBranch(v)
	}
	if v, ok := u.IsTemplate.Get(); ok {
		builder.SetIsTemplate(v)
	}
	if v, ok := u.HasIssues.Get(); ok {
		builder.SetHasIssues(v)
	}
	if v, ok := u.Archived.Get(); ok {
		builder.SetArchived(v)
	}
	if v, ok := u.PushedAt.Get(); ok {
		builder.SetPushedAt(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.UpdatedAt.Get(); ok {
		builder.SetUpdatedAt(v)
	}
	if v, ok := u.License.Get(); ok {
		builder.SetLicense(v)
	}

	if v, ok := u.AddLabels.Get(); ok && v != nil {
		builder.AddLabelIDs(v...)
	}
	if v, ok := u.RemoveLabels.Get(); ok && v != nil {
		builder.RemoveLabelIDs(v...)
	}
	if v, ok := u.AddReleases.Get(); ok && v != nil {
		builder.AddReleaseIDs(v...)
	}
	if v, ok := u.RemoveReleases.Get(); ok && v != nil {
		builder.RemoveReleaseIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateGithubRepositoryParams) Exec(ctx context.Context, builder *ent.GithubRepositoryUpdateOne, query *ent.GithubRepositoryQuery) (*ent.GithubRepository, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubRepository(query.Where(githubrepository.ID(result.ID))).Only(ctx)
}

// UpdateLabelParams defines parameters for updating a Label via a PATCH request.
type UpdateLabelParams struct {
	// Time the entity was last updated.
	UpdateTime Option[time.Time] `json:"update_time"`
	// Label name.
	Name                     Option[string] `json:"name"`
	AddPosts                 Option[[]int]  `json:"add_posts,omitempty"`
	RemovePosts              Option[[]int]  `json:"remove_posts,omitempty"`
	AddGithubRepositories    Option[[]int]  `json:"add_github_repositories,omitempty"`
	RemoveGithubRepositories Option[[]int]  `json:"remove_github_repositories,omitempty"`
}

func (u *UpdateLabelParams) ApplyInputs(builder *ent.LabelUpdateOne) *ent.LabelUpdateOne {
	if v, ok := u.UpdateTime.Get(); ok {
		builder.SetUpdateTime(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}

	if v, ok := u.AddPosts.Get(); ok && v != nil {
		builder.AddPostIDs(v...)
	}
	if v, ok := u.RemovePosts.Get(); ok && v != nil {
		builder.RemovePostIDs(v...)
	}
	if v, ok := u.AddGithubRepositories.Get(); ok && v != nil {
		builder.AddGithubRepositoryIDs(v...)
	}
	if v, ok := u.RemoveGithubRepositories.Get(); ok && v != nil {
		builder.RemoveGithubRepositoryIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateLabelParams) Exec(ctx context.Context, builder *ent.LabelUpdateOne, query *ent.LabelQuery) (*ent.Label, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadLabel(query.Where(label.ID(result.ID))).Only(ctx)
}

// UpdatePostParams defines parameters for updating a Post via a PATCH request.
type UpdatePostParams struct {
	// Time the entity was last updated.
	UpdateTime Option[time.Time] `json:"update_time"`
	// Post slug.
	Slug Option[string] `json:"slug"`
	// Post title.
	Title Option[string] `json:"title"`
	// Post content in Markdown.
	Content     Option[string]    `json:"content"`
	PublishedAt Option[time.Time] `json:"published_at"`
	// Whether the post is public or not.
	Public       Option[bool]  `json:"public"`
	AddLabels    Option[[]int] `json:"add_labels,omitempty"`
	RemoveLabels Option[[]int] `json:"remove_labels,omitempty"`
}

func (u *UpdatePostParams) ApplyInputs(builder *ent.PostUpdateOne) *ent.PostUpdateOne {
	if v, ok := u.UpdateTime.Get(); ok {
		builder.SetUpdateTime(v)
	}
	if v, ok := u.Slug.Get(); ok {
		builder.SetSlug(v)
	}
	if v, ok := u.Title.Get(); ok {
		builder.SetTitle(v)
	}
	if v, ok := u.Content.Get(); ok {
		builder.SetContent(v)
	}
	if v, ok := u.PublishedAt.Get(); ok {
		builder.SetPublishedAt(v)
	}
	if v, ok := u.Public.Get(); ok {
		builder.SetPublic(v)
	}

	if v, ok := u.AddLabels.Get(); ok && v != nil {
		builder.AddLabelIDs(v...)
	}
	if v, ok := u.RemoveLabels.Get(); ok && v != nil {
		builder.RemoveLabelIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdatePostParams) Exec(ctx context.Context, builder *ent.PostUpdateOne, query *ent.PostQuery) (*ent.Post, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadPost(query.Where(post.ID(result.ID))).Only(ctx)
}

// UpdateUserParams defines parameters for updating a User via a PATCH request.
type UpdateUserParams struct {
	// Time the entity was last updated.
	UpdateTime Option[time.Time] `json:"update_time"`
	// Users GitHub login ID (username).
	Login Option[string] `json:"login"`
	// Users GitHub display name.
	Name Option[string] `json:"name,omitempty"`
	// GitHub avatar of the user, provided by GitHub.
	AvatarURL Option[string] `json:"avatar_url,omitempty"`
	// Users GitHub profile URL.
	HTMLURL Option[string] `json:"html_url,omitempty"`
	// Users GitHub email address.
	Email Option[string] `json:"email,omitempty"`
	// Users GitHub location.
	Location Option[string] `json:"location,omitempty"`
	// Users GitHub bio.
	Bio         Option[string] `json:"bio,omitempty"`
	AddPosts    Option[[]int]  `json:"add_posts,omitempty"`
	RemovePosts Option[[]int]  `json:"remove_posts,omitempty"`
}

func (u *UpdateUserParams) ApplyInputs(builder *ent.UserUpdateOne) *ent.UserUpdateOne {
	if v, ok := u.UpdateTime.Get(); ok {
		builder.SetUpdateTime(v)
	}
	if v, ok := u.Login.Get(); ok {
		builder.SetLogin(v)
	}
	if v, ok := u.Name.Get(); ok {
		builder.SetName(v)
	}
	if v, ok := u.AvatarURL.Get(); ok {
		builder.SetAvatarURL(v)
	}
	if v, ok := u.HTMLURL.Get(); ok {
		builder.SetHTMLURL(v)
	}
	if v, ok := u.Email.Get(); ok {
		builder.SetEmail(v)
	}
	if v, ok := u.Location.Get(); ok {
		builder.SetLocation(v)
	}
	if v, ok := u.Bio.Get(); ok {
		builder.SetBio(v)
	}

	if v, ok := u.AddPosts.Get(); ok && v != nil {
		builder.AddPostIDs(v...)
	}
	if v, ok := u.RemovePosts.Get(); ok && v != nil {
		builder.RemovePostIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateUserParams) Exec(ctx context.Context, builder *ent.UserUpdateOne, query *ent.UserQuery) (*ent.User, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadUser(query.Where(user.ID(result.ID))).Only(ctx)
}
