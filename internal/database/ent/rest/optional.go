// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package rest

import "encoding/json"

// empty returns an empty value of type T.
func empty[T any]() (t T) {
	return
}

// Option is a container for an optional value of type T.
type Option[T any] struct {
	present bool
	value   T
}

// Present returns false when value is absent.
func (o Option[T]) Present() bool {
	return o.present
}

// Get returns value and presence.
func (o Option[T]) Get() (T, bool) {
	if !o.present {
		return empty[T](), false
	}
	return o.value, true
}

// OrElse returns value if present, or the provided default value.
func (o Option[T]) OrElse(fallback T) T {
	if !o.present {
		return fallback
	}
	return o.value
}

// OrEmpty returns value if present, or the provided empty value.
func (o Option[T]) OrEmpty() T {
	return o.value
}

// Ptr returns value if present, or nil otherwise.
func (o Option[T]) Ptr() *T {
	if !o.present {
		return nil
	}
	return &o.value
}

// MarshalJSON encodes Option to JSON.
func (o Option[T]) MarshalJSON() ([]byte, error) {
	if o.present {
		return json.Marshal(o.value)
	}
	return json.Marshal(nil)
}

// UnmarshalJSON decodes Option from JSON.
func (o *Option[T]) UnmarshalJSON(b []byte) error {
	o.present = true

	err := json.Unmarshal(b, &o.value)
	if err != nil {
		return err
	}

	return nil
}

// MarshalText implements the encoding.TextMarshaler interface.
func (o Option[T]) MarshalText() ([]byte, error) {
	return json.Marshal(o)
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (o *Option[T]) UnmarshalText(data []byte) error {
	return json.Unmarshal(data, o)
}
