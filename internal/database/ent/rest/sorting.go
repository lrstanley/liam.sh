// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package rest

import (
	"fmt"
	"slices"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/lrstanley/liam.sh/internal/database/ent"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubasset"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrelease"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrepository"
	"github.com/lrstanley/liam.sh/internal/database/ent/label"
	"github.com/lrstanley/liam.sh/internal/database/ent/post"
	"github.com/lrstanley/liam.sh/internal/database/ent/user"
)

type Sorted struct {
	// Field is the field to sort by. Can be a standard field name (e.g. "name"), or a custom field
	// name (e.g. "pets.age.sum"). If no field is provided, the default field will be used.
	Field *string `json:"sort" form:"sort,omitempty"`

	// Order is the order to sort by. Can be either "asc" or "desc". If no order is provided, the
	// default order will be used.
	Order *orderDirection `json:"order" form:"order,omitempty"`
}

// Validate validates the sorting fields and applies any necessary defaults.
func (s *Sorted) Validate(cfg *SortConfig) error {
	if s.Field == nil {
		if cfg.DefaultField == "" {
			return nil
		}
		s.Field = &cfg.DefaultField
	}
	if s.Order == nil {
		s.Order = &cfg.DefaultOrder
	}

	if !slices.Contains(cfg.Fields, *s.Field) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid sort field: %s", *s.Field)}
	}

	if !slices.Contains(OrderDirections, *s.Order) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid order: %s", *s.Order)}
	}

	return nil
}

// withOrderTerm returns the OrderTermOption (asc/desc) based on the provided order string.
func withOrderTerm(order orderDirection) sql.OrderTermOption {
	if order == orderAsc {
		return sql.OrderAsc()
	}
	return sql.OrderDesc()
}

func withFieldSelector(field string, order orderDirection) func(*sql.Selector) {
	if order == orderAsc {
		return ent.Asc(field)
	}
	return ent.Desc(field)
}

type SortConfig struct {
	Fields       []string
	DefaultField string
	DefaultOrder orderDirection
}

type orderDirection string

var (
	orderAsc  orderDirection = "asc"
	orderDesc orderDirection = "desc"

	// OrderDirections are the allowed order directions that can be provided.
	OrderDirections = []orderDirection{orderAsc, orderDesc}
	// GithubAssetSortConfig defines the default sort configuration for GithubAsset.
	GithubAssetSortConfig = &SortConfig{
		Fields: []string{
			"asset_id",
			"created_at",
			"download_count",
			"id",
			"label",
			"name",
			"random",
			"release.created_at",
			"release.draft",
			"release.id",
			"release.name",
			"release.prerelease",
			"release.published_at",
			"release.release_id",
			"release.tag_name",
			"size",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// GithubEventSortConfig defines the default sort configuration for GithubEvent.
	GithubEventSortConfig = &SortConfig{
		Fields: []string{
			"actor_id",
			"created_at",
			"event_id",
			"event_type",
			"id",
			"public",
			"random",
			"repo_id",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// GithubGistSortConfig defines the default sort configuration for GithubGist.
	GithubGistSortConfig = &SortConfig{
		Fields: []string{
			"created_at",
			"gist_id",
			"id",
			"language",
			"name",
			"public",
			"random",
			"size",
			"type",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// GithubReleaseSortConfig defines the default sort configuration for GithubRelease.
	GithubReleaseSortConfig = &SortConfig{
		Fields: []string{
			"assets.asset_id.sum",
			"assets.count",
			"assets.download_count.sum",
			"assets.size.sum",
			"created_at",
			"draft",
			"id",
			"name",
			"prerelease",
			"published_at",
			"random",
			"release_id",
			"repository.archived",
			"repository.created_at",
			"repository.default_branch",
			"repository.fork",
			"repository.full_name",
			"repository.has_issues",
			"repository.id",
			"repository.is_template",
			"repository.name",
			"repository.owner_login",
			"repository.public",
			"repository.pushed_at",
			"repository.repo_id",
			"repository.star_count",
			"repository.updated_at",
			"tag_name",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// GithubRepositorySortConfig defines the default sort configuration for GithubRepository.
	GithubRepositorySortConfig = &SortConfig{
		Fields: []string{
			"archived",
			"created_at",
			"default_branch",
			"fork",
			"full_name",
			"has_issues",
			"id",
			"is_template",
			"labels.count",
			"name",
			"owner_login",
			"public",
			"pushed_at",
			"random",
			"releases.count",
			"releases.release_id.sum",
			"repo_id",
			"star_count",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// LabelSortConfig defines the default sort configuration for Label.
	LabelSortConfig = &SortConfig{
		Fields: []string{
			"create_time",
			"github_repositories.count",
			"github_repositories.repo_id.sum",
			"github_repositories.star_count.sum",
			"id",
			"name",
			"posts.count",
			"posts.view_count.sum",
			"random",
			"update_time",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// PostSortConfig defines the default sort configuration for Post.
	PostSortConfig = &SortConfig{
		Fields: []string{
			"author.create_time",
			"author.email",
			"author.id",
			"author.location",
			"author.login",
			"author.name",
			"author.update_time",
			"create_time",
			"id",
			"labels.count",
			"public",
			"published_at",
			"random",
			"slug",
			"title",
			"update_time",
			"view_count",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// UserSortConfig defines the default sort configuration for User.
	UserSortConfig = &SortConfig{
		Fields: []string{
			"create_time",
			"email",
			"id",
			"location",
			"login",
			"name",
			"posts.count",
			"posts.view_count.sum",
			"random",
			"update_time",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
)

// isSpecializedSort checks if the sort field is a specialized sort field.
func isSpecializedSort(parts []string) (isCount, isSum bool) {
	switch {
	case len(parts) == 3:
		switch parts[2] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	case len(parts) == 2:
		switch parts[1] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	}
	return isCount, isSum
}

// applySortingGithubAsset applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingGithubAsset(query *ent.GithubAssetQuery, field string, order orderDirection) *ent.GithubAssetQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case githubasset.EdgeRelease:
			return query.Order(githubasset.ByReleaseField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingGithubEvent applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingGithubEvent(query *ent.GithubEventQuery, field string, order orderDirection) *ent.GithubEventQuery {
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingGithubGist applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingGithubGist(query *ent.GithubGistQuery, field string, order orderDirection) *ent.GithubGistQuery {
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingGithubRelease applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingGithubRelease(query *ent.GithubReleaseQuery, field string, order orderDirection) *ent.GithubReleaseQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case githubrelease.EdgeRepository:
			return query.Order(githubrelease.ByRepositoryField(parts[1], dir))
		case githubrelease.EdgeAssets:
			switch {
			case isCount:
				return query.Order(githubrelease.ByAssetsCount(dir))
			case isSum:
				return query.Order(githubrelease.ByAssets(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(githubrelease.ByAssets(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingGithubRepository applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingGithubRepository(query *ent.GithubRepositoryQuery, field string, order orderDirection) *ent.GithubRepositoryQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case githubrepository.EdgeLabels:
			switch {
			case isCount:
				return query.Order(githubrepository.ByLabelsCount(dir))
			case isSum:
				return query.Order(githubrepository.ByLabels(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(githubrepository.ByLabels(sql.OrderByField(parts[1], dir)))
			}
		case githubrepository.EdgeReleases:
			switch {
			case isCount:
				return query.Order(githubrepository.ByReleasesCount(dir))
			case isSum:
				return query.Order(githubrepository.ByReleases(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(githubrepository.ByReleases(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingLabel applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingLabel(query *ent.LabelQuery, field string, order orderDirection) *ent.LabelQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case label.EdgePosts:
			switch {
			case isCount:
				return query.Order(label.ByPostsCount(dir))
			case isSum:
				return query.Order(label.ByPosts(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(label.ByPosts(sql.OrderByField(parts[1], dir)))
			}
		case label.EdgeGithubRepositories:
			switch {
			case isCount:
				return query.Order(label.ByGithubRepositoriesCount(dir))
			case isSum:
				return query.Order(label.ByGithubRepositories(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(label.ByGithubRepositories(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingPost applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingPost(query *ent.PostQuery, field string, order orderDirection) *ent.PostQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case post.EdgeAuthor:
			return query.Order(post.ByAuthorField(parts[1], dir))
		case post.EdgeLabels:
			switch {
			case isCount:
				return query.Order(post.ByLabelsCount(dir))
			case isSum:
				return query.Order(post.ByLabels(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(post.ByLabels(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingUser applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingUser(query *ent.UserQuery, field string, order orderDirection) *ent.UserQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case user.EdgePosts:
			switch {
			case isCount:
				return query.Order(user.ByPostsCount(dir))
			case isSum:
				return query.Order(user.ByPosts(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByPosts(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}
