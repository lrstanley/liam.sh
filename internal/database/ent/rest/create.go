// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// DO NOT EDIT, CODE GENERATED BY entc.

package rest

import (
	"context"
	"time"

	github "github.com/google/go-github/v63/github"
	"github.com/lrstanley/liam.sh/internal/database/ent"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubasset"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubevent"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubgist"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrelease"
	"github.com/lrstanley/liam.sh/internal/database/ent/githubrepository"
	"github.com/lrstanley/liam.sh/internal/database/ent/label"
	"github.com/lrstanley/liam.sh/internal/database/ent/post"
	"github.com/lrstanley/liam.sh/internal/database/ent/user"
)

// CreateGithubAssetParams defines parameters for creating a GithubAsset via a POST request.
type CreateGithubAssetParams struct {
	// The ID of the asset.
	AssetID int64 `json:"asset_id"`
	// The URL of the asset.
	BrowserDownloadURL string `json:"browser_download_url"`
	// The name of the asset.
	Name string `json:"name"`
	// The label of the asset.
	Label *string `json:"label,omitempty"`
	// The state of the asset.
	State *string `json:"state,omitempty"`
	// The content type of the asset.
	ContentType string `json:"content_type"`
	// The size of the asset in bytes.
	Size          int64 `json:"size"`
	DownloadCount int64 `json:"download_count"`
	// The date the asset was created.
	CreatedAt time.Time `json:"created_at"`
	// The date the asset was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// The data of the user that uploaded the asset.
	Uploader *github.User `json:"uploader"`
	Release  int          `json:"release"`
}

func (c *CreateGithubAssetParams) ApplyInputs(builder *ent.GithubAssetCreate) *ent.GithubAssetCreate {
	builder.SetAssetID(c.AssetID)
	builder.SetBrowserDownloadURL(c.BrowserDownloadURL)
	builder.SetName(c.Name)
	if c.Label != nil {
		builder.SetLabel(*c.Label)
	}
	if c.State != nil {
		builder.SetState(*c.State)
	}
	builder.SetContentType(c.ContentType)
	builder.SetSize(c.Size)
	builder.SetDownloadCount(c.DownloadCount)
	builder.SetCreatedAt(c.CreatedAt)
	if c.UpdatedAt != nil {
		builder.SetUpdatedAt(*c.UpdatedAt)
	}
	builder.SetUploader(c.Uploader)
	builder.SetReleaseID(c.Release)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateGithubAssetParams) Exec(ctx context.Context, builder *ent.GithubAssetCreate, query *ent.GithubAssetQuery) (*ent.GithubAsset, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubAsset(query.Where(githubasset.ID(result.ID))).Only(ctx)
}

// CreateGithubEventParams defines parameters for creating a GithubEvent via a POST request.
type CreateGithubEventParams struct {
	// The ID of the event.
	EventID string `json:"event_id"`
	// The type of the event.
	EventType string `json:"event_type"`
	// The date the event was created.
	CreatedAt time.Time `json:"created_at"`
	// Whether the event is public or not.
	Public *bool `json:"public"`
	// The ID of the actor.
	ActorID int64 `json:"actor_id"`
	// The actor data of the event.
	Actor *github.User `json:"actor"`
	// The ID of the repository.
	RepoID int64 `json:"repo_id"`
	// The repository of the event.
	Repo *github.Repository `json:"repo"`
	// The payload of the event.
	Payload map[string]interface{} `json:"payload"`
}

func (c *CreateGithubEventParams) ApplyInputs(builder *ent.GithubEventCreate) *ent.GithubEventCreate {
	builder.SetEventID(c.EventID)
	builder.SetEventType(c.EventType)
	builder.SetCreatedAt(c.CreatedAt)
	if c.Public != nil {
		builder.SetPublic(*c.Public)
	}
	builder.SetActorID(c.ActorID)
	builder.SetActor(c.Actor)
	builder.SetRepoID(c.RepoID)
	builder.SetRepo(c.Repo)
	builder.SetPayload(c.Payload)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateGithubEventParams) Exec(ctx context.Context, builder *ent.GithubEventCreate, query *ent.GithubEventQuery) (*ent.GithubEvent, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubEvent(query.Where(githubevent.ID(result.ID))).Only(ctx)
}

// CreateGithubGistParams defines parameters for creating a GithubGist via a POST request.
type CreateGithubGistParams struct {
	// The ID of the gist.
	GistID string `json:"gist_id"`
	// The URL of the gist.
	HTMLURL string `json:"html_url"`
	// Whether the gist is public or not.
	Public bool `json:"public"`
	// The date the gist was created.
	CreatedAt time.Time `json:"created_at"`
	// The date the gist was last updated.
	UpdatedAt time.Time `json:"updated_at"`
	// The description of the gist.
	Description *string `json:"description,omitempty"`
	// The owner data of the gist.
	Owner *github.User `json:"owner"`
	// The name of the file.
	Name string `json:"name"`
	// The type of the file.
	Type string `json:"type"`
	// The programming language of the file.
	Language *string `json:"language,omitempty"`
	// The size of the file in bytes.
	Size int64 `json:"size"`
	// The raw URL of the file.
	RawURL string `json:"raw_url"`
	// The content of the file.
	Content string `json:"content"`
}

func (c *CreateGithubGistParams) ApplyInputs(builder *ent.GithubGistCreate) *ent.GithubGistCreate {
	builder.SetGistID(c.GistID)
	builder.SetHTMLURL(c.HTMLURL)
	builder.SetPublic(c.Public)
	builder.SetCreatedAt(c.CreatedAt)
	builder.SetUpdatedAt(c.UpdatedAt)
	if c.Description != nil {
		builder.SetDescription(*c.Description)
	}
	builder.SetOwner(c.Owner)
	builder.SetName(c.Name)
	builder.SetType(c.Type)
	if c.Language != nil {
		builder.SetLanguage(*c.Language)
	}
	builder.SetSize(c.Size)
	builder.SetRawURL(c.RawURL)
	builder.SetContent(c.Content)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateGithubGistParams) Exec(ctx context.Context, builder *ent.GithubGistCreate, query *ent.GithubGistQuery) (*ent.GithubGist, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubGist(query.Where(githubgist.ID(result.ID))).Only(ctx)
}

// CreateGithubReleaseParams defines parameters for creating a GithubRelease via a POST request.
type CreateGithubReleaseParams struct {
	// The ID of the release.
	ReleaseID int64 `json:"release_id"`
	// The URL of the release.
	HTMLURL string `json:"html_url"`
	// The tag name of the release.
	TagName string `json:"tag_name"`
	// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
	TargetCommitish string `json:"target_commitish"`
	// The name of the release.
	Name *string `json:"name,omitempty"`
	// Indicates whether the release is a draft.
	Draft bool `json:"draft"`
	// Indicates whether the release is a prerelease.
	Prerelease bool `json:"prerelease"`
	// The date the release was created.
	CreatedAt time.Time `json:"created_at"`
	// The date the release was published.
	PublishedAt time.Time    `json:"published_at"`
	Author      *github.User `json:"author"`
	Repository  int          `json:"repository"`
	Assets      []int        `json:"assets,omitempty"`
}

func (c *CreateGithubReleaseParams) ApplyInputs(builder *ent.GithubReleaseCreate) *ent.GithubReleaseCreate {
	builder.SetReleaseID(c.ReleaseID)
	builder.SetHTMLURL(c.HTMLURL)
	builder.SetTagName(c.TagName)
	builder.SetTargetCommitish(c.TargetCommitish)
	if c.Name != nil {
		builder.SetName(*c.Name)
	}
	builder.SetDraft(c.Draft)
	builder.SetPrerelease(c.Prerelease)
	builder.SetCreatedAt(c.CreatedAt)
	builder.SetPublishedAt(c.PublishedAt)
	builder.SetAuthor(c.Author)
	builder.SetRepositoryID(c.Repository)
	builder.AddAssetIDs(c.Assets...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateGithubReleaseParams) Exec(ctx context.Context, builder *ent.GithubReleaseCreate, query *ent.GithubReleaseQuery) (*ent.GithubRelease, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubRelease(query.Where(githubrelease.ID(result.ID))).Only(ctx)
}

// CreateGithubRepositoryParams defines parameters for creating a GithubRepository via a POST request.
type CreateGithubRepositoryParams struct {
	// The ID of the repository.
	RepoID int64 `json:"repo_id"`
	// The name of the repository.
	Name string `json:"name"`
	// The full name of the repository, which includes the owner.
	FullName string `json:"full_name"`
	// The username which owns the repository (user or organization).
	OwnerLogin string `json:"owner_login"`
	// The owner data of the repository.
	Owner *github.User `json:"owner"`
	// Whether the repository is public or not.
	Public *bool `json:"public"`
	// The URL of the repository.
	HTMLURL string `json:"html_url"`
	// The description of the repository.
	Description *string `json:"description,omitempty"`
	// Whether the repository is a fork or not.
	Fork *bool `json:"fork"`
	// The homepage of the repository.
	Homepage *string `json:"homepage,omitempty"`
	// The number of stars the repository has.
	StarCount *int `json:"star_count"`
	// The default branch of the repository.
	DefaultBranch string `json:"default_branch"`
	// Whether the repository is a template repo or not.
	IsTemplate *bool `json:"is_template"`
	// Whether the repository has issues enabled or not.
	HasIssues *bool `json:"has_issues"`
	// Whether the repository is archived or not.
	Archived *bool `json:"archived"`
	// The date the repository was last pushed to.
	PushedAt *time.Time `json:"pushed_at,omitempty"`
	// The date the repository was created.
	CreatedAt time.Time `json:"created_at"`
	// The date the repository was last updated.
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`
	License   **github.License `json:"license,omitempty"`
	Labels    []int            `json:"labels,omitempty"`
	Releases  []int            `json:"releases,omitempty"`
}

func (c *CreateGithubRepositoryParams) ApplyInputs(builder *ent.GithubRepositoryCreate) *ent.GithubRepositoryCreate {
	builder.SetRepoID(c.RepoID)
	builder.SetName(c.Name)
	builder.SetFullName(c.FullName)
	builder.SetOwnerLogin(c.OwnerLogin)
	builder.SetOwner(c.Owner)
	if c.Public != nil {
		builder.SetPublic(*c.Public)
	}
	builder.SetHTMLURL(c.HTMLURL)
	if c.Description != nil {
		builder.SetDescription(*c.Description)
	}
	if c.Fork != nil {
		builder.SetFork(*c.Fork)
	}
	if c.Homepage != nil {
		builder.SetHomepage(*c.Homepage)
	}
	if c.StarCount != nil {
		builder.SetStarCount(*c.StarCount)
	}
	builder.SetDefaultBranch(c.DefaultBranch)
	if c.IsTemplate != nil {
		builder.SetIsTemplate(*c.IsTemplate)
	}
	if c.HasIssues != nil {
		builder.SetHasIssues(*c.HasIssues)
	}
	if c.Archived != nil {
		builder.SetArchived(*c.Archived)
	}
	if c.PushedAt != nil {
		builder.SetPushedAt(*c.PushedAt)
	}
	builder.SetCreatedAt(c.CreatedAt)
	if c.UpdatedAt != nil {
		builder.SetUpdatedAt(*c.UpdatedAt)
	}
	if c.License != nil {
		builder.SetLicense(*c.License)
	}
	builder.AddLabelIDs(c.Labels...)
	builder.AddReleaseIDs(c.Releases...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateGithubRepositoryParams) Exec(ctx context.Context, builder *ent.GithubRepositoryCreate, query *ent.GithubRepositoryQuery) (*ent.GithubRepository, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadGithubRepository(query.Where(githubrepository.ID(result.ID))).Only(ctx)
}

// CreateLabelParams defines parameters for creating a Label via a POST request.
type CreateLabelParams struct {
	// Time the entity was created.
	CreateTime *time.Time `json:"create_time"`
	// Time the entity was last updated.
	UpdateTime *time.Time `json:"update_time"`
	// Label name.
	Name               string `json:"name"`
	Posts              []int  `json:"posts,omitempty"`
	GithubRepositories []int  `json:"github_repositories,omitempty"`
}

func (c *CreateLabelParams) ApplyInputs(builder *ent.LabelCreate) *ent.LabelCreate {
	if c.CreateTime != nil {
		builder.SetCreateTime(*c.CreateTime)
	}
	if c.UpdateTime != nil {
		builder.SetUpdateTime(*c.UpdateTime)
	}
	builder.SetName(c.Name)
	builder.AddPostIDs(c.Posts...)
	builder.AddGithubRepositoryIDs(c.GithubRepositories...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateLabelParams) Exec(ctx context.Context, builder *ent.LabelCreate, query *ent.LabelQuery) (*ent.Label, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadLabel(query.Where(label.ID(result.ID))).Only(ctx)
}

// CreatePostParams defines parameters for creating a Post via a POST request.
type CreatePostParams struct {
	// Time the entity was created.
	CreateTime *time.Time `json:"create_time"`
	// Time the entity was last updated.
	UpdateTime *time.Time `json:"update_time"`
	// Post slug.
	Slug string `json:"slug"`
	// Post title.
	Title string `json:"title"`
	// Post content in Markdown.
	Content     string     `json:"content"`
	PublishedAt *time.Time `json:"published_at"`
	// Whether the post is public or not.
	Public *bool `json:"public"`
	Author int   `json:"author"`
	Labels []int `json:"labels,omitempty"`
}

func (c *CreatePostParams) ApplyInputs(builder *ent.PostCreate) *ent.PostCreate {
	if c.CreateTime != nil {
		builder.SetCreateTime(*c.CreateTime)
	}
	if c.UpdateTime != nil {
		builder.SetUpdateTime(*c.UpdateTime)
	}
	builder.SetSlug(c.Slug)
	builder.SetTitle(c.Title)
	builder.SetContent(c.Content)
	if c.PublishedAt != nil {
		builder.SetPublishedAt(*c.PublishedAt)
	}
	if c.Public != nil {
		builder.SetPublic(*c.Public)
	}
	builder.SetAuthorID(c.Author)
	builder.AddLabelIDs(c.Labels...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreatePostParams) Exec(ctx context.Context, builder *ent.PostCreate, query *ent.PostQuery) (*ent.Post, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadPost(query.Where(post.ID(result.ID))).Only(ctx)
}

// CreateUserParams defines parameters for creating a User via a POST request.
type CreateUserParams struct {
	// Time the entity was created.
	CreateTime *time.Time `json:"create_time"`
	// Time the entity was last updated.
	UpdateTime *time.Time `json:"update_time"`
	// Users GitHub ID.
	UserID int `json:"user_id"`
	// Users GitHub login ID (username).
	Login string `json:"login"`
	// Users GitHub display name.
	Name *string `json:"name,omitempty"`
	// GitHub avatar of the user, provided by GitHub.
	AvatarURL *string `json:"avatar_url,omitempty"`
	// Users GitHub profile URL.
	HTMLURL *string `json:"html_url,omitempty"`
	// Users GitHub email address.
	Email *string `json:"email,omitempty"`
	// Users GitHub location.
	Location *string `json:"location,omitempty"`
	// Users GitHub bio.
	Bio   *string `json:"bio,omitempty"`
	Posts []int   `json:"posts,omitempty"`
}

func (c *CreateUserParams) ApplyInputs(builder *ent.UserCreate) *ent.UserCreate {
	if c.CreateTime != nil {
		builder.SetCreateTime(*c.CreateTime)
	}
	if c.UpdateTime != nil {
		builder.SetUpdateTime(*c.UpdateTime)
	}
	builder.SetUserID(c.UserID)
	builder.SetLogin(c.Login)
	if c.Name != nil {
		builder.SetName(*c.Name)
	}
	if c.AvatarURL != nil {
		builder.SetAvatarURL(*c.AvatarURL)
	}
	if c.HTMLURL != nil {
		builder.SetHTMLURL(*c.HTMLURL)
	}
	if c.Email != nil {
		builder.SetEmail(*c.Email)
	}
	if c.Location != nil {
		builder.SetLocation(*c.Location)
	}
	if c.Bio != nil {
		builder.SetBio(*c.Bio)
	}
	builder.AddPostIDs(c.Posts...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateUserParams) Exec(ctx context.Context, builder *ent.UserCreate, query *ent.UserQuery) (*ent.User, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadUser(query.Where(user.ID(result.ID))).Only(ctx)
}
